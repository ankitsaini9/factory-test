{"version":3,"sources":["../src/index.ts","../src/coin-quantity.ts","../src/__generated__/operations.ts","../src/provider.ts","../src/transaction-request/input.ts","../src/transaction-request/output.ts","../src/transaction-request/transaction-request.ts","../src/transaction-request/storage-slot.ts","../src/transaction-request/witness.ts","../src/transaction-response/transaction-response.ts","../src/util.ts"],"sourcesContent":["/// <reference types=\"graphql\" />\n\n// TODO: Remove when necessary members like `InputType` are wrapped in this package\nexport * from '@fuel-ts/transactions';\n\nexport * from './coin-quantity';\nexport * from './coin';\nexport * from './provider';\nexport { default as Provider } from './provider';\nexport * from './transaction-request';\nexport * from './transaction-response';\nexport * from './util';\n","import type { BytesLike } from '@ethersproject/bytes';\nimport { hexlify } from '@ethersproject/bytes';\nimport { NativeAssetId } from '@fuel-ts/constants';\nimport type { BigNumberish } from '@fuel-ts/math';\n\nexport type CoinQuantityLike =\n  | [amount: BigNumberish, assetId?: BytesLike]\n  | { amount: BigNumberish; assetId?: BytesLike };\nexport type CoinQuantity = { amount: bigint; assetId: string };\n\nexport const coinQuantityfy = (coinQuantityLike: CoinQuantityLike): CoinQuantity => {\n  let assetId;\n  let amount;\n  if (Array.isArray(coinQuantityLike)) {\n    amount = coinQuantityLike[0];\n    assetId = coinQuantityLike[1] ?? NativeAssetId;\n  } else {\n    amount = coinQuantityLike.amount;\n    assetId = coinQuantityLike.assetId ?? NativeAssetId;\n  }\n\n  return {\n    assetId: hexlify(assetId),\n    amount: BigInt(amount),\n  };\n};\n","import type { GraphQLClient } from 'graphql-request';\nimport type * as Dom from 'graphql-request/dist/types.dom';\nimport gql from 'graphql-tag';\n\nexport type Maybe<T> = T | null;\nexport type InputMaybe<T> = Maybe<T>;\nexport type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\nexport type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\nexport type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\n/** All built-in and custom scalars, mapped to their actual values */\nexport type Scalars = {\n  ID: string;\n  String: string;\n  Boolean: boolean;\n  Int: number;\n  Float: number;\n  Address: string;\n  AssetId: string;\n  BlockId: string;\n  Bytes32: string;\n  ContractId: string;\n  /**\n   * Implement the DateTime<Utc> scalar\n   *\n   * The input/output is a string in RFC3339 format.\n   */\n  DateTime: string;\n  HexString: string;\n  Salt: string;\n  TransactionId: string;\n  U64: string;\n  UtxoId: string;\n};\n\nexport type GqlBalance = {\n  __typename: 'Balance';\n  amount: Scalars['U64'];\n  assetId: Scalars['AssetId'];\n  owner: Scalars['Address'];\n};\n\nexport type GqlBalanceConnection = {\n  __typename: 'BalanceConnection';\n  /** A list of edges. */\n  edges: Array<GqlBalanceEdge>;\n  /** Information to aid in pagination. */\n  pageInfo: GqlPageInfo;\n};\n\n/** An edge in a connection. */\nexport type GqlBalanceEdge = {\n  __typename: 'BalanceEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String'];\n  /** \"The item at the end of the edge */\n  node: GqlBalance;\n};\n\nexport type GqlBalanceFilterInput = {\n  /** Filter coins based on the `owner` field */\n  owner: Scalars['Address'];\n};\n\nexport type GqlBlock = {\n  __typename: 'Block';\n  height: Scalars['U64'];\n  id: Scalars['BlockId'];\n  producer: Scalars['Address'];\n  time: Scalars['DateTime'];\n  transactions: Array<GqlTransaction>;\n};\n\nexport type GqlBlockConnection = {\n  __typename: 'BlockConnection';\n  /** A list of edges. */\n  edges: Array<GqlBlockEdge>;\n  /** Information to aid in pagination. */\n  pageInfo: GqlPageInfo;\n};\n\n/** An edge in a connection. */\nexport type GqlBlockEdge = {\n  __typename: 'BlockEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String'];\n  /** \"The item at the end of the edge */\n  node: GqlBlock;\n};\n\nexport type GqlBreakpoint = {\n  contract: Scalars['ContractId'];\n  pc: Scalars['U64'];\n};\n\nexport type GqlChainInfo = {\n  __typename: 'ChainInfo';\n  baseChainHeight: Scalars['U64'];\n  consensusParameters: GqlConsensusParameters;\n  latestBlock: GqlBlock;\n  name: Scalars['String'];\n  peerCount: Scalars['Int'];\n};\n\nexport type GqlChangeOutput = {\n  __typename: 'ChangeOutput';\n  amount: Scalars['U64'];\n  assetId: Scalars['AssetId'];\n  to: Scalars['Address'];\n};\n\nexport type GqlCoin = {\n  __typename: 'Coin';\n  amount: Scalars['U64'];\n  assetId: Scalars['AssetId'];\n  blockCreated: Scalars['U64'];\n  maturity: Scalars['U64'];\n  owner: Scalars['Address'];\n  status: GqlCoinStatus;\n  utxoId: Scalars['UtxoId'];\n};\n\nexport type GqlCoinConnection = {\n  __typename: 'CoinConnection';\n  /** A list of edges. */\n  edges: Array<GqlCoinEdge>;\n  /** Information to aid in pagination. */\n  pageInfo: GqlPageInfo;\n};\n\n/** An edge in a connection. */\nexport type GqlCoinEdge = {\n  __typename: 'CoinEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String'];\n  /** \"The item at the end of the edge */\n  node: GqlCoin;\n};\n\nexport type GqlCoinFilterInput = {\n  /** Asset ID of the coins */\n  assetId?: InputMaybe<Scalars['AssetId']>;\n  /** Address of the owner */\n  owner: Scalars['Address'];\n};\n\nexport type GqlCoinOutput = {\n  __typename: 'CoinOutput';\n  amount: Scalars['U64'];\n  assetId: Scalars['AssetId'];\n  to: Scalars['Address'];\n};\n\nexport enum GqlCoinStatus {\n  Spent = 'SPENT',\n  Unspent = 'UNSPENT',\n}\n\nexport type GqlConsensusParameters = {\n  __typename: 'ConsensusParameters';\n  contractMaxSize: Scalars['U64'];\n  gasPriceFactor: Scalars['U64'];\n  maxGasPerTx: Scalars['U64'];\n  maxInputs: Scalars['U64'];\n  maxOutputs: Scalars['U64'];\n  maxPredicateDataLength: Scalars['U64'];\n  maxPredicateLength: Scalars['U64'];\n  maxScriptDataLength: Scalars['U64'];\n  maxScriptLength: Scalars['U64'];\n  maxStaticContracts: Scalars['U64'];\n  maxStorageSlots: Scalars['U64'];\n  maxWitnesses: Scalars['U64'];\n};\n\nexport type GqlContract = {\n  __typename: 'Contract';\n  bytecode: Scalars['HexString'];\n  id: Scalars['ContractId'];\n  salt: Scalars['Salt'];\n};\n\nexport type GqlContractBalance = {\n  __typename: 'ContractBalance';\n  amount: Scalars['U64'];\n  assetId: Scalars['AssetId'];\n  contract: Scalars['ContractId'];\n};\n\nexport type GqlContractBalanceConnection = {\n  __typename: 'ContractBalanceConnection';\n  /** A list of edges. */\n  edges: Array<GqlContractBalanceEdge>;\n  /** Information to aid in pagination. */\n  pageInfo: GqlPageInfo;\n};\n\n/** An edge in a connection. */\nexport type GqlContractBalanceEdge = {\n  __typename: 'ContractBalanceEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String'];\n  /** \"The item at the end of the edge */\n  node: GqlContractBalance;\n};\n\nexport type GqlContractBalanceFilterInput = {\n  /** Filter assets based on the `contractId` field */\n  contract: Scalars['ContractId'];\n};\n\nexport type GqlContractCreated = {\n  __typename: 'ContractCreated';\n  contract: GqlContract;\n  stateRoot: Scalars['Bytes32'];\n};\n\nexport type GqlContractOutput = {\n  __typename: 'ContractOutput';\n  balanceRoot: Scalars['Bytes32'];\n  inputIndex: Scalars['Int'];\n  stateRoot: Scalars['Bytes32'];\n};\n\nexport type GqlFailureStatus = {\n  __typename: 'FailureStatus';\n  block: GqlBlock;\n  programState?: Maybe<GqlProgramState>;\n  reason: Scalars['String'];\n  time: Scalars['DateTime'];\n};\n\nexport type GqlInput = GqlInputCoin | GqlInputContract;\n\nexport type GqlInputCoin = {\n  __typename: 'InputCoin';\n  amount: Scalars['U64'];\n  assetId: Scalars['AssetId'];\n  maturity: Scalars['U64'];\n  owner: Scalars['Address'];\n  predicate: Scalars['HexString'];\n  predicateData: Scalars['HexString'];\n  utxoId: Scalars['UtxoId'];\n  witnessIndex: Scalars['Int'];\n};\n\nexport type GqlInputContract = {\n  __typename: 'InputContract';\n  balanceRoot: Scalars['Bytes32'];\n  contract: GqlContract;\n  stateRoot: Scalars['Bytes32'];\n  utxoId: Scalars['UtxoId'];\n};\n\nexport type GqlMutation = {\n  __typename: 'Mutation';\n  continueTx: GqlRunResult;\n  /** Execute a dry-run of the transaction using a fork of current state, no changes are committed. */\n  dryRun: Array<GqlReceipt>;\n  endSession: Scalars['Boolean'];\n  execute: Scalars['Boolean'];\n  reset: Scalars['Boolean'];\n  setBreakpoint: Scalars['Boolean'];\n  setSingleStepping: Scalars['Boolean'];\n  startSession: Scalars['ID'];\n  startTx: GqlRunResult;\n  /** Submits transaction to the txpool */\n  submit: GqlTransaction;\n};\n\nexport type GqlMutationContinueTxArgs = {\n  id: Scalars['ID'];\n};\n\nexport type GqlMutationDryRunArgs = {\n  tx: Scalars['HexString'];\n  utxoValidation?: InputMaybe<Scalars['Boolean']>;\n};\n\nexport type GqlMutationEndSessionArgs = {\n  id: Scalars['ID'];\n};\n\nexport type GqlMutationExecuteArgs = {\n  id: Scalars['ID'];\n  op: Scalars['String'];\n};\n\nexport type GqlMutationResetArgs = {\n  id: Scalars['ID'];\n};\n\nexport type GqlMutationSetBreakpointArgs = {\n  breakpoint: GqlBreakpoint;\n  id: Scalars['ID'];\n};\n\nexport type GqlMutationSetSingleSteppingArgs = {\n  enable: Scalars['Boolean'];\n  id: Scalars['ID'];\n};\n\nexport type GqlMutationStartTxArgs = {\n  id: Scalars['ID'];\n  txJson: Scalars['String'];\n};\n\nexport type GqlMutationSubmitArgs = {\n  tx: Scalars['HexString'];\n};\n\nexport type GqlNodeInfo = {\n  __typename: 'NodeInfo';\n  maxDepth: Scalars['U64'];\n  maxTx: Scalars['U64'];\n  minBytePrice: Scalars['U64'];\n  minGasPrice: Scalars['U64'];\n  nodeVersion: Scalars['String'];\n  predicates: Scalars['Boolean'];\n  utxoValidation: Scalars['Boolean'];\n  vmBacktrace: Scalars['Boolean'];\n};\n\nexport type GqlOutput =\n  | GqlChangeOutput\n  | GqlCoinOutput\n  | GqlContractCreated\n  | GqlContractOutput\n  | GqlVariableOutput\n  | GqlWithdrawalOutput;\n\n/**\n * A separate `Breakpoint` type to be used as an output, as a single\n * type cannot act as both input and output type in async-graphql\n */\nexport type GqlOutputBreakpoint = {\n  __typename: 'OutputBreakpoint';\n  contract: Scalars['ContractId'];\n  pc: Scalars['U64'];\n};\n\n/** Information about pagination in a connection */\nexport type GqlPageInfo = {\n  __typename: 'PageInfo';\n  /** When paginating forwards, the cursor to continue. */\n  endCursor?: Maybe<Scalars['String']>;\n  /** When paginating forwards, are there more items? */\n  hasNextPage: Scalars['Boolean'];\n  /** When paginating backwards, are there more items? */\n  hasPreviousPage: Scalars['Boolean'];\n  /** When paginating backwards, the cursor to continue. */\n  startCursor?: Maybe<Scalars['String']>;\n};\n\nexport type GqlProgramState = {\n  __typename: 'ProgramState';\n  data: Scalars['HexString'];\n  returnType: GqlReturnType;\n};\n\nexport type GqlQuery = {\n  __typename: 'Query';\n  balance: GqlBalance;\n  balances: GqlBalanceConnection;\n  block?: Maybe<GqlBlock>;\n  blocks: GqlBlockConnection;\n  chain: GqlChainInfo;\n  coin?: Maybe<GqlCoin>;\n  coins: GqlCoinConnection;\n  /**\n   * For each `spend_query`, get some spendable coins (of asset specified by the query) owned by\n   * `owner` that add up at least the query amount. The returned coins (UTXOs) are actual coins\n   * that can be spent. The number of coins (UXTOs) is optimized to prevent dust accumulation.\n   * Max number of UTXOS and excluded UTXOS can also be specified.\n   */\n  coinsToSpend: Array<GqlCoin>;\n  contract?: Maybe<GqlContract>;\n  contractBalance: GqlContractBalance;\n  contractBalances: GqlContractBalanceConnection;\n  /** Returns true when the GraphQL API is serving requests. */\n  health: Scalars['Boolean'];\n  memory: Scalars['String'];\n  nodeInfo: GqlNodeInfo;\n  register: Scalars['U64'];\n  transaction?: Maybe<GqlTransaction>;\n  transactions: GqlTransactionConnection;\n  transactionsByOwner: GqlTransactionConnection;\n};\n\nexport type GqlQueryBalanceArgs = {\n  assetId: Scalars['AssetId'];\n  owner: Scalars['Address'];\n};\n\nexport type GqlQueryBalancesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  filter: GqlBalanceFilterInput;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\nexport type GqlQueryBlockArgs = {\n  height?: InputMaybe<Scalars['U64']>;\n  id?: InputMaybe<Scalars['BlockId']>;\n};\n\nexport type GqlQueryBlocksArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\nexport type GqlQueryCoinArgs = {\n  utxoId: Scalars['UtxoId'];\n};\n\nexport type GqlQueryCoinsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  filter: GqlCoinFilterInput;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\nexport type GqlQueryCoinsToSpendArgs = {\n  excludedIds?: InputMaybe<Array<Scalars['UtxoId']>>;\n  maxInputs?: InputMaybe<Scalars['Int']>;\n  owner: Scalars['Address'];\n  spendQuery: Array<GqlSpendQueryElementInput>;\n};\n\nexport type GqlQueryContractArgs = {\n  id: Scalars['ContractId'];\n};\n\nexport type GqlQueryContractBalanceArgs = {\n  asset: Scalars['AssetId'];\n  contract: Scalars['ContractId'];\n};\n\nexport type GqlQueryContractBalancesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  filter: GqlContractBalanceFilterInput;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\nexport type GqlQueryMemoryArgs = {\n  id: Scalars['ID'];\n  size: Scalars['U64'];\n  start: Scalars['U64'];\n};\n\nexport type GqlQueryRegisterArgs = {\n  id: Scalars['ID'];\n  register: Scalars['U64'];\n};\n\nexport type GqlQueryTransactionArgs = {\n  id: Scalars['TransactionId'];\n};\n\nexport type GqlQueryTransactionsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\nexport type GqlQueryTransactionsByOwnerArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  owner: Scalars['Address'];\n};\n\nexport type GqlReceipt = {\n  __typename: 'Receipt';\n  amount?: Maybe<Scalars['U64']>;\n  assetId?: Maybe<Scalars['AssetId']>;\n  contract?: Maybe<GqlContract>;\n  data?: Maybe<Scalars['HexString']>;\n  digest?: Maybe<Scalars['Bytes32']>;\n  gas?: Maybe<Scalars['U64']>;\n  gasUsed?: Maybe<Scalars['U64']>;\n  is?: Maybe<Scalars['U64']>;\n  len?: Maybe<Scalars['U64']>;\n  param1?: Maybe<Scalars['U64']>;\n  param2?: Maybe<Scalars['U64']>;\n  pc?: Maybe<Scalars['U64']>;\n  ptr?: Maybe<Scalars['U64']>;\n  ra?: Maybe<Scalars['U64']>;\n  rawPayload: Scalars['HexString'];\n  rb?: Maybe<Scalars['U64']>;\n  rc?: Maybe<Scalars['U64']>;\n  rd?: Maybe<Scalars['U64']>;\n  reason?: Maybe<Scalars['U64']>;\n  receiptType: GqlReceiptType;\n  result?: Maybe<Scalars['U64']>;\n  to?: Maybe<GqlContract>;\n  toAddress?: Maybe<Scalars['Address']>;\n  val?: Maybe<Scalars['U64']>;\n};\n\nexport enum GqlReceiptType {\n  Call = 'CALL',\n  Log = 'LOG',\n  LogData = 'LOG_DATA',\n  Panic = 'PANIC',\n  Return = 'RETURN',\n  ReturnData = 'RETURN_DATA',\n  Revert = 'REVERT',\n  ScriptResult = 'SCRIPT_RESULT',\n  Transfer = 'TRANSFER',\n  TransferOut = 'TRANSFER_OUT',\n}\n\nexport enum GqlReturnType {\n  Return = 'RETURN',\n  ReturnData = 'RETURN_DATA',\n  Revert = 'REVERT',\n}\n\nexport type GqlRunResult = {\n  __typename: 'RunResult';\n  breakpoint?: Maybe<GqlOutputBreakpoint>;\n  state: GqlRunState;\n};\n\nexport enum GqlRunState {\n  /** Stopped on a breakpoint */\n  Breakpoint = 'BREAKPOINT',\n  /** All breakpoints have been processed, and the program has terminated */\n  Completed = 'COMPLETED',\n}\n\nexport type GqlSpendQueryElementInput = {\n  /** Target amount for the query */\n  amount: Scalars['U64'];\n  /** Asset ID of the coins */\n  assetId: Scalars['AssetId'];\n};\n\nexport type GqlSubmittedStatus = {\n  __typename: 'SubmittedStatus';\n  time: Scalars['DateTime'];\n};\n\nexport type GqlSuccessStatus = {\n  __typename: 'SuccessStatus';\n  block: GqlBlock;\n  programState: GqlProgramState;\n  time: Scalars['DateTime'];\n};\n\nexport type GqlTransaction = {\n  __typename: 'Transaction';\n  bytePrice: Scalars['U64'];\n  bytecodeLength?: Maybe<Scalars['U64']>;\n  bytecodeWitnessIndex?: Maybe<Scalars['Int']>;\n  gasLimit: Scalars['U64'];\n  gasPrice: Scalars['U64'];\n  id: Scalars['TransactionId'];\n  inputAssetIds: Array<Scalars['AssetId']>;\n  inputContracts: Array<GqlContract>;\n  inputs: Array<GqlInput>;\n  isScript: Scalars['Boolean'];\n  maturity: Scalars['U64'];\n  outputs: Array<GqlOutput>;\n  /** Return the transaction bytes using canonical encoding */\n  rawPayload: Scalars['HexString'];\n  receipts?: Maybe<Array<GqlReceipt>>;\n  receiptsRoot?: Maybe<Scalars['Bytes32']>;\n  salt?: Maybe<Scalars['Salt']>;\n  script?: Maybe<Scalars['HexString']>;\n  scriptData?: Maybe<Scalars['HexString']>;\n  staticContracts?: Maybe<Array<GqlContract>>;\n  status?: Maybe<GqlTransactionStatus>;\n  storageSlots?: Maybe<Array<Scalars['HexString']>>;\n  witnesses: Array<Scalars['HexString']>;\n};\n\nexport type GqlTransactionConnection = {\n  __typename: 'TransactionConnection';\n  /** A list of edges. */\n  edges: Array<GqlTransactionEdge>;\n  /** Information to aid in pagination. */\n  pageInfo: GqlPageInfo;\n};\n\n/** An edge in a connection. */\nexport type GqlTransactionEdge = {\n  __typename: 'TransactionEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String'];\n  /** \"The item at the end of the edge */\n  node: GqlTransaction;\n};\n\nexport type GqlTransactionStatus = GqlFailureStatus | GqlSubmittedStatus | GqlSuccessStatus;\n\nexport type GqlVariableOutput = {\n  __typename: 'VariableOutput';\n  amount: Scalars['U64'];\n  assetId: Scalars['AssetId'];\n  to: Scalars['Address'];\n};\n\nexport type GqlWithdrawalOutput = {\n  __typename: 'WithdrawalOutput';\n  amount: Scalars['U64'];\n  assetId: Scalars['AssetId'];\n  to: Scalars['Address'];\n};\n\nexport type GqlTransactionFragmentFragment = {\n  __typename: 'Transaction';\n  id: string;\n  rawPayload: string;\n  status?:\n    | {\n        __typename: 'FailureStatus';\n        time: string;\n        reason: string;\n        type: 'FailureStatus';\n        block: { __typename: 'Block'; id: string };\n      }\n    | { __typename: 'SubmittedStatus'; time: string; type: 'SubmittedStatus' }\n    | {\n        __typename: 'SuccessStatus';\n        time: string;\n        type: 'SuccessStatus';\n        block: { __typename: 'Block'; id: string };\n        programState: { __typename: 'ProgramState'; returnType: GqlReturnType; data: string };\n      }\n    | null;\n};\n\nexport type GqlReceiptFragmentFragment = {\n  __typename: 'Receipt';\n  data?: string | null;\n  rawPayload: string;\n};\n\nexport type GqlBlockFragmentFragment = {\n  __typename: 'Block';\n  id: string;\n  height: string;\n  producer: string;\n  time: string;\n  transactions: Array<{ __typename: 'Transaction'; id: string }>;\n};\n\nexport type GqlCoinFragmentFragment = {\n  __typename: 'Coin';\n  utxoId: string;\n  owner: string;\n  amount: string;\n  assetId: string;\n  maturity: string;\n  status: GqlCoinStatus;\n  blockCreated: string;\n};\n\nexport type GqlBalanceFragmentFragment = {\n  __typename: 'Balance';\n  owner: string;\n  amount: string;\n  assetId: string;\n};\n\nexport type GqlGetVersionQueryVariables = Exact<{ [key: string]: never }>;\n\nexport type GqlGetVersionQuery = {\n  __typename: 'Query';\n  nodeInfo: { __typename: 'NodeInfo'; nodeVersion: string };\n};\n\nexport type GqlGetChainQueryVariables = Exact<{ [key: string]: never }>;\n\nexport type GqlGetChainQuery = {\n  __typename: 'Query';\n  chain: {\n    __typename: 'ChainInfo';\n    name: string;\n    baseChainHeight: string;\n    peerCount: number;\n    latestBlock: {\n      __typename: 'Block';\n      id: string;\n      height: string;\n      producer: string;\n      time: string;\n      transactions: Array<{ __typename: 'Transaction'; id: string }>;\n    };\n  };\n};\n\nexport type GqlGetTransactionQueryVariables = Exact<{\n  transactionId: Scalars['TransactionId'];\n}>;\n\nexport type GqlGetTransactionQuery = {\n  __typename: 'Query';\n  transaction?: {\n    __typename: 'Transaction';\n    id: string;\n    rawPayload: string;\n    status?:\n      | {\n          __typename: 'FailureStatus';\n          time: string;\n          reason: string;\n          type: 'FailureStatus';\n          block: { __typename: 'Block'; id: string };\n        }\n      | { __typename: 'SubmittedStatus'; time: string; type: 'SubmittedStatus' }\n      | {\n          __typename: 'SuccessStatus';\n          time: string;\n          type: 'SuccessStatus';\n          block: { __typename: 'Block'; id: string };\n          programState: { __typename: 'ProgramState'; returnType: GqlReturnType; data: string };\n        }\n      | null;\n  } | null;\n};\n\nexport type GqlGetTransactionWithReceiptsQueryVariables = Exact<{\n  transactionId: Scalars['TransactionId'];\n}>;\n\nexport type GqlGetTransactionWithReceiptsQuery = {\n  __typename: 'Query';\n  transaction?: {\n    __typename: 'Transaction';\n    id: string;\n    rawPayload: string;\n    receipts?: Array<{ __typename: 'Receipt'; data?: string | null; rawPayload: string }> | null;\n    status?:\n      | {\n          __typename: 'FailureStatus';\n          time: string;\n          reason: string;\n          type: 'FailureStatus';\n          block: { __typename: 'Block'; id: string };\n        }\n      | { __typename: 'SubmittedStatus'; time: string; type: 'SubmittedStatus' }\n      | {\n          __typename: 'SuccessStatus';\n          time: string;\n          type: 'SuccessStatus';\n          block: { __typename: 'Block'; id: string };\n          programState: { __typename: 'ProgramState'; returnType: GqlReturnType; data: string };\n        }\n      | null;\n  } | null;\n};\n\nexport type GqlGetTransactionsQueryVariables = Exact<{\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n}>;\n\nexport type GqlGetTransactionsQuery = {\n  __typename: 'Query';\n  transactions: {\n    __typename: 'TransactionConnection';\n    edges: Array<{\n      __typename: 'TransactionEdge';\n      node: {\n        __typename: 'Transaction';\n        id: string;\n        rawPayload: string;\n        status?:\n          | {\n              __typename: 'FailureStatus';\n              time: string;\n              reason: string;\n              type: 'FailureStatus';\n              block: { __typename: 'Block'; id: string };\n            }\n          | { __typename: 'SubmittedStatus'; time: string; type: 'SubmittedStatus' }\n          | {\n              __typename: 'SuccessStatus';\n              time: string;\n              type: 'SuccessStatus';\n              block: { __typename: 'Block'; id: string };\n              programState: { __typename: 'ProgramState'; returnType: GqlReturnType; data: string };\n            }\n          | null;\n      };\n    }>;\n  };\n};\n\nexport type GqlGetTransactionsByOwnerQueryVariables = Exact<{\n  owner: Scalars['Address'];\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n}>;\n\nexport type GqlGetTransactionsByOwnerQuery = {\n  __typename: 'Query';\n  transactionsByOwner: {\n    __typename: 'TransactionConnection';\n    edges: Array<{\n      __typename: 'TransactionEdge';\n      node: {\n        __typename: 'Transaction';\n        id: string;\n        rawPayload: string;\n        status?:\n          | {\n              __typename: 'FailureStatus';\n              time: string;\n              reason: string;\n              type: 'FailureStatus';\n              block: { __typename: 'Block'; id: string };\n            }\n          | { __typename: 'SubmittedStatus'; time: string; type: 'SubmittedStatus' }\n          | {\n              __typename: 'SuccessStatus';\n              time: string;\n              type: 'SuccessStatus';\n              block: { __typename: 'Block'; id: string };\n              programState: { __typename: 'ProgramState'; returnType: GqlReturnType; data: string };\n            }\n          | null;\n      };\n    }>;\n  };\n};\n\nexport type GqlGetBlockQueryVariables = Exact<{\n  blockId?: InputMaybe<Scalars['BlockId']>;\n  blockHeight?: InputMaybe<Scalars['U64']>;\n}>;\n\nexport type GqlGetBlockQuery = {\n  __typename: 'Query';\n  block?: {\n    __typename: 'Block';\n    id: string;\n    height: string;\n    producer: string;\n    time: string;\n    transactions: Array<{ __typename: 'Transaction'; id: string }>;\n  } | null;\n};\n\nexport type GqlGetBlockWithTransactionsQueryVariables = Exact<{\n  blockId?: InputMaybe<Scalars['BlockId']>;\n  blockHeight?: InputMaybe<Scalars['U64']>;\n}>;\n\nexport type GqlGetBlockWithTransactionsQuery = {\n  __typename: 'Query';\n  block?: {\n    __typename: 'Block';\n    id: string;\n    height: string;\n    producer: string;\n    time: string;\n    transactions: Array<{\n      __typename: 'Transaction';\n      id: string;\n      rawPayload: string;\n      status?:\n        | {\n            __typename: 'FailureStatus';\n            time: string;\n            reason: string;\n            type: 'FailureStatus';\n            block: { __typename: 'Block'; id: string };\n          }\n        | { __typename: 'SubmittedStatus'; time: string; type: 'SubmittedStatus' }\n        | {\n            __typename: 'SuccessStatus';\n            time: string;\n            type: 'SuccessStatus';\n            block: { __typename: 'Block'; id: string };\n            programState: { __typename: 'ProgramState'; returnType: GqlReturnType; data: string };\n          }\n        | null;\n    }>;\n  } | null;\n};\n\nexport type GqlGetBlocksQueryVariables = Exact<{\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n}>;\n\nexport type GqlGetBlocksQuery = {\n  __typename: 'Query';\n  blocks: {\n    __typename: 'BlockConnection';\n    edges: Array<{\n      __typename: 'BlockEdge';\n      node: {\n        __typename: 'Block';\n        id: string;\n        height: string;\n        producer: string;\n        time: string;\n        transactions: Array<{ __typename: 'Transaction'; id: string }>;\n      };\n    }>;\n  };\n};\n\nexport type GqlGetCoinQueryVariables = Exact<{\n  coinId: Scalars['UtxoId'];\n}>;\n\nexport type GqlGetCoinQuery = {\n  __typename: 'Query';\n  coin?: {\n    __typename: 'Coin';\n    utxoId: string;\n    owner: string;\n    amount: string;\n    assetId: string;\n    maturity: string;\n    status: GqlCoinStatus;\n    blockCreated: string;\n  } | null;\n};\n\nexport type GqlGetCoinsQueryVariables = Exact<{\n  filter: GqlCoinFilterInput;\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n}>;\n\nexport type GqlGetCoinsQuery = {\n  __typename: 'Query';\n  coins: {\n    __typename: 'CoinConnection';\n    edges: Array<{\n      __typename: 'CoinEdge';\n      node: {\n        __typename: 'Coin';\n        utxoId: string;\n        owner: string;\n        amount: string;\n        assetId: string;\n        maturity: string;\n        status: GqlCoinStatus;\n        blockCreated: string;\n      };\n    }>;\n  };\n};\n\nexport type GqlGetCoinsToSpendQueryVariables = Exact<{\n  owner: Scalars['Address'];\n  spendQuery: Array<GqlSpendQueryElementInput> | GqlSpendQueryElementInput;\n  maxInputs?: InputMaybe<Scalars['Int']>;\n}>;\n\nexport type GqlGetCoinsToSpendQuery = {\n  __typename: 'Query';\n  coinsToSpend: Array<{\n    __typename: 'Coin';\n    utxoId: string;\n    owner: string;\n    amount: string;\n    assetId: string;\n    maturity: string;\n    status: GqlCoinStatus;\n    blockCreated: string;\n  }>;\n};\n\nexport type GqlGetContractQueryVariables = Exact<{\n  contractId: Scalars['ContractId'];\n}>;\n\nexport type GqlGetContractQuery = {\n  __typename: 'Query';\n  contract?: { __typename: 'Contract'; bytecode: string; id: string } | null;\n};\n\nexport type GqlGetBalanceQueryVariables = Exact<{\n  owner: Scalars['Address'];\n  assetId: Scalars['AssetId'];\n}>;\n\nexport type GqlGetBalanceQuery = {\n  __typename: 'Query';\n  balance: { __typename: 'Balance'; owner: string; amount: string; assetId: string };\n};\n\nexport type GqlGetBalancesQueryVariables = Exact<{\n  filter: GqlBalanceFilterInput;\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n}>;\n\nexport type GqlGetBalancesQuery = {\n  __typename: 'Query';\n  balances: {\n    __typename: 'BalanceConnection';\n    edges: Array<{\n      __typename: 'BalanceEdge';\n      node: { __typename: 'Balance'; owner: string; amount: string; assetId: string };\n    }>;\n  };\n};\n\nexport type GqlDryRunMutationVariables = Exact<{\n  encodedTransaction: Scalars['HexString'];\n  utxoValidation?: InputMaybe<Scalars['Boolean']>;\n}>;\n\nexport type GqlDryRunMutation = {\n  __typename: 'Mutation';\n  dryRun: Array<{ __typename: 'Receipt'; data?: string | null; rawPayload: string }>;\n};\n\nexport type GqlSubmitMutationVariables = Exact<{\n  encodedTransaction: Scalars['HexString'];\n}>;\n\nexport type GqlSubmitMutation = {\n  __typename: 'Mutation';\n  submit: { __typename: 'Transaction'; id: string };\n};\n\nexport type GqlStartSessionMutationVariables = Exact<{ [key: string]: never }>;\n\nexport type GqlStartSessionMutation = { __typename: 'Mutation'; startSession: string };\n\nexport type GqlEndSessionMutationVariables = Exact<{\n  sessionId: Scalars['ID'];\n}>;\n\nexport type GqlEndSessionMutation = { __typename: 'Mutation'; endSession: boolean };\n\nexport type GqlExecuteMutationVariables = Exact<{\n  sessionId: Scalars['ID'];\n  op: Scalars['String'];\n}>;\n\nexport type GqlExecuteMutation = { __typename: 'Mutation'; execute: boolean };\n\nexport type GqlResetMutationVariables = Exact<{\n  sessionId: Scalars['ID'];\n}>;\n\nexport type GqlResetMutation = { __typename: 'Mutation'; reset: boolean };\n\nexport const TransactionFragmentFragmentDoc = gql`\n  fragment transactionFragment on Transaction {\n    id\n    rawPayload\n    status {\n      type: __typename\n      ... on SubmittedStatus {\n        time\n      }\n      ... on SuccessStatus {\n        block {\n          id\n        }\n        time\n        programState {\n          returnType\n          data\n        }\n      }\n      ... on FailureStatus {\n        block {\n          id\n        }\n        time\n        reason\n      }\n    }\n  }\n`;\nexport const ReceiptFragmentFragmentDoc = gql`\n  fragment receiptFragment on Receipt {\n    data\n    rawPayload\n  }\n`;\nexport const BlockFragmentFragmentDoc = gql`\n  fragment blockFragment on Block {\n    id\n    height\n    producer\n    transactions {\n      id\n    }\n    time\n  }\n`;\nexport const CoinFragmentFragmentDoc = gql`\n  fragment coinFragment on Coin {\n    utxoId\n    owner\n    amount\n    assetId\n    maturity\n    status\n    blockCreated\n  }\n`;\nexport const BalanceFragmentFragmentDoc = gql`\n  fragment balanceFragment on Balance {\n    owner\n    amount\n    assetId\n  }\n`;\nexport const GetVersionDocument = gql`\n  query getVersion {\n    nodeInfo {\n      nodeVersion\n    }\n  }\n`;\nexport const GetChainDocument = gql`\n  query getChain {\n    chain {\n      name\n      latestBlock {\n        ...blockFragment\n      }\n      baseChainHeight\n      peerCount\n    }\n  }\n  ${BlockFragmentFragmentDoc}\n`;\nexport const GetTransactionDocument = gql`\n  query getTransaction($transactionId: TransactionId!) {\n    transaction(id: $transactionId) {\n      ...transactionFragment\n    }\n  }\n  ${TransactionFragmentFragmentDoc}\n`;\nexport const GetTransactionWithReceiptsDocument = gql`\n  query getTransactionWithReceipts($transactionId: TransactionId!) {\n    transaction(id: $transactionId) {\n      ...transactionFragment\n      receipts {\n        ...receiptFragment\n      }\n    }\n  }\n  ${TransactionFragmentFragmentDoc}\n  ${ReceiptFragmentFragmentDoc}\n`;\nexport const GetTransactionsDocument = gql`\n  query getTransactions($after: String, $before: String, $first: Int, $last: Int) {\n    transactions(after: $after, before: $before, first: $first, last: $last) {\n      edges {\n        node {\n          ...transactionFragment\n        }\n      }\n    }\n  }\n  ${TransactionFragmentFragmentDoc}\n`;\nexport const GetTransactionsByOwnerDocument = gql`\n  query getTransactionsByOwner(\n    $owner: Address!\n    $after: String\n    $before: String\n    $first: Int\n    $last: Int\n  ) {\n    transactionsByOwner(owner: $owner, after: $after, before: $before, first: $first, last: $last) {\n      edges {\n        node {\n          ...transactionFragment\n        }\n      }\n    }\n  }\n  ${TransactionFragmentFragmentDoc}\n`;\nexport const GetBlockDocument = gql`\n  query getBlock($blockId: BlockId, $blockHeight: U64) {\n    block(id: $blockId, height: $blockHeight) {\n      ...blockFragment\n    }\n  }\n  ${BlockFragmentFragmentDoc}\n`;\nexport const GetBlockWithTransactionsDocument = gql`\n  query getBlockWithTransactions($blockId: BlockId, $blockHeight: U64) {\n    block(id: $blockId, height: $blockHeight) {\n      ...blockFragment\n      transactions {\n        ...transactionFragment\n      }\n    }\n  }\n  ${BlockFragmentFragmentDoc}\n  ${TransactionFragmentFragmentDoc}\n`;\nexport const GetBlocksDocument = gql`\n  query getBlocks($after: String, $before: String, $first: Int, $last: Int) {\n    blocks(after: $after, before: $before, first: $first, last: $last) {\n      edges {\n        node {\n          ...blockFragment\n        }\n      }\n    }\n  }\n  ${BlockFragmentFragmentDoc}\n`;\nexport const GetCoinDocument = gql`\n  query getCoin($coinId: UtxoId!) {\n    coin(utxoId: $coinId) {\n      ...coinFragment\n    }\n  }\n  ${CoinFragmentFragmentDoc}\n`;\nexport const GetCoinsDocument = gql`\n  query getCoins(\n    $filter: CoinFilterInput!\n    $after: String\n    $before: String\n    $first: Int\n    $last: Int\n  ) {\n    coins(filter: $filter, after: $after, before: $before, first: $first, last: $last) {\n      edges {\n        node {\n          ...coinFragment\n        }\n      }\n    }\n  }\n  ${CoinFragmentFragmentDoc}\n`;\nexport const GetCoinsToSpendDocument = gql`\n  query getCoinsToSpend(\n    $owner: Address!\n    $spendQuery: [SpendQueryElementInput!]!\n    $maxInputs: Int\n  ) {\n    coinsToSpend(owner: $owner, spendQuery: $spendQuery, maxInputs: $maxInputs) {\n      ...coinFragment\n    }\n  }\n  ${CoinFragmentFragmentDoc}\n`;\nexport const GetContractDocument = gql`\n  query getContract($contractId: ContractId!) {\n    contract(id: $contractId) {\n      bytecode\n      id\n    }\n  }\n`;\nexport const GetBalanceDocument = gql`\n  query getBalance($owner: Address!, $assetId: AssetId!) {\n    balance(owner: $owner, assetId: $assetId) {\n      ...balanceFragment\n    }\n  }\n  ${BalanceFragmentFragmentDoc}\n`;\nexport const GetBalancesDocument = gql`\n  query getBalances(\n    $filter: BalanceFilterInput!\n    $after: String\n    $before: String\n    $first: Int\n    $last: Int\n  ) {\n    balances(filter: $filter, after: $after, before: $before, first: $first, last: $last) {\n      edges {\n        node {\n          ...balanceFragment\n        }\n      }\n    }\n  }\n  ${BalanceFragmentFragmentDoc}\n`;\nexport const DryRunDocument = gql`\n  mutation dryRun($encodedTransaction: HexString!, $utxoValidation: Boolean) {\n    dryRun(tx: $encodedTransaction, utxoValidation: $utxoValidation) {\n      ...receiptFragment\n    }\n  }\n  ${ReceiptFragmentFragmentDoc}\n`;\nexport const SubmitDocument = gql`\n  mutation submit($encodedTransaction: HexString!) {\n    submit(tx: $encodedTransaction) {\n      id\n    }\n  }\n`;\nexport const StartSessionDocument = gql`\n  mutation startSession {\n    startSession\n  }\n`;\nexport const EndSessionDocument = gql`\n  mutation endSession($sessionId: ID!) {\n    endSession(id: $sessionId)\n  }\n`;\nexport const ExecuteDocument = gql`\n  mutation execute($sessionId: ID!, $op: String!) {\n    execute(id: $sessionId, op: $op)\n  }\n`;\nexport const ResetDocument = gql`\n  mutation reset($sessionId: ID!) {\n    reset(id: $sessionId)\n  }\n`;\n\nexport type SdkFunctionWrapper = <T>(\n  action: (requestHeaders?: Record<string, string>) => Promise<T>,\n  operationName: string,\n  operationType?: string\n) => Promise<T>;\n\nconst defaultWrapper: SdkFunctionWrapper = (action, _operationName, _operationType) => action();\n\nexport function getSdk(client: GraphQLClient, withWrapper: SdkFunctionWrapper = defaultWrapper) {\n  return {\n    getVersion(\n      variables?: GqlGetVersionQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetVersionQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetVersionQuery>(GetVersionDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getVersion',\n        'query'\n      );\n    },\n    getChain(\n      variables?: GqlGetChainQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetChainQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetChainQuery>(GetChainDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getChain',\n        'query'\n      );\n    },\n    getTransaction(\n      variables: GqlGetTransactionQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetTransactionQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetTransactionQuery>(GetTransactionDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getTransaction',\n        'query'\n      );\n    },\n    getTransactionWithReceipts(\n      variables: GqlGetTransactionWithReceiptsQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetTransactionWithReceiptsQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetTransactionWithReceiptsQuery>(\n            GetTransactionWithReceiptsDocument,\n            variables,\n            { ...requestHeaders, ...wrappedRequestHeaders }\n          ),\n        'getTransactionWithReceipts',\n        'query'\n      );\n    },\n    getTransactions(\n      variables?: GqlGetTransactionsQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetTransactionsQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetTransactionsQuery>(GetTransactionsDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getTransactions',\n        'query'\n      );\n    },\n    getTransactionsByOwner(\n      variables: GqlGetTransactionsByOwnerQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetTransactionsByOwnerQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetTransactionsByOwnerQuery>(\n            GetTransactionsByOwnerDocument,\n            variables,\n            { ...requestHeaders, ...wrappedRequestHeaders }\n          ),\n        'getTransactionsByOwner',\n        'query'\n      );\n    },\n    getBlock(\n      variables?: GqlGetBlockQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetBlockQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetBlockQuery>(GetBlockDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getBlock',\n        'query'\n      );\n    },\n    getBlockWithTransactions(\n      variables?: GqlGetBlockWithTransactionsQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetBlockWithTransactionsQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetBlockWithTransactionsQuery>(\n            GetBlockWithTransactionsDocument,\n            variables,\n            { ...requestHeaders, ...wrappedRequestHeaders }\n          ),\n        'getBlockWithTransactions',\n        'query'\n      );\n    },\n    getBlocks(\n      variables?: GqlGetBlocksQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetBlocksQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetBlocksQuery>(GetBlocksDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getBlocks',\n        'query'\n      );\n    },\n    getCoin(\n      variables: GqlGetCoinQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetCoinQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetCoinQuery>(GetCoinDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getCoin',\n        'query'\n      );\n    },\n    getCoins(\n      variables: GqlGetCoinsQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetCoinsQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetCoinsQuery>(GetCoinsDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getCoins',\n        'query'\n      );\n    },\n    getCoinsToSpend(\n      variables: GqlGetCoinsToSpendQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetCoinsToSpendQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetCoinsToSpendQuery>(GetCoinsToSpendDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getCoinsToSpend',\n        'query'\n      );\n    },\n    getContract(\n      variables: GqlGetContractQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetContractQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetContractQuery>(GetContractDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getContract',\n        'query'\n      );\n    },\n    getBalance(\n      variables: GqlGetBalanceQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetBalanceQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetBalanceQuery>(GetBalanceDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getBalance',\n        'query'\n      );\n    },\n    getBalances(\n      variables: GqlGetBalancesQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetBalancesQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetBalancesQuery>(GetBalancesDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getBalances',\n        'query'\n      );\n    },\n    dryRun(\n      variables: GqlDryRunMutationVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlDryRunMutation> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlDryRunMutation>(DryRunDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'dryRun',\n        'mutation'\n      );\n    },\n    submit(\n      variables: GqlSubmitMutationVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlSubmitMutation> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlSubmitMutation>(SubmitDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'submit',\n        'mutation'\n      );\n    },\n    startSession(\n      variables?: GqlStartSessionMutationVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlStartSessionMutation> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlStartSessionMutation>(StartSessionDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'startSession',\n        'mutation'\n      );\n    },\n    endSession(\n      variables: GqlEndSessionMutationVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlEndSessionMutation> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlEndSessionMutation>(EndSessionDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'endSession',\n        'mutation'\n      );\n    },\n    execute(\n      variables: GqlExecuteMutationVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlExecuteMutation> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlExecuteMutation>(ExecuteDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'execute',\n        'mutation'\n      );\n    },\n    reset(\n      variables: GqlResetMutationVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlResetMutation> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlResetMutation>(ResetDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'reset',\n        'mutation'\n      );\n    },\n  };\n}\nexport type Sdk = ReturnType<typeof getSdk>;\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport type { BytesLike } from '@ethersproject/bytes';\nimport { arrayify, hexlify } from '@ethersproject/bytes';\nimport type { Network } from '@ethersproject/networks';\nimport type { Transaction } from '@fuel-ts/transactions';\nimport { ReceiptType, ReceiptCoder, TransactionCoder } from '@fuel-ts/transactions';\nimport { GraphQLClient } from 'graphql-request';\n\nimport type { GqlReceiptFragmentFragment } from './__generated__/operations';\nimport { getSdk as getOperationsSdk } from './__generated__/operations';\nimport type { Coin } from './coin';\nimport type { CoinQuantity, CoinQuantityLike } from './coin-quantity';\nimport { coinQuantityfy } from './coin-quantity';\nimport { transactionRequestify } from './transaction-request';\nimport type { TransactionRequestLike } from './transaction-request';\nimport type { TransactionResultReceipt } from './transaction-response/transaction-response';\nimport { TransactionResponse } from './transaction-response/transaction-response';\n\nexport type CallResult = {\n  receipts: TransactionResultReceipt[];\n};\n\n/**\n * A Fuel block\n */\nexport type Block = {\n  id: string;\n  height: bigint;\n  time: string;\n  producer: string;\n  transactionIds: string[];\n};\n\n/**\n * Deployed Contract bytecode and contract id\n */\nexport type ContractResult = {\n  id: string;\n  bytecode: string;\n};\n\nconst processGqlReceipt = (gqlReceipt: GqlReceiptFragmentFragment): TransactionResultReceipt => {\n  const receipt = new ReceiptCoder().decode(arrayify(gqlReceipt.rawPayload), 0)[0];\n\n  switch (receipt.type) {\n    case ReceiptType.ReturnData: {\n      return {\n        ...receipt,\n        data: gqlReceipt.data!,\n      };\n    }\n    case ReceiptType.LogData: {\n      return {\n        ...receipt,\n        data: gqlReceipt.data!,\n      };\n    }\n    default:\n      return receipt;\n  }\n};\n\n/**\n * Cursor pagination arguments\n *\n * https://relay.dev/graphql/connections.htm#sec-Arguments\n */\nexport type CursorPaginationArgs = {\n  /** Forward pagination limit */\n  first?: number | null;\n  /** Forward pagination cursor */\n  after?: string | null;\n  /** Backward pagination limit  */\n  last?: number | null;\n  /** Backward pagination cursor */\n  before?: string | null;\n};\n\n/**\n * Provider Call transaction params\n */\nexport type ProviderCallParams = {\n  utxoValidation?: boolean;\n};\n\n/**\n * A provider for connecting to a Fuel node\n */\nexport default class Provider {\n  operations: ReturnType<typeof getOperationsSdk>;\n\n  constructor(\n    /** GraphQL endpoint of the Fuel node */\n    public url: string\n  ) {\n    const gqlClient = new GraphQLClient(url);\n    this.operations = getOperationsSdk(gqlClient);\n  }\n\n  /**\n   * Returns the version of the connected Fuel node\n   */\n  async getVersion(): Promise<string> {\n    const {\n      nodeInfo: { nodeVersion },\n    } = await this.operations.getVersion();\n    return nodeVersion;\n  }\n\n  /**\n   * Returns the network configuration of the connected Fuel node\n   */\n  async getNetwork(): Promise<Network> {\n    return {\n      name: 'fuelv2',\n      chainId: 0xdeadbeef,\n    };\n  }\n\n  /**\n   * Returns the current block number\n   */\n  async getBlockNumber(): Promise<bigint> {\n    const { chain } = await this.operations.getChain();\n    return BigInt(chain.latestBlock.height);\n  }\n\n  /**\n   * Submits a transaction to the chain to be executed\n   */\n  async sendTransaction(\n    transactionRequestLike: TransactionRequestLike\n  ): Promise<TransactionResponse> {\n    const transactionRequest = transactionRequestify(transactionRequestLike);\n    const encodedTransaction = hexlify(transactionRequest.toTransactionBytes());\n    const {\n      submit: { id: transactionId },\n    } = await this.operations.submit({ encodedTransaction });\n\n    const response = new TransactionResponse(transactionId, transactionRequest, this);\n    return response;\n  }\n\n  /**\n   * Executes a transaction without actually submitting it to the chain\n   */\n  async call(\n    transactionRequestLike: TransactionRequestLike,\n    { utxoValidation }: ProviderCallParams = {}\n  ): Promise<CallResult> {\n    const transactionRequest = transactionRequestify(transactionRequestLike);\n    const encodedTransaction = hexlify(transactionRequest.toTransactionBytes());\n    const { dryRun: gqlReceipts } = await this.operations.dryRun({\n      encodedTransaction,\n      utxoValidation: utxoValidation || false,\n    });\n    const receipts = gqlReceipts.map(processGqlReceipt);\n    return {\n      receipts,\n    };\n  }\n\n  /**\n   * Returns coins for the given owner\n   */\n  async getCoins(\n    /** The address to get coins for */\n    owner: BytesLike,\n    /** The asset ID of coins to get */\n    assetId?: BytesLike,\n    /** Pagination arguments */\n    paginationArgs?: CursorPaginationArgs\n  ): Promise<Coin[]> {\n    const result = await this.operations.getCoins({\n      first: 10,\n      ...paginationArgs,\n      filter: { owner: hexlify(owner), assetId: assetId && hexlify(assetId) },\n    });\n\n    const coins = result.coins.edges!.map((edge) => edge!.node!);\n\n    return coins.map((coin) => ({\n      id: coin.utxoId,\n      assetId: coin.assetId,\n      amount: BigInt(coin.amount),\n      owner: coin.owner,\n      status: coin.status,\n      maturity: BigInt(coin.maturity),\n      blockCreated: BigInt(coin.blockCreated),\n    }));\n  }\n\n  /**\n   * Returns coins for the given owner satisfying the spend query\n   */\n  async getCoinsToSpend(\n    /** The address to get coins for */\n    owner: BytesLike,\n    /** The quantitites to get */\n    quantities: CoinQuantityLike[],\n    /** Maximum number of coins to return */\n    maxInputs?: number\n  ): Promise<Coin[]> {\n    const result = await this.operations.getCoinsToSpend({\n      owner: hexlify(owner),\n      spendQuery: quantities.map(coinQuantityfy).map((quantity) => ({\n        assetId: hexlify(quantity.assetId),\n        amount: quantity.amount.toString(),\n      })),\n      maxInputs,\n    });\n\n    const coins = result.coinsToSpend;\n\n    return coins.map((coin) => ({\n      id: coin.utxoId,\n      status: coin.status,\n      assetId: coin.assetId,\n      amount: BigInt(coin.amount),\n      owner: coin.owner,\n      maturity: BigInt(coin.maturity),\n      blockCreated: BigInt(coin.blockCreated),\n    }));\n  }\n\n  /**\n   * Returns block matching the given ID or type\n   */\n  async getBlock(\n    /** ID or height of the block */\n    idOrHeight: string | number | 'latest'\n  ): Promise<Block | null> {\n    let variables;\n    if (typeof idOrHeight === 'number') {\n      variables = { blockHeight: BigInt(idOrHeight).toString() };\n    } else if (idOrHeight === 'latest') {\n      variables = { blockHeight: (await this.getBlockNumber()).toString() };\n    } else {\n      variables = { blockId: idOrHeight };\n    }\n\n    const { block } = await this.operations.getBlock(variables);\n\n    if (!block) {\n      return null;\n    }\n\n    return {\n      id: block.id,\n      height: BigInt(block.height),\n      time: block.time,\n      producer: block.producer,\n      transactionIds: block.transactions.map((tx) => tx.id),\n    };\n  }\n\n  /**\n   * Returns block matching the given ID or type, including transaction data\n   */\n  async getBlockWithTransactions(\n    /** ID or height of the block */\n    idOrHeight: string | number | 'latest'\n  ): Promise<(Block & { transactions: Transaction[] }) | null> {\n    let variables;\n    if (typeof idOrHeight === 'number') {\n      variables = { blockHeight: BigInt(idOrHeight).toString() };\n    } else if (idOrHeight === 'latest') {\n      variables = { blockHeight: (await this.getBlockNumber()).toString() };\n    } else {\n      variables = { blockId: idOrHeight };\n    }\n\n    const { block } = await this.operations.getBlockWithTransactions(variables);\n\n    if (!block) {\n      return null;\n    }\n\n    return {\n      id: block.id,\n      height: BigInt(block.height),\n      time: block.time,\n      producer: block.producer,\n      transactionIds: block.transactions.map((tx) => tx.id),\n      transactions: block.transactions.map(\n        (tx) => new TransactionCoder().decode(arrayify(tx.rawPayload), 0)?.[0]\n      ),\n    };\n  }\n\n  /**\n   * Get transaction with the given ID\n   */\n  async getTransaction(transactionId: string): Promise<Transaction | null> {\n    const { transaction } = await this.operations.getTransaction({ transactionId });\n    if (!transaction) {\n      return null;\n    }\n    return new TransactionCoder().decode(arrayify(transaction.rawPayload), 0)?.[0];\n  }\n\n  /**\n   * Get deployed contract with the given ID\n   *\n   * @returns contract bytecode and contract id\n   */\n  async getContract(contractId: string): Promise<ContractResult | null> {\n    const { contract } = await this.operations.getContract({ contractId });\n    if (!contract) {\n      return null;\n    }\n    return contract;\n  }\n\n  /**\n   * Returns the balance for the given owner for the given asset ID\n   */\n  async getBalance(\n    /** The address to get coins for */\n    owner: BytesLike,\n    /** The asset ID of coins to get */\n    assetId: BytesLike\n  ): Promise<bigint> {\n    const { balance } = await this.operations.getBalance({\n      owner: hexlify(owner),\n      assetId: hexlify(assetId),\n    });\n    return BigInt(balance.amount);\n  }\n\n  /**\n   * Returns balances for the given owner\n   */\n  async getBalances(\n    /** The address to get coins for */\n    owner: BytesLike,\n    /** Pagination arguments */\n    paginationArgs?: CursorPaginationArgs\n  ): Promise<CoinQuantity[]> {\n    const result = await this.operations.getBalances({\n      first: 10,\n      ...paginationArgs,\n      filter: { owner: hexlify(owner) },\n    });\n\n    const balances = result.balances.edges!.map((edge) => edge!.node!);\n\n    return balances.map((balance) => ({\n      assetId: balance.assetId,\n      amount: BigInt(balance.amount),\n    }));\n  }\n}\n","import type { BytesLike } from '@ethersproject/bytes';\nimport { arrayify, hexlify } from '@ethersproject/bytes';\nimport { ZeroBytes32 } from '@fuel-ts/constants';\nimport type { BigNumberish } from '@fuel-ts/math';\nimport type { Input } from '@fuel-ts/transactions';\nimport { InputType } from '@fuel-ts/transactions';\n\nexport type CoinTransactionRequestInput = {\n  type: InputType.Coin;\n  /** UTXO ID */\n  id: BytesLike;\n  /** Owning address or script hash */\n  owner: BytesLike;\n  /** Amount of coins */\n  amount: BigNumberish;\n  /** Asset ID of the coins */\n  assetId: BytesLike;\n  /** Index of witness that authorizes spending the coin */\n  witnessIndex: number;\n  /** UTXO being spent must have been created at least this many blocks ago */\n  maturity?: BigNumberish;\n  /** Predicate bytecode */\n  predicate?: BytesLike;\n  /** Predicate input data (parameters) */\n  predicateData?: BytesLike;\n};\nexport type ContractTransactionRequestInput = {\n  type: InputType.Contract;\n  /** Contract ID */\n  contractId: BytesLike;\n};\nexport type TransactionRequestInput = CoinTransactionRequestInput | ContractTransactionRequestInput;\n\nexport const inputify = (value: TransactionRequestInput): Input => {\n  switch (value.type) {\n    case InputType.Coin: {\n      const predicate = arrayify(value.predicate ?? '0x');\n      const predicateData = arrayify(value.predicateData ?? '0x');\n      return {\n        type: InputType.Coin,\n        utxoID: {\n          transactionId: hexlify(arrayify(value.id).slice(0, 32)),\n          outputIndex: arrayify(value.id)[32],\n        },\n        owner: hexlify(value.owner),\n        amount: BigInt(value.amount),\n        assetId: hexlify(value.assetId),\n        witnessIndex: value.witnessIndex,\n        maturity: BigInt(value.maturity ?? 0),\n        predicateLength: predicate.length,\n        predicateDataLength: predicateData.length,\n        predicate: hexlify(predicate),\n        predicateData: hexlify(predicateData),\n      };\n    }\n    case InputType.Contract: {\n      return {\n        type: InputType.Contract,\n        utxoID: {\n          transactionId: ZeroBytes32,\n          outputIndex: 0,\n        },\n        balanceRoot: ZeroBytes32,\n        stateRoot: ZeroBytes32,\n        contractID: hexlify(value.contractId),\n      };\n    }\n    default: {\n      throw new Error('Invalid Input type');\n    }\n  }\n};\n","import type { BytesLike } from '@ethersproject/bytes';\nimport { hexlify } from '@ethersproject/bytes';\nimport { ZeroBytes32 } from '@fuel-ts/constants';\nimport type { BigNumberish } from '@fuel-ts/math';\nimport type { Output } from '@fuel-ts/transactions';\nimport { OutputType } from '@fuel-ts/transactions';\n\nexport type CoinTransactionRequestOutput = {\n  type: OutputType.Coin;\n  /** Receiving address or script hash */\n  to: BytesLike;\n  /** Amount of coins to send */\n  amount: BigNumberish;\n  /** Asset ID of coins */\n  assetId: BytesLike;\n};\nexport type ContractTransactionRequestOutput = {\n  type: OutputType.Contract;\n  /** Index of input contract */\n  inputIndex: number;\n};\nexport type WithdrawalTransactionRequestOutput = {\n  type: OutputType.Withdrawal;\n  /** Receiving address */\n  to: BytesLike;\n  /** Amount of coins to withdraw */\n  amount: BigNumberish;\n  /** Asset ID of coins */\n  assetId: BytesLike;\n};\nexport type ChangeTransactionRequestOutput = {\n  type: OutputType.Change;\n  /** Receiving address or script hash */\n  to: BytesLike;\n  /** Asset ID of coins */\n  assetId: BytesLike;\n};\nexport type VariableTransactionRequestOutput = {\n  type: OutputType.Variable;\n};\nexport type ContractCreatedTransactionRequestOutput = {\n  type: OutputType.ContractCreated;\n  /** Contract ID */\n  contractId: BytesLike;\n  /** State Root */\n  stateRoot: BytesLike;\n};\nexport type TransactionRequestOutput =\n  | CoinTransactionRequestOutput\n  | ContractTransactionRequestOutput\n  | WithdrawalTransactionRequestOutput\n  | ChangeTransactionRequestOutput\n  | VariableTransactionRequestOutput\n  | ContractCreatedTransactionRequestOutput;\n\nexport const outputify = (value: TransactionRequestOutput): Output => {\n  switch (value.type) {\n    case OutputType.Coin: {\n      return {\n        type: OutputType.Coin,\n        to: hexlify(value.to),\n        amount: BigInt(value.amount),\n        assetId: hexlify(value.assetId),\n      };\n    }\n    case OutputType.Contract: {\n      return {\n        type: OutputType.Contract,\n        inputIndex: value.inputIndex,\n        balanceRoot: ZeroBytes32,\n        stateRoot: ZeroBytes32,\n      };\n    }\n    case OutputType.Withdrawal: {\n      return {\n        type: OutputType.Withdrawal,\n        to: hexlify(value.to),\n        amount: BigInt(value.amount),\n        assetId: hexlify(value.assetId),\n      };\n    }\n    case OutputType.Change: {\n      return {\n        type: OutputType.Change,\n        to: hexlify(value.to),\n        amount: BigInt(0),\n        assetId: hexlify(value.assetId),\n      };\n    }\n    case OutputType.Variable: {\n      return {\n        type: OutputType.Variable,\n        to: ZeroBytes32,\n        amount: BigInt(0),\n        assetId: ZeroBytes32,\n      };\n    }\n    case OutputType.ContractCreated: {\n      return {\n        type: OutputType.ContractCreated,\n        contractId: hexlify(value.contractId),\n        stateRoot: hexlify(value.stateRoot),\n      };\n    }\n    default: {\n      throw new Error('Invalid Output type');\n    }\n  }\n};\n","/* eslint-disable max-classes-per-file */\nimport type { BytesLike } from '@ethersproject/bytes';\nimport { arrayify, hexlify } from '@ethersproject/bytes';\nimport { NativeAssetId, ZeroBytes32 } from '@fuel-ts/constants';\nimport { addressify, contractIdify } from '@fuel-ts/interfaces';\nimport type { AddressLike, Address, ContractIdLike, AbstractScript } from '@fuel-ts/interfaces';\nimport type { BigNumberish } from '@fuel-ts/math';\nimport type { Transaction } from '@fuel-ts/transactions';\nimport { TransactionType, TransactionCoder, InputType, OutputType } from '@fuel-ts/transactions';\n\nimport type { Coin } from '../coin';\nimport type { CoinQuantityLike } from '../coin-quantity';\nimport { coinQuantityfy } from '../coin-quantity';\n\nimport type {\n  CoinTransactionRequestOutput,\n  ContractCreatedTransactionRequestOutput,\n  ContractTransactionRequestOutput,\n  VariableTransactionRequestOutput,\n} from '.';\nimport type {\n  TransactionRequestInput,\n  CoinTransactionRequestInput,\n  ContractTransactionRequestInput,\n} from './input';\nimport { inputify } from './input';\nimport type { TransactionRequestOutput, ChangeTransactionRequestOutput } from './output';\nimport { outputify } from './output';\nimport type { TransactionRequestStorageSlot } from './storage-slot';\nimport { storageSlotify } from './storage-slot';\nimport type { TransactionRequestWitness } from './witness';\nimport { witnessify } from './witness';\n\nexport { TransactionType };\n\n// We can't import this from `@fuel-ts/script` because it causes\n// cyclic dependency errors so we duplicate it here.\nexport const returnZeroScript: AbstractScript<void> = {\n  /*\n    Opcode::RET(REG_ZERO)\n    Opcode::NOOP\n  */\n  // TODO: Don't use hardcoded scripts: https://github.com/FuelLabs/fuels-ts/issues/281\n  bytes: arrayify('0x24000000'),\n  encodeScriptData: () => new Uint8Array(0),\n};\n\ninterface BaseTransactionRequestLike {\n  /** Gas price for transaction */\n  gasPrice?: BigNumberish;\n  /** Gas limit for transaction */\n  gasLimit?: BigNumberish;\n  /** Price per transaction byte */\n  bytePrice?: BigNumberish;\n  /** Block until which tx cannot be included */\n  maturity?: BigNumberish;\n  /** List of inputs */\n  inputs?: TransactionRequestInput[];\n  /** List of outputs */\n  outputs?: TransactionRequestOutput[];\n  /** List of witnesses */\n  witnesses?: TransactionRequestWitness[];\n}\n\nexport class ChangeOutputCollisionError extends Error {\n  name = 'ChangeOutputCollisionError';\n  message = 'A ChangeOutput with the same \"assetId\" already exists for a different \"to\" address';\n}\n\nexport class NoWitnessAtIndexError extends Error {\n  name = 'NoWitnessAtIndexError';\n  constructor(public readonly index: number) {\n    super();\n    this.message = `Witness at index \"${index}\" was not found`;\n  }\n}\n\nexport class NoWitnessByOwnerError extends Error {\n  name = 'NoWitnessByOwnerError';\n  constructor(public readonly owner: Address) {\n    super();\n    this.message = `A witness for the given owner \"${owner}\" was not found`;\n  }\n}\n\nabstract class BaseTransactionRequest implements BaseTransactionRequestLike {\n  /** Type of the transaction */\n  abstract type: TransactionType;\n  /** Gas price for transaction */\n  gasPrice: bigint;\n  /** Gas limit for transaction */\n  gasLimit: bigint;\n  /** Price per transaction byte */\n  bytePrice: bigint;\n  /** Block until which tx cannot be included */\n  maturity: bigint;\n  /** List of inputs */\n  inputs: TransactionRequestInput[] = [];\n  /** List of outputs */\n  outputs: TransactionRequestOutput[] = [];\n  /** List of witnesses */\n  witnesses: TransactionRequestWitness[] = [];\n\n  constructor({\n    gasPrice,\n    gasLimit,\n    bytePrice,\n    maturity,\n    inputs,\n    outputs,\n    witnesses,\n  }: BaseTransactionRequestLike = {}) {\n    this.gasPrice = BigInt(gasPrice ?? 0);\n    this.gasLimit = BigInt(gasLimit ?? 0);\n    this.bytePrice = BigInt(bytePrice ?? 0);\n    this.maturity = BigInt(maturity ?? 0);\n    this.inputs = [...(inputs ?? [])];\n    this.outputs = [...(outputs ?? [])];\n    this.witnesses = [...(witnesses ?? [])];\n  }\n\n  protected getBaseTransaction(): Pick<\n    Transaction,\n    keyof BaseTransactionRequestLike | 'inputsCount' | 'outputsCount' | 'witnessesCount'\n  > {\n    const inputs = this.inputs?.map(inputify) ?? [];\n    const outputs = this.outputs?.map(outputify) ?? [];\n    const witnesses = this.witnesses?.map(witnessify) ?? [];\n    return {\n      gasPrice: this.gasPrice,\n      gasLimit: this.gasLimit,\n      bytePrice: this.bytePrice,\n      maturity: this.maturity,\n      inputs,\n      outputs,\n      witnesses,\n      inputsCount: inputs.length,\n      outputsCount: outputs.length,\n      witnessesCount: witnesses.length,\n    };\n  }\n\n  abstract toTransaction(): Transaction;\n\n  toTransactionBytes(): Uint8Array {\n    return new TransactionCoder().encode(this.toTransaction());\n  }\n\n  /**\n   * Pushes an input to the list without any side effects and returns the index\n   */\n  protected pushInput(input: TransactionRequestInput): number {\n    this.inputs.push(input);\n    return this.inputs.length - 1;\n  }\n\n  /**\n   * Pushes an output to the list without any side effects and returns the index\n   */\n  protected pushOutput(output: TransactionRequestOutput): number {\n    this.outputs.push(output);\n    return this.outputs.length - 1;\n  }\n\n  /**\n   * Creates an empty witness without any side effects and returns the index\n   */\n  protected createWitness() {\n    this.witnesses.push('0x');\n    return this.witnesses.length - 1;\n  }\n\n  /**\n   * Updates an existing witness without any side effects\n   */\n  updateWitness(index: number, witness: TransactionRequestWitness) {\n    if (!this.witnesses[index]) {\n      throw new NoWitnessAtIndexError(index);\n    }\n    this.witnesses[index] = witness;\n  }\n\n  getCoinInputs(): CoinTransactionRequestInput[] {\n    return this.inputs.filter(\n      (input): input is CoinTransactionRequestInput => input.type === InputType.Coin\n    );\n  }\n\n  getCoinOutputs(): CoinTransactionRequestOutput[] {\n    return this.outputs.filter(\n      (output): output is CoinTransactionRequestOutput => output.type === OutputType.Coin\n    );\n  }\n\n  getChangeOutputs(): ChangeTransactionRequestOutput[] {\n    return this.outputs.filter(\n      (output): output is ChangeTransactionRequestOutput => output.type === OutputType.Change\n    );\n  }\n\n  /**\n   * Returns the witnessIndex of the found CoinInput\n   */\n  getCoinInputWitnessIndexByOwner(owner: AddressLike): number | null {\n    const ownerAddress = addressify(owner);\n    return (\n      this.inputs.find(\n        (input): input is CoinTransactionRequestInput =>\n          input.type === InputType.Coin && hexlify(input.owner) === ownerAddress\n      )?.witnessIndex ?? null\n    );\n  }\n\n  /**\n   * Updates the witness for the given CoinInput owner\n   */\n  updateWitnessByCoinInputOwner(owner: AddressLike, witness: BytesLike) {\n    const witnessIndex = this.getCoinInputWitnessIndexByOwner(owner);\n\n    if (!witnessIndex) {\n      throw new NoWitnessByOwnerError(addressify(owner));\n    }\n\n    this.updateWitness(witnessIndex, witness);\n  }\n\n  /**\n   * Converts the given Coin to a CoinInput with the appropriate witnessIndex and pushes it\n   */\n  addCoin(coin: Coin) {\n    let witnessIndex = this.getCoinInputWitnessIndexByOwner(coin.owner);\n\n    // Insert a dummy witness if no witness exists\n    if (typeof witnessIndex !== 'number') {\n      witnessIndex = this.createWitness();\n    }\n\n    // Insert the CoinInput\n    this.pushInput({\n      type: InputType.Coin,\n      ...coin,\n      witnessIndex,\n    });\n\n    // Find the ChangeOutput for the AssetId of the Coin\n    const changeOutput = this.getChangeOutputs().find(\n      (output) => hexlify(output.assetId) === coin.assetId\n    );\n\n    // Throw if the existing ChangeOutput is not for the same owner\n    if (changeOutput && hexlify(changeOutput.to) !== coin.owner) {\n      throw new ChangeOutputCollisionError();\n    }\n\n    // Insert a ChangeOutput if it does not exist\n    if (!changeOutput) {\n      this.pushOutput({\n        type: OutputType.Change,\n        to: coin.owner,\n        assetId: coin.assetId,\n      });\n    }\n  }\n\n  addCoins(coins: ReadonlyArray<Coin>) {\n    coins.forEach((coin) => this.addCoin(coin));\n  }\n\n  addCoinOutput(\n    /** Address of the destination */\n    to: AddressLike,\n    /** Amount of coins */\n    amount: BigNumberish,\n    /** Asset ID of coins */\n    assetId: BytesLike = NativeAssetId\n  ) {\n    this.pushOutput({\n      type: OutputType.Coin,\n      to: addressify(to),\n      amount,\n      assetId,\n    });\n  }\n\n  addCoinOutputs(\n    /** Address of the destination */\n    to: AddressLike,\n    /** Quantities of coins */\n    quantities: CoinQuantityLike[]\n  ) {\n    quantities.map(coinQuantityfy).forEach((quantity) => {\n      this.pushOutput({\n        type: OutputType.Coin,\n        to: addressify(to),\n        amount: quantity.amount,\n        assetId: quantity.assetId,\n      });\n    });\n  }\n\n  calculateFee(): bigint {\n    // TODO: Calculate the correct amount\n    const amount = 1n;\n\n    return amount;\n  }\n}\n\nexport interface ScriptTransactionRequestLike extends BaseTransactionRequestLike {\n  /** Script to execute */\n  script?: BytesLike;\n  /** Script input data (parameters) */\n  scriptData?: BytesLike;\n}\n\nexport class ScriptTransactionRequest extends BaseTransactionRequest {\n  static from(obj: ScriptTransactionRequestLike) {\n    if (obj instanceof this) {\n      return obj;\n    }\n    return new this(obj);\n  }\n\n  /** Type of the transaction */\n  type = TransactionType.Script as const;\n  /** Script to execute */\n  script: Uint8Array;\n  /** Script input data (parameters) */\n  scriptData: Uint8Array;\n\n  constructor({ script, scriptData, ...rest }: ScriptTransactionRequestLike = {}) {\n    super(rest);\n    this.script = arrayify(script ?? returnZeroScript.bytes);\n    this.scriptData = arrayify(scriptData ?? returnZeroScript.encodeScriptData());\n  }\n\n  toTransaction(): Transaction {\n    const script = arrayify(this.script ?? '0x');\n    const scriptData = arrayify(this.scriptData ?? '0x');\n    return {\n      type: TransactionType.Script,\n      ...super.getBaseTransaction(),\n      scriptLength: script.length,\n      scriptDataLength: scriptData.length,\n      receiptsRoot: ZeroBytes32,\n      script: hexlify(script),\n      scriptData: hexlify(scriptData),\n    };\n  }\n\n  getContractInputs(): ContractTransactionRequestInput[] {\n    return this.inputs.filter(\n      (input): input is ContractTransactionRequestInput => input.type === InputType.Contract\n    );\n  }\n\n  getContractOutputs(): ContractTransactionRequestOutput[] {\n    return this.outputs.filter(\n      (output): output is ContractTransactionRequestOutput => output.type === OutputType.Contract\n    );\n  }\n\n  getVariableOutputs(): VariableTransactionRequestOutput[] {\n    return this.outputs.filter(\n      (output): output is VariableTransactionRequestOutput => output.type === OutputType.Variable\n    );\n  }\n\n  setScript<T>(script: AbstractScript<T>, data: T) {\n    this.script = script.bytes;\n    this.scriptData = script.encodeScriptData(data);\n  }\n\n  addVariableOutputs(numberOfVariables: number = 1) {\n    let outputsNumber = numberOfVariables;\n\n    while (outputsNumber) {\n      this.pushOutput({\n        type: OutputType.Variable,\n      });\n      outputsNumber -= 1;\n    }\n\n    return this.outputs.length - 1;\n  }\n\n  addContract(contract: ContractIdLike) {\n    const inputIndex = super.pushInput({\n      type: InputType.Contract,\n      contractId: contractIdify(contract),\n    });\n\n    this.pushOutput({\n      type: OutputType.Contract,\n      inputIndex,\n    });\n  }\n}\n\nexport interface CreateTransactionRequestLike extends BaseTransactionRequestLike {\n  /** Witness index of contract bytecode to create */\n  bytecodeWitnessIndex?: number;\n  /** Salt */\n  salt?: BytesLike;\n  /** List of static contracts */\n  staticContracts?: BytesLike[];\n  /** List of storage slots to initialize */\n  storageSlots?: TransactionRequestStorageSlot[];\n}\n\nexport class CreateTransactionRequest extends BaseTransactionRequest {\n  static from(obj: CreateTransactionRequestLike) {\n    if (obj instanceof this) {\n      return obj;\n    }\n    return new this(obj);\n  }\n\n  /** Type of the transaction */\n  type = TransactionType.Create as const;\n  /** Witness index of contract bytecode to create */\n  bytecodeWitnessIndex: number;\n  /** Salt */\n  salt: string;\n  /** List of static contracts */\n  staticContracts: string[];\n  /** List of storage slots to initialize */\n  storageSlots: TransactionRequestStorageSlot[];\n\n  constructor({\n    bytecodeWitnessIndex,\n    salt,\n    staticContracts,\n    storageSlots,\n    ...rest\n  }: CreateTransactionRequestLike = {}) {\n    super(rest);\n    this.bytecodeWitnessIndex = bytecodeWitnessIndex ?? 0;\n    this.salt = hexlify(salt ?? ZeroBytes32);\n    this.staticContracts = [...(staticContracts?.map((value) => hexlify(value)) ?? [])];\n    this.storageSlots = [...(storageSlots ?? [])];\n  }\n\n  toTransaction(): Transaction {\n    const baseTransaction = this.getBaseTransaction();\n    const bytecodeWitnessIndex = this.bytecodeWitnessIndex;\n    const staticContracts = this.staticContracts ?? [];\n    const storageSlots = this.storageSlots?.map(storageSlotify) ?? [];\n    return {\n      type: TransactionType.Create,\n      ...baseTransaction,\n      bytecodeLength: baseTransaction.witnesses[bytecodeWitnessIndex].dataLength / 4,\n      bytecodeWitnessIndex,\n      staticContractsCount: staticContracts.length,\n      storageSlotsCount: storageSlots.length,\n      salt: this.salt ? hexlify(this.salt) : ZeroBytes32,\n      staticContracts: staticContracts.map((id) => hexlify(id)),\n      storageSlots,\n    };\n  }\n\n  getContractCreatedOutputs(): ContractCreatedTransactionRequestOutput[] {\n    return this.outputs.filter(\n      (output): output is ContractCreatedTransactionRequestOutput =>\n        output.type === OutputType.ContractCreated\n    );\n  }\n\n  addContractCreatedOutput(\n    /** Contract ID */\n    contractId: BytesLike,\n    /** State Root */\n    stateRoot: BytesLike\n  ) {\n    this.pushOutput({\n      type: OutputType.ContractCreated,\n      contractId,\n      stateRoot,\n    });\n  }\n}\n\nexport type TransactionRequest = ScriptTransactionRequest | CreateTransactionRequest;\nexport type TransactionRequestLike =\n  | ({ type: TransactionType.Script } & ScriptTransactionRequestLike)\n  | ({ type: TransactionType.Create } & CreateTransactionRequestLike);\n\nexport const transactionRequestify = (obj: TransactionRequestLike): TransactionRequest => {\n  if (obj instanceof ScriptTransactionRequest || obj instanceof CreateTransactionRequest) {\n    return obj;\n  }\n  switch (obj.type) {\n    case TransactionType.Script: {\n      return ScriptTransactionRequest.from(obj);\n    }\n    case TransactionType.Create: {\n      return CreateTransactionRequest.from(obj);\n    }\n    default: {\n      throw new Error(\n        `Unknown transaction type: ${\n          // @ts-expect-error Unreachable code\n          obj.type\n        }`\n      );\n    }\n  }\n};\n","import type { BytesLike } from '@ethersproject/bytes';\nimport { hexlify, arrayify } from '@ethersproject/bytes';\nimport type { StorageSlot } from '@fuel-ts/transactions';\n\nexport type TransactionRequestStorageSlot =\n  | {\n      /** Key */\n      key: BytesLike;\n      /** Value */\n      value: BytesLike;\n    }\n  | [key: BytesLike, value: BytesLike];\n\n// Make sure all values have 32 bytes\nconst getStorageValue = (value: BytesLike): Uint8Array => {\n  const v = new Uint8Array(32);\n  v.set(arrayify(value));\n  return v;\n};\n\nexport const storageSlotify = (storageSlot: TransactionRequestStorageSlot): StorageSlot => {\n  let key;\n  let value;\n\n  if (Array.isArray(storageSlot)) {\n    key = storageSlot[0];\n    value = storageSlot[1];\n  } else {\n    key = storageSlot.key;\n    value = storageSlot.value;\n  }\n\n  return {\n    key: hexlify(key),\n    value: hexlify(getStorageValue(value)),\n  };\n};\n","import type { BytesLike } from '@ethersproject/bytes';\nimport { arrayify, hexlify } from '@ethersproject/bytes';\nimport type { Witness } from '@fuel-ts/transactions';\n\nexport type TransactionRequestWitness = BytesLike;\n\nexport const witnessify = (value: TransactionRequestWitness): Witness => {\n  const data = arrayify(value);\n\n  return {\n    data: hexlify(data),\n    dataLength: data.length,\n  };\n};\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { arrayify } from '@ethersproject/bytes';\nimport type {\n  ReceiptCall,\n  ReceiptLog,\n  ReceiptLogData,\n  ReceiptPanic,\n  ReceiptReturn,\n  ReceiptReturnData,\n  ReceiptRevert,\n  ReceiptTransfer,\n  ReceiptTransferOut,\n  ReceiptScriptResult,\n} from '@fuel-ts/transactions';\nimport { ReceiptType, ReceiptCoder } from '@fuel-ts/transactions';\n\nimport type {\n  GqlGetTransactionWithReceiptsQuery,\n  GqlReceiptFragmentFragment,\n} from '../__generated__/operations';\nimport type Provider from '../provider';\nimport type { TransactionRequest } from '../transaction-request';\n\nexport type TransactionResultCallReceipt = ReceiptCall;\nexport type TransactionResultReturnReceipt = ReceiptReturn;\nexport type TransactionResultReturnDataReceipt = ReceiptReturnData & { data: string };\nexport type TransactionResultPanicReceipt = ReceiptPanic;\nexport type TransactionResultRevertReceipt = ReceiptRevert;\nexport type TransactionResultLogReceipt = ReceiptLog;\nexport type TransactionResultLogDataReceipt = ReceiptLogData & { data: string };\nexport type TransactionResultTransferReceipt = ReceiptTransfer;\nexport type TransactionResultTransferOutReceipt = ReceiptTransferOut;\nexport type TransactionResultScriptResultReceipt = ReceiptScriptResult;\n\nexport type TransactionResultReceipt =\n  | TransactionResultCallReceipt\n  | TransactionResultReturnReceipt\n  | TransactionResultReturnDataReceipt\n  | TransactionResultPanicReceipt\n  | TransactionResultRevertReceipt\n  | TransactionResultLogReceipt\n  | TransactionResultLogDataReceipt\n  | TransactionResultTransferReceipt\n  | TransactionResultTransferOutReceipt\n  | TransactionResultScriptResultReceipt;\n\nexport type TransactionResult<TStatus extends 'success' | 'failure'> = {\n  status: TStatus extends 'success'\n    ? { type: 'success'; programState: any }\n    : { type: 'failure'; reason: any };\n  /** Receipts produced during the execution of the transaction */\n  receipts: TransactionResultReceipt[];\n  transactionId: string;\n  blockId: any;\n  time: any;\n};\n\nconst processGqlReceipt = (gqlReceipt: GqlReceiptFragmentFragment): TransactionResultReceipt => {\n  const receipt = new ReceiptCoder().decode(arrayify(gqlReceipt.rawPayload), 0)[0];\n\n  switch (receipt.type) {\n    case ReceiptType.ReturnData: {\n      return {\n        ...receipt,\n        data: gqlReceipt.data!,\n      };\n    }\n    case ReceiptType.LogData: {\n      return {\n        ...receipt,\n        data: gqlReceipt.data!,\n      };\n    }\n    default:\n      return receipt;\n  }\n};\n\nexport class TransactionResponse {\n  /** Transaction ID */\n  id: string;\n  /** Transaction request */\n  request: TransactionRequest;\n  provider: Provider;\n\n  constructor(id: string, request: TransactionRequest, provider: Provider) {\n    this.id = id;\n    this.request = request;\n    this.provider = provider;\n  }\n\n  async #fetch(): Promise<NonNullable<GqlGetTransactionWithReceiptsQuery['transaction']>> {\n    const { transaction } = await this.provider.operations.getTransactionWithReceipts({\n      transactionId: this.id,\n    });\n    if (!transaction) {\n      throw new Error('No Transaction was received from the client.');\n    }\n    return transaction;\n  }\n\n  /** Waits for transaction to succeed or fail and returns the result */\n  async waitForResult(): Promise<TransactionResult<any>> {\n    const transaction = await this.#fetch();\n\n    switch (transaction.status?.type) {\n      case 'SubmittedStatus': {\n        // TODO: Implement polling or GQL subscription\n        throw new Error('Not yet implemented');\n      }\n      case 'FailureStatus': {\n        return {\n          status: { type: 'failure', reason: transaction.status.reason },\n          receipts: transaction.receipts!.map(processGqlReceipt),\n          transactionId: this.id,\n          blockId: transaction.status.block.id,\n          time: transaction.status.time,\n        };\n      }\n      case 'SuccessStatus': {\n        return {\n          status: { type: 'success', programState: transaction.status.programState },\n          receipts: transaction.receipts!.map(processGqlReceipt),\n          transactionId: this.id,\n          blockId: transaction.status.block.id,\n          time: transaction.status.time,\n        };\n      }\n      default: {\n        throw new Error('Invalid Transaction status');\n      }\n    }\n  }\n\n  /** Waits for transaction to succeed and returns the result */\n  async wait(): Promise<TransactionResult<'success'>> {\n    const result = await this.waitForResult();\n\n    if (result.status.type === 'failure') {\n      throw new Error(`Transaction failed: ${result.status.reason}`);\n    }\n\n    return result;\n  }\n}\n","import { sha256 } from '@ethersproject/sha2';\nimport { ZeroBytes32 } from '@fuel-ts/constants';\nimport type { Transaction } from '@fuel-ts/transactions';\nimport { InputType, OutputType, TransactionType, TransactionCoder } from '@fuel-ts/transactions';\n\nexport const getSignableTransaction = (transaction: Transaction): Transaction => {\n  const signableTransaction = { ...transaction } as Transaction;\n  switch (signableTransaction.type) {\n    case TransactionType.Script: {\n      signableTransaction.receiptsRoot = ZeroBytes32;\n      break;\n    }\n    case TransactionType.Create: {\n      break;\n    }\n    default: {\n      throw new Error('Not implemented');\n    }\n  }\n\n  signableTransaction.inputs = signableTransaction.inputs.map((input) => {\n    if (input.type === InputType.Contract) {\n      return {\n        ...input,\n        utxoID: {\n          transactionId: ZeroBytes32,\n          outputIndex: 0,\n        },\n        balanceRoot: ZeroBytes32,\n        stateRoot: ZeroBytes32,\n      };\n    }\n    return input;\n  });\n\n  signableTransaction.outputs = signableTransaction.outputs.map((output) => {\n    switch (output.type) {\n      case OutputType.Contract: {\n        return {\n          ...output,\n          balanceRoot: ZeroBytes32,\n          stateRoot: ZeroBytes32,\n        };\n      }\n      case OutputType.Change: {\n        return {\n          ...output,\n          amount: 0n,\n        };\n      }\n      case OutputType.Variable: {\n        return {\n          ...output,\n          to: ZeroBytes32,\n          amount: 0n,\n          assetId: ZeroBytes32,\n        };\n      }\n      default: {\n        return output;\n      }\n    }\n  });\n\n  return signableTransaction;\n};\n\nexport const getTransactionId = (transaction: Transaction): string => {\n  const signableTransaction = getSignableTransaction(transaction);\n\n  const encodedTransaction = new TransactionCoder().encode(signableTransaction);\n\n  return sha256(encodedTransaction);\n};\n"],"mappings":"+0BAGA,mCCFA,gDACA,oDAQO,GAAM,GAAiB,AAAC,GAAqD,CAVpF,QAWE,GAAI,GACA,EACJ,MAAI,OAAM,QAAQ,CAAgB,EAChC,GAAS,EAAiB,GAC1B,EAAU,KAAiB,KAAjB,OAAuB,IAEjC,GAAS,EAAiB,OAC1B,EAAU,KAAiB,UAAjB,OAA4B,IAGjC,CACL,QAAS,GAAQ,CAAO,EACxB,OAAQ,OAAO,CAAM,CACvB,CACF,ECvBA,2BAsJO,GAAK,IAAL,CAAK,GACV,SAAQ,QACR,UAAU,UAFA,YAk5BL,GAAM,GAAiC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA6BjC,GAA6B;AAAA;AAAA;AAAA;AAAA;AAAA,EAM7B,EAA2B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAW3B,EAA0B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAW1B,GAA6B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAO7B,GAAqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOrB,GAAmB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAW5B;AAAA,EAES,GAAyB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAMlC;AAAA,EAES,GAAqC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAS9C;AAAA,IACA;AAAA,EAES,GAA0B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAUnC;AAAA,EAES,GAAiC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAgB1C;AAAA,EAES,GAAmB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAM5B;AAAA,EAES,GAAmC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAS5C;AAAA,IACA;AAAA,EAES,GAAoB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAU7B;AAAA,EAES,GAAkB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAM3B;AAAA,EAES,GAAmB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAgB5B;AAAA,EAES,GAA0B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAUnC;AAAA,EAES,GAAsB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQtB,GAAqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAM9B;AAAA,EAES,GAAsB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAgB/B;AAAA,EAES,GAAiB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAM1B;AAAA,EAES,GAAiB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOjB,GAAuB;AAAA;AAAA;AAAA;AAAA,EAKvB,GAAqB;AAAA;AAAA;AAAA;AAAA,EAKrB,GAAkB;AAAA;AAAA;AAAA;AAAA,EAKlB,GAAgB;AAAA;AAAA;AAAA;AAAA,EAYvB,GAAqC,CAAC,EAAQ,EAAgB,IAAmB,EAAO,EAEvF,YAAgB,EAAuB,EAAkC,GAAgB,CAC9F,MAAO,CACL,WACE,EACA,EAC6B,CAC7B,MAAO,GACL,AAAC,GACC,EAAO,QAA4B,GAAoB,EAAW,OAC7D,GACA,EACJ,EACH,aACA,OACF,CACF,EACA,SACE,EACA,EAC2B,CAC3B,MAAO,GACL,AAAC,GACC,EAAO,QAA0B,GAAkB,EAAW,OACzD,GACA,EACJ,EACH,WACA,OACF,CACF,EACA,eACE,EACA,EACiC,CACjC,MAAO,GACL,AAAC,GACC,EAAO,QAAgC,GAAwB,EAAW,OACrE,GACA,EACJ,EACH,iBACA,OACF,CACF,EACA,2BACE,EACA,EAC6C,CAC7C,MAAO,GACL,AAAC,GACC,EAAO,QACL,GACA,EACA,OAAK,GAAmB,EAC1B,EACF,6BACA,OACF,CACF,EACA,gBACE,EACA,EACkC,CAClC,MAAO,GACL,AAAC,GACC,EAAO,QAAiC,GAAyB,EAAW,OACvE,GACA,EACJ,EACH,kBACA,OACF,CACF,EACA,uBACE,EACA,EACyC,CACzC,MAAO,GACL,AAAC,GACC,EAAO,QACL,GACA,EACA,OAAK,GAAmB,EAC1B,EACF,yBACA,OACF,CACF,EACA,SACE,EACA,EAC2B,CAC3B,MAAO,GACL,AAAC,GACC,EAAO,QAA0B,GAAkB,EAAW,OACzD,GACA,EACJ,EACH,WACA,OACF,CACF,EACA,yBACE,EACA,EAC2C,CAC3C,MAAO,GACL,AAAC,GACC,EAAO,QACL,GACA,EACA,OAAK,GAAmB,EAC1B,EACF,2BACA,OACF,CACF,EACA,UACE,EACA,EAC4B,CAC5B,MAAO,GACL,AAAC,GACC,EAAO,QAA2B,GAAmB,EAAW,OAC3D,GACA,EACJ,EACH,YACA,OACF,CACF,EACA,QACE,EACA,EAC0B,CAC1B,MAAO,GACL,AAAC,GACC,EAAO,QAAyB,GAAiB,EAAW,OACvD,GACA,EACJ,EACH,UACA,OACF,CACF,EACA,SACE,EACA,EAC2B,CAC3B,MAAO,GACL,AAAC,GACC,EAAO,QAA0B,GAAkB,EAAW,OACzD,GACA,EACJ,EACH,WACA,OACF,CACF,EACA,gBACE,EACA,EACkC,CAClC,MAAO,GACL,AAAC,GACC,EAAO,QAAiC,GAAyB,EAAW,OACvE,GACA,EACJ,EACH,kBACA,OACF,CACF,EACA,YACE,EACA,EAC8B,CAC9B,MAAO,GACL,AAAC,GACC,EAAO,QAA6B,GAAqB,EAAW,OAC/D,GACA,EACJ,EACH,cACA,OACF,CACF,EACA,WACE,EACA,EAC6B,CAC7B,MAAO,GACL,AAAC,GACC,EAAO,QAA4B,GAAoB,EAAW,OAC7D,GACA,EACJ,EACH,aACA,OACF,CACF,EACA,YACE,EACA,EAC8B,CAC9B,MAAO,GACL,AAAC,GACC,EAAO,QAA6B,GAAqB,EAAW,OAC/D,GACA,EACJ,EACH,cACA,OACF,CACF,EAC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","names":[]}