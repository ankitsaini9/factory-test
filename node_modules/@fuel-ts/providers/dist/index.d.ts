import { InputType, Input, OutputType, Output, TransactionType, Transaction, ReceiptCall, ReceiptReturn, ReceiptReturnData, ReceiptPanic, ReceiptRevert, ReceiptLog, ReceiptLogData, ReceiptTransfer, ReceiptTransferOut, ReceiptScriptResult } from '@fuel-ts/transactions';
export * from '@fuel-ts/transactions';
export { TransactionType } from '@fuel-ts/transactions';
import { BytesLike } from '@ethersproject/bytes';
import { BigNumberish } from '@fuel-ts/math';
import { GraphQLClient } from 'graphql-request';
import * as Dom from 'graphql-request/dist/types.dom';
import { Network } from '@ethersproject/networks';
import { AbstractScript, Address, ContractIdLike, AddressLike } from '@fuel-ts/interfaces';

declare type CoinQuantityLike = [amount: BigNumberish, assetId?: BytesLike] | {
    amount: BigNumberish;
    assetId?: BytesLike;
};
declare type CoinQuantity = {
    amount: bigint;
    assetId: string;
};
declare const coinQuantityfy: (coinQuantityLike: CoinQuantityLike) => CoinQuantity;

declare type Maybe<T> = T | null;
declare type InputMaybe<T> = Maybe<T>;
declare type Exact<T extends {
    [key: string]: unknown;
}> = {
    [K in keyof T]: T[K];
};
/** All built-in and custom scalars, mapped to their actual values */
declare type Scalars = {
    ID: string;
    String: string;
    Boolean: boolean;
    Int: number;
    Float: number;
    Address: string;
    AssetId: string;
    BlockId: string;
    Bytes32: string;
    ContractId: string;
    /**
     * Implement the DateTime<Utc> scalar
     *
     * The input/output is a string in RFC3339 format.
     */
    DateTime: string;
    HexString: string;
    Salt: string;
    TransactionId: string;
    U64: string;
    UtxoId: string;
};
declare type GqlBalanceFilterInput = {
    /** Filter coins based on the `owner` field */
    owner: Scalars['Address'];
};
declare type GqlCoinFilterInput = {
    /** Asset ID of the coins */
    assetId?: InputMaybe<Scalars['AssetId']>;
    /** Address of the owner */
    owner: Scalars['Address'];
};
declare enum GqlCoinStatus {
    Spent = "SPENT",
    Unspent = "UNSPENT"
}
declare enum GqlReturnType {
    Return = "RETURN",
    ReturnData = "RETURN_DATA",
    Revert = "REVERT"
}
declare type GqlSpendQueryElementInput = {
    /** Target amount for the query */
    amount: Scalars['U64'];
    /** Asset ID of the coins */
    assetId: Scalars['AssetId'];
};
declare type GqlGetVersionQuery = {
    __typename: 'Query';
    nodeInfo: {
        __typename: 'NodeInfo';
        nodeVersion: string;
    };
};
declare type GqlGetChainQuery = {
    __typename: 'Query';
    chain: {
        __typename: 'ChainInfo';
        name: string;
        baseChainHeight: string;
        peerCount: number;
        latestBlock: {
            __typename: 'Block';
            id: string;
            height: string;
            producer: string;
            time: string;
            transactions: Array<{
                __typename: 'Transaction';
                id: string;
            }>;
        };
    };
};
declare type GqlGetTransactionQueryVariables = Exact<{
    transactionId: Scalars['TransactionId'];
}>;
declare type GqlGetTransactionQuery = {
    __typename: 'Query';
    transaction?: {
        __typename: 'Transaction';
        id: string;
        rawPayload: string;
        status?: {
            __typename: 'FailureStatus';
            time: string;
            reason: string;
            type: 'FailureStatus';
            block: {
                __typename: 'Block';
                id: string;
            };
        } | {
            __typename: 'SubmittedStatus';
            time: string;
            type: 'SubmittedStatus';
        } | {
            __typename: 'SuccessStatus';
            time: string;
            type: 'SuccessStatus';
            block: {
                __typename: 'Block';
                id: string;
            };
            programState: {
                __typename: 'ProgramState';
                returnType: GqlReturnType;
                data: string;
            };
        } | null;
    } | null;
};
declare type GqlGetTransactionWithReceiptsQueryVariables = Exact<{
    transactionId: Scalars['TransactionId'];
}>;
declare type GqlGetTransactionWithReceiptsQuery = {
    __typename: 'Query';
    transaction?: {
        __typename: 'Transaction';
        id: string;
        rawPayload: string;
        receipts?: Array<{
            __typename: 'Receipt';
            data?: string | null;
            rawPayload: string;
        }> | null;
        status?: {
            __typename: 'FailureStatus';
            time: string;
            reason: string;
            type: 'FailureStatus';
            block: {
                __typename: 'Block';
                id: string;
            };
        } | {
            __typename: 'SubmittedStatus';
            time: string;
            type: 'SubmittedStatus';
        } | {
            __typename: 'SuccessStatus';
            time: string;
            type: 'SuccessStatus';
            block: {
                __typename: 'Block';
                id: string;
            };
            programState: {
                __typename: 'ProgramState';
                returnType: GqlReturnType;
                data: string;
            };
        } | null;
    } | null;
};
declare type GqlGetTransactionsQuery = {
    __typename: 'Query';
    transactions: {
        __typename: 'TransactionConnection';
        edges: Array<{
            __typename: 'TransactionEdge';
            node: {
                __typename: 'Transaction';
                id: string;
                rawPayload: string;
                status?: {
                    __typename: 'FailureStatus';
                    time: string;
                    reason: string;
                    type: 'FailureStatus';
                    block: {
                        __typename: 'Block';
                        id: string;
                    };
                } | {
                    __typename: 'SubmittedStatus';
                    time: string;
                    type: 'SubmittedStatus';
                } | {
                    __typename: 'SuccessStatus';
                    time: string;
                    type: 'SuccessStatus';
                    block: {
                        __typename: 'Block';
                        id: string;
                    };
                    programState: {
                        __typename: 'ProgramState';
                        returnType: GqlReturnType;
                        data: string;
                    };
                } | null;
            };
        }>;
    };
};
declare type GqlGetTransactionsByOwnerQueryVariables = Exact<{
    owner: Scalars['Address'];
    after?: InputMaybe<Scalars['String']>;
    before?: InputMaybe<Scalars['String']>;
    first?: InputMaybe<Scalars['Int']>;
    last?: InputMaybe<Scalars['Int']>;
}>;
declare type GqlGetTransactionsByOwnerQuery = {
    __typename: 'Query';
    transactionsByOwner: {
        __typename: 'TransactionConnection';
        edges: Array<{
            __typename: 'TransactionEdge';
            node: {
                __typename: 'Transaction';
                id: string;
                rawPayload: string;
                status?: {
                    __typename: 'FailureStatus';
                    time: string;
                    reason: string;
                    type: 'FailureStatus';
                    block: {
                        __typename: 'Block';
                        id: string;
                    };
                } | {
                    __typename: 'SubmittedStatus';
                    time: string;
                    type: 'SubmittedStatus';
                } | {
                    __typename: 'SuccessStatus';
                    time: string;
                    type: 'SuccessStatus';
                    block: {
                        __typename: 'Block';
                        id: string;
                    };
                    programState: {
                        __typename: 'ProgramState';
                        returnType: GqlReturnType;
                        data: string;
                    };
                } | null;
            };
        }>;
    };
};
declare type GqlGetBlockQuery = {
    __typename: 'Query';
    block?: {
        __typename: 'Block';
        id: string;
        height: string;
        producer: string;
        time: string;
        transactions: Array<{
            __typename: 'Transaction';
            id: string;
        }>;
    } | null;
};
declare type GqlGetBlockWithTransactionsQuery = {
    __typename: 'Query';
    block?: {
        __typename: 'Block';
        id: string;
        height: string;
        producer: string;
        time: string;
        transactions: Array<{
            __typename: 'Transaction';
            id: string;
            rawPayload: string;
            status?: {
                __typename: 'FailureStatus';
                time: string;
                reason: string;
                type: 'FailureStatus';
                block: {
                    __typename: 'Block';
                    id: string;
                };
            } | {
                __typename: 'SubmittedStatus';
                time: string;
                type: 'SubmittedStatus';
            } | {
                __typename: 'SuccessStatus';
                time: string;
                type: 'SuccessStatus';
                block: {
                    __typename: 'Block';
                    id: string;
                };
                programState: {
                    __typename: 'ProgramState';
                    returnType: GqlReturnType;
                    data: string;
                };
            } | null;
        }>;
    } | null;
};
declare type GqlGetBlocksQuery = {
    __typename: 'Query';
    blocks: {
        __typename: 'BlockConnection';
        edges: Array<{
            __typename: 'BlockEdge';
            node: {
                __typename: 'Block';
                id: string;
                height: string;
                producer: string;
                time: string;
                transactions: Array<{
                    __typename: 'Transaction';
                    id: string;
                }>;
            };
        }>;
    };
};
declare type GqlGetCoinQueryVariables = Exact<{
    coinId: Scalars['UtxoId'];
}>;
declare type GqlGetCoinQuery = {
    __typename: 'Query';
    coin?: {
        __typename: 'Coin';
        utxoId: string;
        owner: string;
        amount: string;
        assetId: string;
        maturity: string;
        status: GqlCoinStatus;
        blockCreated: string;
    } | null;
};
declare type GqlGetCoinsQueryVariables = Exact<{
    filter: GqlCoinFilterInput;
    after?: InputMaybe<Scalars['String']>;
    before?: InputMaybe<Scalars['String']>;
    first?: InputMaybe<Scalars['Int']>;
    last?: InputMaybe<Scalars['Int']>;
}>;
declare type GqlGetCoinsQuery = {
    __typename: 'Query';
    coins: {
        __typename: 'CoinConnection';
        edges: Array<{
            __typename: 'CoinEdge';
            node: {
                __typename: 'Coin';
                utxoId: string;
                owner: string;
                amount: string;
                assetId: string;
                maturity: string;
                status: GqlCoinStatus;
                blockCreated: string;
            };
        }>;
    };
};
declare type GqlGetCoinsToSpendQueryVariables = Exact<{
    owner: Scalars['Address'];
    spendQuery: Array<GqlSpendQueryElementInput> | GqlSpendQueryElementInput;
    maxInputs?: InputMaybe<Scalars['Int']>;
}>;
declare type GqlGetCoinsToSpendQuery = {
    __typename: 'Query';
    coinsToSpend: Array<{
        __typename: 'Coin';
        utxoId: string;
        owner: string;
        amount: string;
        assetId: string;
        maturity: string;
        status: GqlCoinStatus;
        blockCreated: string;
    }>;
};
declare type GqlGetContractQueryVariables = Exact<{
    contractId: Scalars['ContractId'];
}>;
declare type GqlGetContractQuery = {
    __typename: 'Query';
    contract?: {
        __typename: 'Contract';
        bytecode: string;
        id: string;
    } | null;
};
declare type GqlGetBalanceQueryVariables = Exact<{
    owner: Scalars['Address'];
    assetId: Scalars['AssetId'];
}>;
declare type GqlGetBalanceQuery = {
    __typename: 'Query';
    balance: {
        __typename: 'Balance';
        owner: string;
        amount: string;
        assetId: string;
    };
};
declare type GqlGetBalancesQueryVariables = Exact<{
    filter: GqlBalanceFilterInput;
    after?: InputMaybe<Scalars['String']>;
    before?: InputMaybe<Scalars['String']>;
    first?: InputMaybe<Scalars['Int']>;
    last?: InputMaybe<Scalars['Int']>;
}>;
declare type GqlGetBalancesQuery = {
    __typename: 'Query';
    balances: {
        __typename: 'BalanceConnection';
        edges: Array<{
            __typename: 'BalanceEdge';
            node: {
                __typename: 'Balance';
                owner: string;
                amount: string;
                assetId: string;
            };
        }>;
    };
};
declare type GqlDryRunMutationVariables = Exact<{
    encodedTransaction: Scalars['HexString'];
    utxoValidation?: InputMaybe<Scalars['Boolean']>;
}>;
declare type GqlDryRunMutation = {
    __typename: 'Mutation';
    dryRun: Array<{
        __typename: 'Receipt';
        data?: string | null;
        rawPayload: string;
    }>;
};
declare type GqlSubmitMutationVariables = Exact<{
    encodedTransaction: Scalars['HexString'];
}>;
declare type GqlSubmitMutation = {
    __typename: 'Mutation';
    submit: {
        __typename: 'Transaction';
        id: string;
    };
};
declare type GqlStartSessionMutation = {
    __typename: 'Mutation';
    startSession: string;
};
declare type GqlEndSessionMutationVariables = Exact<{
    sessionId: Scalars['ID'];
}>;
declare type GqlEndSessionMutation = {
    __typename: 'Mutation';
    endSession: boolean;
};
declare type GqlExecuteMutationVariables = Exact<{
    sessionId: Scalars['ID'];
    op: Scalars['String'];
}>;
declare type GqlExecuteMutation = {
    __typename: 'Mutation';
    execute: boolean;
};
declare type GqlResetMutationVariables = Exact<{
    sessionId: Scalars['ID'];
}>;
declare type GqlResetMutation = {
    __typename: 'Mutation';
    reset: boolean;
};
declare type SdkFunctionWrapper = <T>(action: (requestHeaders?: Record<string, string>) => Promise<T>, operationName: string, operationType?: string) => Promise<T>;
declare function getSdk(client: GraphQLClient, withWrapper?: SdkFunctionWrapper): {
    getVersion(variables?: Exact<{
        [key: string]: never;
    }> | undefined, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetVersionQuery>;
    getChain(variables?: Exact<{
        [key: string]: never;
    }> | undefined, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetChainQuery>;
    getTransaction(variables: GqlGetTransactionQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetTransactionQuery>;
    getTransactionWithReceipts(variables: GqlGetTransactionWithReceiptsQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetTransactionWithReceiptsQuery>;
    getTransactions(variables?: Exact<{
        after?: InputMaybe<string> | undefined;
        before?: InputMaybe<string> | undefined;
        first?: InputMaybe<number> | undefined;
        last?: InputMaybe<number> | undefined;
    }> | undefined, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetTransactionsQuery>;
    getTransactionsByOwner(variables: GqlGetTransactionsByOwnerQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetTransactionsByOwnerQuery>;
    getBlock(variables?: Exact<{
        blockId?: InputMaybe<string> | undefined;
        blockHeight?: InputMaybe<string> | undefined;
    }> | undefined, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetBlockQuery>;
    getBlockWithTransactions(variables?: Exact<{
        blockId?: InputMaybe<string> | undefined;
        blockHeight?: InputMaybe<string> | undefined;
    }> | undefined, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetBlockWithTransactionsQuery>;
    getBlocks(variables?: Exact<{
        after?: InputMaybe<string> | undefined;
        before?: InputMaybe<string> | undefined;
        first?: InputMaybe<number> | undefined;
        last?: InputMaybe<number> | undefined;
    }> | undefined, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetBlocksQuery>;
    getCoin(variables: GqlGetCoinQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetCoinQuery>;
    getCoins(variables: GqlGetCoinsQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetCoinsQuery>;
    getCoinsToSpend(variables: GqlGetCoinsToSpendQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetCoinsToSpendQuery>;
    getContract(variables: GqlGetContractQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetContractQuery>;
    getBalance(variables: GqlGetBalanceQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetBalanceQuery>;
    getBalances(variables: GqlGetBalancesQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetBalancesQuery>;
    dryRun(variables: GqlDryRunMutationVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlDryRunMutation>;
    submit(variables: GqlSubmitMutationVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlSubmitMutation>;
    startSession(variables?: Exact<{
        [key: string]: never;
    }> | undefined, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlStartSessionMutation>;
    endSession(variables: GqlEndSessionMutationVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlEndSessionMutation>;
    execute(variables: GqlExecuteMutationVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlExecuteMutation>;
    reset(variables: GqlResetMutationVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlResetMutation>;
};

/**
 * A Fuel coin
 */
declare type Coin = {
    id: string;
    assetId: string;
    amount: bigint;
    owner: string;
    status: GqlCoinStatus;
    maturity: bigint;
    blockCreated: bigint;
};

declare type CoinTransactionRequestInput = {
    type: InputType.Coin;
    /** UTXO ID */
    id: BytesLike;
    /** Owning address or script hash */
    owner: BytesLike;
    /** Amount of coins */
    amount: BigNumberish;
    /** Asset ID of the coins */
    assetId: BytesLike;
    /** Index of witness that authorizes spending the coin */
    witnessIndex: number;
    /** UTXO being spent must have been created at least this many blocks ago */
    maturity?: BigNumberish;
    /** Predicate bytecode */
    predicate?: BytesLike;
    /** Predicate input data (parameters) */
    predicateData?: BytesLike;
};
declare type ContractTransactionRequestInput = {
    type: InputType.Contract;
    /** Contract ID */
    contractId: BytesLike;
};
declare type TransactionRequestInput = CoinTransactionRequestInput | ContractTransactionRequestInput;
declare const inputify: (value: TransactionRequestInput) => Input;

declare type CoinTransactionRequestOutput = {
    type: OutputType.Coin;
    /** Receiving address or script hash */
    to: BytesLike;
    /** Amount of coins to send */
    amount: BigNumberish;
    /** Asset ID of coins */
    assetId: BytesLike;
};
declare type ContractTransactionRequestOutput = {
    type: OutputType.Contract;
    /** Index of input contract */
    inputIndex: number;
};
declare type WithdrawalTransactionRequestOutput = {
    type: OutputType.Withdrawal;
    /** Receiving address */
    to: BytesLike;
    /** Amount of coins to withdraw */
    amount: BigNumberish;
    /** Asset ID of coins */
    assetId: BytesLike;
};
declare type ChangeTransactionRequestOutput = {
    type: OutputType.Change;
    /** Receiving address or script hash */
    to: BytesLike;
    /** Asset ID of coins */
    assetId: BytesLike;
};
declare type VariableTransactionRequestOutput = {
    type: OutputType.Variable;
};
declare type ContractCreatedTransactionRequestOutput = {
    type: OutputType.ContractCreated;
    /** Contract ID */
    contractId: BytesLike;
    /** State Root */
    stateRoot: BytesLike;
};
declare type TransactionRequestOutput = CoinTransactionRequestOutput | ContractTransactionRequestOutput | WithdrawalTransactionRequestOutput | ChangeTransactionRequestOutput | VariableTransactionRequestOutput | ContractCreatedTransactionRequestOutput;
declare const outputify: (value: TransactionRequestOutput) => Output;

declare type TransactionRequestStorageSlot = {
    /** Key */
    key: BytesLike;
    /** Value */
    value: BytesLike;
} | [key: BytesLike, value: BytesLike];

declare type TransactionRequestWitness = BytesLike;

declare const returnZeroScript: AbstractScript<void>;
interface BaseTransactionRequestLike {
    /** Gas price for transaction */
    gasPrice?: BigNumberish;
    /** Gas limit for transaction */
    gasLimit?: BigNumberish;
    /** Price per transaction byte */
    bytePrice?: BigNumberish;
    /** Block until which tx cannot be included */
    maturity?: BigNumberish;
    /** List of inputs */
    inputs?: TransactionRequestInput[];
    /** List of outputs */
    outputs?: TransactionRequestOutput[];
    /** List of witnesses */
    witnesses?: TransactionRequestWitness[];
}
declare class ChangeOutputCollisionError extends Error {
    name: string;
    message: string;
}
declare class NoWitnessAtIndexError extends Error {
    readonly index: number;
    name: string;
    constructor(index: number);
}
declare class NoWitnessByOwnerError extends Error {
    readonly owner: Address;
    name: string;
    constructor(owner: Address);
}
declare abstract class BaseTransactionRequest implements BaseTransactionRequestLike {
    /** Type of the transaction */
    abstract type: TransactionType;
    /** Gas price for transaction */
    gasPrice: bigint;
    /** Gas limit for transaction */
    gasLimit: bigint;
    /** Price per transaction byte */
    bytePrice: bigint;
    /** Block until which tx cannot be included */
    maturity: bigint;
    /** List of inputs */
    inputs: TransactionRequestInput[];
    /** List of outputs */
    outputs: TransactionRequestOutput[];
    /** List of witnesses */
    witnesses: TransactionRequestWitness[];
    constructor({ gasPrice, gasLimit, bytePrice, maturity, inputs, outputs, witnesses, }?: BaseTransactionRequestLike);
    protected getBaseTransaction(): Pick<Transaction, keyof BaseTransactionRequestLike | 'inputsCount' | 'outputsCount' | 'witnessesCount'>;
    abstract toTransaction(): Transaction;
    toTransactionBytes(): Uint8Array;
    /**
     * Pushes an input to the list without any side effects and returns the index
     */
    protected pushInput(input: TransactionRequestInput): number;
    /**
     * Pushes an output to the list without any side effects and returns the index
     */
    protected pushOutput(output: TransactionRequestOutput): number;
    /**
     * Creates an empty witness without any side effects and returns the index
     */
    protected createWitness(): number;
    /**
     * Updates an existing witness without any side effects
     */
    updateWitness(index: number, witness: TransactionRequestWitness): void;
    getCoinInputs(): CoinTransactionRequestInput[];
    getCoinOutputs(): CoinTransactionRequestOutput[];
    getChangeOutputs(): ChangeTransactionRequestOutput[];
    /**
     * Returns the witnessIndex of the found CoinInput
     */
    getCoinInputWitnessIndexByOwner(owner: AddressLike): number | null;
    /**
     * Updates the witness for the given CoinInput owner
     */
    updateWitnessByCoinInputOwner(owner: AddressLike, witness: BytesLike): void;
    /**
     * Converts the given Coin to a CoinInput with the appropriate witnessIndex and pushes it
     */
    addCoin(coin: Coin): void;
    addCoins(coins: ReadonlyArray<Coin>): void;
    addCoinOutput(
    /** Address of the destination */
    to: AddressLike, 
    /** Amount of coins */
    amount: BigNumberish, 
    /** Asset ID of coins */
    assetId?: BytesLike): void;
    addCoinOutputs(
    /** Address of the destination */
    to: AddressLike, 
    /** Quantities of coins */
    quantities: CoinQuantityLike[]): void;
    calculateFee(): bigint;
}
interface ScriptTransactionRequestLike extends BaseTransactionRequestLike {
    /** Script to execute */
    script?: BytesLike;
    /** Script input data (parameters) */
    scriptData?: BytesLike;
}
declare class ScriptTransactionRequest extends BaseTransactionRequest {
    static from(obj: ScriptTransactionRequestLike): ScriptTransactionRequest;
    /** Type of the transaction */
    type: TransactionType.Script;
    /** Script to execute */
    script: Uint8Array;
    /** Script input data (parameters) */
    scriptData: Uint8Array;
    constructor({ script, scriptData, ...rest }?: ScriptTransactionRequestLike);
    toTransaction(): Transaction;
    getContractInputs(): ContractTransactionRequestInput[];
    getContractOutputs(): ContractTransactionRequestOutput[];
    getVariableOutputs(): VariableTransactionRequestOutput[];
    setScript<T>(script: AbstractScript<T>, data: T): void;
    addVariableOutputs(numberOfVariables?: number): number;
    addContract(contract: ContractIdLike): void;
}
interface CreateTransactionRequestLike extends BaseTransactionRequestLike {
    /** Witness index of contract bytecode to create */
    bytecodeWitnessIndex?: number;
    /** Salt */
    salt?: BytesLike;
    /** List of static contracts */
    staticContracts?: BytesLike[];
    /** List of storage slots to initialize */
    storageSlots?: TransactionRequestStorageSlot[];
}
declare class CreateTransactionRequest extends BaseTransactionRequest {
    static from(obj: CreateTransactionRequestLike): CreateTransactionRequest;
    /** Type of the transaction */
    type: TransactionType.Create;
    /** Witness index of contract bytecode to create */
    bytecodeWitnessIndex: number;
    /** Salt */
    salt: string;
    /** List of static contracts */
    staticContracts: string[];
    /** List of storage slots to initialize */
    storageSlots: TransactionRequestStorageSlot[];
    constructor({ bytecodeWitnessIndex, salt, staticContracts, storageSlots, ...rest }?: CreateTransactionRequestLike);
    toTransaction(): Transaction;
    getContractCreatedOutputs(): ContractCreatedTransactionRequestOutput[];
    addContractCreatedOutput(
    /** Contract ID */
    contractId: BytesLike, 
    /** State Root */
    stateRoot: BytesLike): void;
}
declare type TransactionRequest = ScriptTransactionRequest | CreateTransactionRequest;
declare type TransactionRequestLike = ({
    type: TransactionType.Script;
} & ScriptTransactionRequestLike) | ({
    type: TransactionType.Create;
} & CreateTransactionRequestLike);
declare const transactionRequestify: (obj: TransactionRequestLike) => TransactionRequest;

declare type TransactionResultCallReceipt = ReceiptCall;
declare type TransactionResultReturnReceipt = ReceiptReturn;
declare type TransactionResultReturnDataReceipt = ReceiptReturnData & {
    data: string;
};
declare type TransactionResultPanicReceipt = ReceiptPanic;
declare type TransactionResultRevertReceipt = ReceiptRevert;
declare type TransactionResultLogReceipt = ReceiptLog;
declare type TransactionResultLogDataReceipt = ReceiptLogData & {
    data: string;
};
declare type TransactionResultTransferReceipt = ReceiptTransfer;
declare type TransactionResultTransferOutReceipt = ReceiptTransferOut;
declare type TransactionResultScriptResultReceipt = ReceiptScriptResult;
declare type TransactionResultReceipt = TransactionResultCallReceipt | TransactionResultReturnReceipt | TransactionResultReturnDataReceipt | TransactionResultPanicReceipt | TransactionResultRevertReceipt | TransactionResultLogReceipt | TransactionResultLogDataReceipt | TransactionResultTransferReceipt | TransactionResultTransferOutReceipt | TransactionResultScriptResultReceipt;
declare type TransactionResult<TStatus extends 'success' | 'failure'> = {
    status: TStatus extends 'success' ? {
        type: 'success';
        programState: any;
    } : {
        type: 'failure';
        reason: any;
    };
    /** Receipts produced during the execution of the transaction */
    receipts: TransactionResultReceipt[];
    transactionId: string;
    blockId: any;
    time: any;
};
declare class TransactionResponse {
    #private;
    /** Transaction ID */
    id: string;
    /** Transaction request */
    request: TransactionRequest;
    provider: Provider;
    constructor(id: string, request: TransactionRequest, provider: Provider);
    /** Waits for transaction to succeed or fail and returns the result */
    waitForResult(): Promise<TransactionResult<any>>;
    /** Waits for transaction to succeed and returns the result */
    wait(): Promise<TransactionResult<'success'>>;
}

declare type CallResult = {
    receipts: TransactionResultReceipt[];
};
/**
 * A Fuel block
 */
declare type Block = {
    id: string;
    height: bigint;
    time: string;
    producer: string;
    transactionIds: string[];
};
/**
 * Deployed Contract bytecode and contract id
 */
declare type ContractResult = {
    id: string;
    bytecode: string;
};
/**
 * Cursor pagination arguments
 *
 * https://relay.dev/graphql/connections.htm#sec-Arguments
 */
declare type CursorPaginationArgs = {
    /** Forward pagination limit */
    first?: number | null;
    /** Forward pagination cursor */
    after?: string | null;
    /** Backward pagination limit  */
    last?: number | null;
    /** Backward pagination cursor */
    before?: string | null;
};
/**
 * Provider Call transaction params
 */
declare type ProviderCallParams = {
    utxoValidation?: boolean;
};
/**
 * A provider for connecting to a Fuel node
 */
declare class Provider {
    /** GraphQL endpoint of the Fuel node */
    url: string;
    operations: ReturnType<typeof getSdk>;
    constructor(
    /** GraphQL endpoint of the Fuel node */
    url: string);
    /**
     * Returns the version of the connected Fuel node
     */
    getVersion(): Promise<string>;
    /**
     * Returns the network configuration of the connected Fuel node
     */
    getNetwork(): Promise<Network>;
    /**
     * Returns the current block number
     */
    getBlockNumber(): Promise<bigint>;
    /**
     * Submits a transaction to the chain to be executed
     */
    sendTransaction(transactionRequestLike: TransactionRequestLike): Promise<TransactionResponse>;
    /**
     * Executes a transaction without actually submitting it to the chain
     */
    call(transactionRequestLike: TransactionRequestLike, { utxoValidation }?: ProviderCallParams): Promise<CallResult>;
    /**
     * Returns coins for the given owner
     */
    getCoins(
    /** The address to get coins for */
    owner: BytesLike, 
    /** The asset ID of coins to get */
    assetId?: BytesLike, 
    /** Pagination arguments */
    paginationArgs?: CursorPaginationArgs): Promise<Coin[]>;
    /**
     * Returns coins for the given owner satisfying the spend query
     */
    getCoinsToSpend(
    /** The address to get coins for */
    owner: BytesLike, 
    /** The quantitites to get */
    quantities: CoinQuantityLike[], 
    /** Maximum number of coins to return */
    maxInputs?: number): Promise<Coin[]>;
    /**
     * Returns block matching the given ID or type
     */
    getBlock(
    /** ID or height of the block */
    idOrHeight: string | number | 'latest'): Promise<Block | null>;
    /**
     * Returns block matching the given ID or type, including transaction data
     */
    getBlockWithTransactions(
    /** ID or height of the block */
    idOrHeight: string | number | 'latest'): Promise<(Block & {
        transactions: Transaction[];
    }) | null>;
    /**
     * Get transaction with the given ID
     */
    getTransaction(transactionId: string): Promise<Transaction | null>;
    /**
     * Get deployed contract with the given ID
     *
     * @returns contract bytecode and contract id
     */
    getContract(contractId: string): Promise<ContractResult | null>;
    /**
     * Returns the balance for the given owner for the given asset ID
     */
    getBalance(
    /** The address to get coins for */
    owner: BytesLike, 
    /** The asset ID of coins to get */
    assetId: BytesLike): Promise<bigint>;
    /**
     * Returns balances for the given owner
     */
    getBalances(
    /** The address to get coins for */
    owner: BytesLike, 
    /** Pagination arguments */
    paginationArgs?: CursorPaginationArgs): Promise<CoinQuantity[]>;
}

declare const getSignableTransaction: (transaction: Transaction) => Transaction;
declare const getTransactionId: (transaction: Transaction) => string;

export { Block, CallResult, ChangeOutputCollisionError, ChangeTransactionRequestOutput, Coin, CoinQuantity, CoinQuantityLike, GqlCoinStatus as CoinStatus, CoinTransactionRequestInput, CoinTransactionRequestOutput, ContractCreatedTransactionRequestOutput, ContractResult, ContractTransactionRequestInput, ContractTransactionRequestOutput, CreateTransactionRequest, CreateTransactionRequestLike, CursorPaginationArgs, NoWitnessAtIndexError, NoWitnessByOwnerError, Provider, ProviderCallParams, ScriptTransactionRequest, ScriptTransactionRequestLike, TransactionRequest, TransactionRequestInput, TransactionRequestLike, TransactionRequestOutput, TransactionResponse, TransactionResult, TransactionResultCallReceipt, TransactionResultLogDataReceipt, TransactionResultLogReceipt, TransactionResultPanicReceipt, TransactionResultReceipt, TransactionResultReturnDataReceipt, TransactionResultReturnReceipt, TransactionResultRevertReceipt, TransactionResultScriptResultReceipt, TransactionResultTransferOutReceipt, TransactionResultTransferReceipt, VariableTransactionRequestOutput, WithdrawalTransactionRequestOutput, coinQuantityfy, getSignableTransaction, getTransactionId, inputify, outputify, returnZeroScript, transactionRequestify };
