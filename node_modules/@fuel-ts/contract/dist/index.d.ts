import { FunctionFragment, Interface, JsonAbi } from '@fuel-ts/abi-coder';
import { AbstractContract } from '@fuel-ts/interfaces';
import { BigNumberish } from '@fuel-ts/math';
import { ScriptTransactionRequest, Provider, TransactionRequest, CallResult, TransactionResult, CoinQuantityLike, CreateTransactionRequestLike } from '@fuel-ts/providers';
import { Wallet } from '@fuel-ts/wallet';
import { BytesLike } from '@ethersproject/bytes';

declare type ContractFunction<T = any> = (...args: Array<any>) => Promise<T>;
declare type ContractCallOptions = Partial<{
    gasLimit: BigNumberish;
    forward: CoinQuantityLike;
    variableOutputs: number;
}>;
declare type ContractCall = {
    contract: Contract;
    func: FunctionFragment;
    args: Array<any>;
    options: ContractCallOptions;
};
declare type TransactionOverrides = Partial<{
    gasPrice: BigNumberish;
    gasLimit: BigNumberish;
    bytePrice: BigNumberish;
    maturity: BigNumberish;
    transformRequest?: (transactionRequest: ScriptTransactionRequest) => Promise<ScriptTransactionRequest>;
}>;
declare type Overrides = ContractCallOptions & TransactionOverrides;
declare type BuildTransactionOptions = Partial<{
    fundTransaction: boolean;
}> & TransactionOverrides;
declare const buildTransaction: (calls: ContractCall[], options?: BuildTransactionOptions) => Promise<ScriptTransactionRequest>;
declare class Contract extends AbstractContract {
    interface: Interface;
    id: string;
    provider: Provider | null;
    wallet: Wallet | null;
    transaction?: string;
    request?: TransactionRequest;
    prepareCall: {
        [key: string]: (...args: any[]) => ContractCall;
    };
    dryRun: {
        [key: string]: ContractFunction<any>;
    };
    dryRunResult: {
        [key: string]: ContractFunction<CallResult>;
    };
    submit: {
        [key: string]: ContractFunction<any>;
    };
    submitResult: {
        [key: string]: ContractFunction<TransactionResult<any>>;
    };
    simulate: {
        [key: string]: ContractFunction<any>;
    };
    simulateResult: {
        [key: string]: ContractFunction<CallResult>;
    };
    constructor(id: string, abi: JsonAbi | Interface, walletOrProvider?: Wallet | Provider | null, transactionId?: string, request?: TransactionRequest);
    dryRunMulticall(calls: ContractCall[], options?: BuildTransactionOptions): Promise<any[]>;
    submitMulticall(calls: ContractCall[], options?: BuildTransactionOptions): Promise<any[]>;
    simulateMulticall(calls: ContractCall[], options?: BuildTransactionOptions): Promise<CallResult>;
}

declare type DeployContractOptions = {
    salt?: BytesLike;
    storageSlots?: Array<[BytesLike, BytesLike]>;
    stateRoot?: BytesLike;
} & CreateTransactionRequestLike;
declare class ContractFactory {
    bytecode: BytesLike;
    interface: Interface;
    provider: Provider | null;
    wallet: Wallet | null;
    constructor(bytecode: BytesLike, abi: JsonAbi | Interface, walletOrProvider?: Wallet | Provider | null);
    connect(provider: Provider | null): ContractFactory;
    deployContract(deployContractOptions?: DeployContractOptions): Promise<Contract>;
}

declare const getContractRoot: (bytecode: Uint8Array) => string;
declare const getContractStorageRoot: (storageSlots: [BytesLike, BytesLike][]) => string;
declare const getContractId: (bytecode: BytesLike, salt: BytesLike, stateRoot: BytesLike) => string;

declare const util_getContractRoot: typeof getContractRoot;
declare const util_getContractStorageRoot: typeof getContractStorageRoot;
declare const util_getContractId: typeof getContractId;
declare namespace util {
  export {
    util_getContractRoot as getContractRoot,
    util_getContractStorageRoot as getContractStorageRoot,
    util_getContractId as getContractId,
  };
}

export { BuildTransactionOptions, Contract, ContractCall, ContractFactory, util as ContractUtils, Overrides, TransactionOverrides, buildTransaction };
