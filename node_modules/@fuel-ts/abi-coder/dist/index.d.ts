import { BytesLike } from '@ethersproject/bytes';
import { RequireExactlyOne } from 'type-fest';
import { ParamType } from '@ethersproject/abi';

declare type Primitive = string | number | boolean | bigint;
/**
 * The type of value you can provide to `Coder.encode`
 */
declare type InputValue = Primitive | BytesLike | InputValue[] | {
    [key: string]: InputValue;
} | Record<string, Primitive | BytesLike>;
/**
 * The type of value you can get from `Coder.decode`
 */
declare type DecodedValue = Primitive | DecodedValue[] | {
    [key: string]: DecodedValue;
} | Record<string, Primitive>;
declare type TypesOfCoder<TCoder> = TCoder extends Coder<infer TInput, infer TDecoded> ? {
    Input: TInput;
    Decoded: TDecoded;
} : never;
declare abstract class Coder<TInput = unknown, TDecoded = unknown> {
    readonly name: string;
    readonly type: string;
    readonly encodedLength: number;
    constructor(name: string, type: string, encodedLength: number);
    throwError(message: string, value: unknown): never;
    abstract encode(value: TInput, length?: number): Uint8Array;
    abstract decode(data: Uint8Array, offset: number, length?: number): [TDecoded, number];
}

declare type InputValueOf$3<TCoder extends Coder> = Array<TypesOfCoder<TCoder>['Input']>;
declare type DecodedValueOf$3<TCoder extends Coder> = Array<TypesOfCoder<TCoder>['Decoded']>;
declare class ArrayCoder<TCoder extends Coder> extends Coder<InputValueOf$3<TCoder>, DecodedValueOf$3<TCoder>> {
    coder: TCoder;
    length: number;
    constructor(coder: TCoder, length: number);
    encode(value: InputValueOf$3<TCoder>): Uint8Array;
    decode(data: Uint8Array, offset: number): [DecodedValueOf$3<TCoder>, number];
}

declare class B256Coder extends Coder<string, string> {
    constructor();
    encode(value: string): Uint8Array;
    decode(data: Uint8Array, offset: number): [string, number];
}

declare class BooleanCoder extends Coder<boolean, boolean> {
    constructor();
    encode(value: boolean): Uint8Array;
    decode(data: Uint8Array, offset: number): [boolean, number];
}

declare class ByteCoder extends Coder<number, number> {
    constructor();
    encode(value: number): Uint8Array;
    decode(data: Uint8Array, offset: number): [number, number];
}

declare type InputValueOf$2<TCoders extends Record<string, Coder>> = RequireExactlyOne<{
    [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Input'];
}>;
declare type DecodedValueOf$2<TCoders extends Record<string, Coder>> = RequireExactlyOne<{
    [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Decoded'];
}>;
declare class EnumCoder<TCoders extends Record<string, Coder>> extends Coder<InputValueOf$2<TCoders>, DecodedValueOf$2<TCoders>> {
    #private;
    name: string;
    coders: TCoders;
    constructor(name: string, coders: TCoders);
    encode(value: InputValueOf$2<TCoders>): Uint8Array;
    decode(data: Uint8Array, offset: number): [DecodedValueOf$2<TCoders>, number];
}

declare type NumberCoderType = 'u8' | 'u16' | 'u32' | 'u64';
declare type ToDecodedType<TBaseType extends NumberCoderType> = TBaseType extends 'u64' ? bigint : number;
declare class NumberCoder<TBaseType extends NumberCoderType = NumberCoderType> extends Coder<number | bigint, ToDecodedType<TBaseType>> {
    #private;
    length: number;
    baseType: TBaseType;
    constructor(baseType: TBaseType);
    encode(value: number | bigint): Uint8Array;
    decode(data: Uint8Array, offset: number): [ToDecodedType<TBaseType>, number];
}

declare class StringCoder<TLength extends number = number> extends Coder<string, string> {
    #private;
    length: TLength;
    constructor(length: TLength);
    encode(value: string): Uint8Array;
    decode(data: Uint8Array, offset: number): [string, number];
}

declare type InputValueOf$1<TCoders extends Record<string, Coder>> = {
    [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Input'];
};
declare type DecodedValueOf$1<TCoders extends Record<string, Coder>> = {
    [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Decoded'];
};
declare class StructCoder<TCoders extends Record<string, Coder>> extends Coder<InputValueOf$1<TCoders>, DecodedValueOf$1<TCoders>> {
    name: string;
    coders: TCoders;
    constructor(name: string, coders: TCoders);
    encode(value: InputValueOf$1<TCoders>): any;
    decode(data: Uint8Array, offset: number): [DecodedValueOf$1<TCoders>, number];
}

declare type InputValueOf<TCoders extends Coder[]> = {
    [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Input'];
};
declare type DecodedValueOf<TCoders extends Coder[]> = {
    [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Decoded'];
};
declare class TupleCoder<TCoders extends Coder[]> extends Coder<InputValueOf<TCoders>, DecodedValueOf<TCoders>> {
    coders: TCoders;
    constructor(coders: TCoders);
    encode(value: InputValueOf<TCoders>): Uint8Array;
    decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoders>, number];
}

declare function filterEmptyParams<T>(types: T): T;

interface FragmentParams {
    readonly type: string;
    readonly name: string;
    readonly inputs: Array<ParamType>;
    readonly outputs: Array<ParamType>;
}
declare abstract class Fragment {
    readonly type: string;
    readonly name: string;
    readonly inputs: Array<ParamType>;
    readonly outputs: Array<ParamType>;
    constructor(params: FragmentParams);
    abstract format(format?: string): string;
}

/**
 * Types for Fuel JSON ABI Format as defined on:
 * https://github.com/FuelLabs/fuel-specs/blob/master/specs/protocol/abi.md#json-abi-format
 */
interface JsonAbiFragmentType {
    readonly type: string;
    readonly name?: string;
    readonly components?: ReadonlyArray<JsonAbiFragmentType> | null;
}
interface JsonAbiFragment {
    readonly type: 'function' | string;
    readonly name: string;
    readonly inputs?: ReadonlyArray<JsonAbiFragmentType>;
    readonly outputs?: ReadonlyArray<JsonAbiFragmentType>;
}
/**
 * A JSON ABI object
 */
declare type JsonAbi = ReadonlyArray<JsonAbiFragment>;
/**
 * Checks if a given type is a reference type
 * See: https://github.com/FuelLabs/sway/issues/1368
 */
declare const isReferenceType: (type: string) => boolean;

declare class FunctionFragment extends Fragment {
    static fromObject(value: JsonAbiFragment): FunctionFragment;
    format(): string;
}

declare class AbiCoder {
    constructor();
    getCoder(param: JsonAbiFragmentType): Coder;
    encode(types: ReadonlyArray<JsonAbiFragmentType>, values: InputValue[]): Uint8Array;
    decode(types: ReadonlyArray<JsonAbiFragmentType>, data: BytesLike): DecodedValue[] | undefined;
}

declare class Interface {
    readonly fragments: Array<Fragment>;
    readonly functions: {
        [name: string]: FunctionFragment;
    };
    readonly abiCoder: AbiCoder;
    constructor(jsonAbi: JsonAbi);
    static getSighash(fragment: FunctionFragment | string): Uint8Array;
    getFunction(nameOrSignatureOrSighash: string): FunctionFragment;
    decodeFunctionData(functionFragment: FunctionFragment | string, data: BytesLike): any;
    encodeFunctionData(functionFragment: FunctionFragment | string, values: Array<InputValue>): Uint8Array;
    decodeFunctionResult(functionFragment: FunctionFragment | string, data: BytesLike): any;
    encodeFunctionResult(functionFragment: FunctionFragment | string, values: Array<InputValue>): Uint8Array;
}

export { AbiCoder, ArrayCoder, B256Coder, BooleanCoder, ByteCoder, Coder, DecodedValue, EnumCoder, Fragment, FunctionFragment, InputValue, Interface, JsonAbi, JsonAbiFragment, JsonAbiFragmentType, NumberCoder, StringCoder, StructCoder, TupleCoder, TypesOfCoder, filterEmptyParams, isReferenceType };
