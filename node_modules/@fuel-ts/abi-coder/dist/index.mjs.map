{"version":3,"sources":["../src/coders/abstract-coder.ts","../src/coders/array.ts","../src/coders/b256.ts","../src/coders/boolean.ts","../src/coders/byte.ts","../src/coders/enum.ts","../src/coders/number.ts","../src/coders/string.ts","../src/coders/struct.ts","../src/coders/tuple.ts","../src/utilities.ts","../src/fragments/fragment.ts","../src/fragments/function-fragment.ts","../src/abi-coder.ts","../src/interface.ts","../src/json-abi.ts"],"sourcesContent":["import type { BytesLike } from '@ethersproject/bytes';\nimport { Logger } from '@ethersproject/logger';\n\nconst logger = new Logger(process.env.BUILD_VERSION || '~');\n\ntype Primitive = string | number | boolean | bigint;\n\n/**\n * The type of value you can provide to `Coder.encode`\n */\nexport type InputValue =\n  | Primitive\n  | BytesLike\n  | InputValue[]\n  | { [key: string]: InputValue }\n  | Record<string, Primitive | BytesLike>;\n\n/**\n * The type of value you can get from `Coder.decode`\n */\nexport type DecodedValue =\n  | Primitive\n  | DecodedValue[]\n  | { [key: string]: DecodedValue }\n  | Record<string, Primitive>;\n\nexport type TypesOfCoder<TCoder> = TCoder extends Coder<infer TInput, infer TDecoded>\n  ? { Input: TInput; Decoded: TDecoded }\n  : never;\n\nexport default abstract class Coder<TInput = unknown, TDecoded = unknown> {\n  readonly name: string;\n  readonly type: string;\n  readonly encodedLength: number;\n\n  constructor(name: string, type: string, encodedLength: number) {\n    this.name = name;\n    this.type = type;\n    this.encodedLength = encodedLength;\n  }\n\n  throwError(message: string, value: unknown): never {\n    logger.throwArgumentError(message, this.name, value);\n    // `logger.throwArgumentError` throws, but TS doesn't know it\n    // so we throw here to make sure our `never` works\n    throw new Error('unreachable');\n  }\n\n  abstract encode(value: TInput, length?: number): Uint8Array;\n\n  abstract decode(data: Uint8Array, offset: number, length?: number): [TDecoded, number];\n}\n","import { concat } from '@ethersproject/bytes';\n\nimport type { TypesOfCoder } from './abstract-coder';\nimport Coder from './abstract-coder';\n\ntype InputValueOf<TCoder extends Coder> = Array<TypesOfCoder<TCoder>['Input']>;\ntype DecodedValueOf<TCoder extends Coder> = Array<TypesOfCoder<TCoder>['Decoded']>;\n\nexport default class ArrayCoder<TCoder extends Coder> extends Coder<\n  InputValueOf<TCoder>,\n  DecodedValueOf<TCoder>\n> {\n  coder: TCoder;\n  length: number;\n\n  constructor(coder: TCoder, length: number) {\n    super('array', `[${coder.type}; ${length}]`, length * coder.encodedLength);\n    this.coder = coder;\n    this.length = length;\n  }\n\n  encode(value: InputValueOf<TCoder>): Uint8Array {\n    if (!Array.isArray(value)) {\n      this.throwError('expected array value', value);\n    }\n\n    if (this.length !== value.length) {\n      this.throwError('Types/values length mismatch', value);\n    }\n\n    return concat(Array.from(value).map((v) => this.coder.encode(v)));\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoder>, number] {\n    let newOffset = offset;\n    const decodedValue = Array(this.length)\n      .fill(0)\n      .map(() => {\n        let decoded;\n        [decoded, newOffset] = this.coder.decode(data, newOffset);\n        return decoded;\n      });\n\n    return [decodedValue as DecodedValueOf<TCoder>, newOffset];\n  }\n}\n","import { hexlify, arrayify } from '@ethersproject/bytes';\nimport { toBigInt } from '@fuel-ts/math';\n\nimport Coder from './abstract-coder';\n\nexport default class B256Coder extends Coder<string, string> {\n  constructor() {\n    super('b256', 'b256', 32);\n  }\n\n  encode(value: string): Uint8Array {\n    let encodedValue;\n    try {\n      encodedValue = arrayify(value);\n    } catch (error) {\n      this.throwError(`Invalid ${this.type}`, value);\n    }\n    if (encodedValue.length !== 32) {\n      this.throwError(`Invalid ${this.type}`, value);\n    }\n    return encodedValue;\n  }\n\n  decode(data: Uint8Array, offset: number): [string, number] {\n    let bytes = data.slice(offset, offset + 32);\n\n    if (toBigInt(bytes) === 0n) {\n      bytes = new Uint8Array(32);\n    }\n\n    if (bytes.length !== 32) {\n      this.throwError('Invalid size for b256', bytes);\n    }\n    return [hexlify(bytes), offset + 32];\n  }\n}\n","import { zeroPad } from '@ethersproject/bytes';\nimport { toArray, toBigInt } from '@fuel-ts/math';\n\nimport Coder from './abstract-coder';\n\nexport default class BooleanCoder extends Coder<boolean, boolean> {\n  constructor() {\n    super('boolean', 'boolean', 8);\n  }\n\n  encode(value: boolean): Uint8Array {\n    let bytes;\n\n    try {\n      bytes = toArray(value ? 1 : 0);\n    } catch (error) {\n      this.throwError('Invalid bool', value);\n    }\n    if (bytes.length > 1) {\n      this.throwError('Invalid bool', value);\n    }\n\n    return zeroPad(bytes, 8);\n  }\n\n  decode(data: Uint8Array, offset: number): [boolean, number] {\n    const bytes = toBigInt(data.slice(offset, offset + 8));\n    if (bytes === 0n) {\n      return [false, offset + 8];\n    }\n    if (bytes !== 1n) {\n      this.throwError('Invalid boolean value', bytes);\n    }\n    return [true, offset + 8];\n  }\n}\n","import { zeroPad } from '@ethersproject/bytes';\nimport { toArray, toBigInt } from '@fuel-ts/math';\n\nimport Coder from './abstract-coder';\n\nexport default class ByteCoder extends Coder<number, number> {\n  constructor() {\n    super('byte', 'byte', 8);\n  }\n\n  encode(value: number): Uint8Array {\n    let bytes;\n\n    try {\n      bytes = toArray(value);\n    } catch (error) {\n      this.throwError('Invalid Byte', value);\n    }\n    if (bytes.length > 1) {\n      this.throwError('Invalid Byte', value);\n    }\n\n    return zeroPad(bytes, 8);\n  }\n\n  decode(data: Uint8Array, offset: number): [number, number] {\n    const bytes = data.slice(offset, offset + 8);\n    const value = toBigInt(bytes);\n    if (value > 255n) {\n      this.throwError('Invalid Byte', value);\n    }\n    const byte = Number(value);\n    return [byte, offset + 8];\n  }\n}\n","import { concat } from '@ethersproject/bytes';\nimport type { RequireExactlyOne } from 'type-fest';\n\nimport type { TypesOfCoder } from './abstract-coder';\nimport Coder from './abstract-coder';\nimport NumberCoder from './number';\n\ntype InputValueOf<TCoders extends Record<string, Coder>> = RequireExactlyOne<{\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Input'];\n}>;\ntype DecodedValueOf<TCoders extends Record<string, Coder>> = RequireExactlyOne<{\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Decoded'];\n}>;\n\nexport default class EnumCoder<TCoders extends Record<string, Coder>> extends Coder<\n  InputValueOf<TCoders>,\n  DecodedValueOf<TCoders>\n> {\n  name: string;\n  coders: TCoders;\n  #caseIndexCoder: NumberCoder<'u64'>;\n  #encodedValueSize: number;\n\n  constructor(name: string, coders: TCoders) {\n    const caseIndexCoder = new NumberCoder('u64');\n    const encodedValueSize = Object.values(coders).reduce(\n      (max, coder) => Math.max(max, coder.encodedLength),\n      0\n    );\n    super('enum', `enum ${name}`, caseIndexCoder.encodedLength + encodedValueSize);\n    this.name = name;\n    this.coders = coders;\n    this.#caseIndexCoder = caseIndexCoder;\n    this.#encodedValueSize = encodedValueSize;\n  }\n\n  encode(value: InputValueOf<TCoders>): Uint8Array {\n    const [caseKey, ...empty] = Object.keys(value);\n    if (!caseKey) {\n      throw new Error('A field for the case must be provided');\n    }\n    if (empty.length !== 0) {\n      throw new Error('Only one field must be provided');\n    }\n    const valueCoder = this.coders[caseKey];\n    const caseIndex = Object.keys(this.coders).indexOf(caseKey);\n    const encodedValue = valueCoder.encode(value[caseKey]);\n    const padding = new Uint8Array(this.#encodedValueSize - valueCoder.encodedLength);\n    return concat([this.#caseIndexCoder.encode(caseIndex), padding, encodedValue]);\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoders>, number] {\n    let newOffset = offset;\n\n    let decoded;\n    [decoded, newOffset] = new NumberCoder('u64').decode(data, newOffset);\n    const caseIndex = decoded;\n    const caseKey = Object.keys(this.coders)[Number(caseIndex)];\n    if (!caseKey) {\n      throw new Error(`Invalid caseIndex \"${caseIndex}\". Valid cases: ${Object.keys(this.coders)}`);\n    }\n    const valueCoder = this.coders[caseKey];\n    const padding = this.#encodedValueSize - valueCoder.encodedLength;\n    newOffset += padding;\n    [decoded, newOffset] = valueCoder.decode(data, newOffset);\n\n    return [{ [caseKey]: decoded } as DecodedValueOf<TCoders>, newOffset];\n  }\n}\n","import { zeroPad } from '@ethersproject/bytes';\nimport { toArray, toBigInt, toNumber } from '@fuel-ts/math';\n\nimport Coder from './abstract-coder';\n\ntype NumberCoderType = 'u8' | 'u16' | 'u32' | 'u64';\n\ntype ToDecodedType<TBaseType extends NumberCoderType> = TBaseType extends 'u64' ? bigint : number;\n\nexport default class NumberCoder<TBaseType extends NumberCoderType = NumberCoderType> extends Coder<\n  number | bigint,\n  ToDecodedType<TBaseType>\n> {\n  // This is to align the bits to the total bytes\n  // See https://github.com/FuelLabs/fuel-specs/blob/master/specs/protocol/abi.md#unsigned-integers\n  length: number;\n  baseType: TBaseType;\n\n  constructor(baseType: TBaseType) {\n    super('number', baseType, 8);\n    this.baseType = baseType;\n    switch (baseType) {\n      case 'u8':\n        this.length = 1;\n        break;\n      case 'u16':\n        this.length = 2;\n        break;\n      case 'u32':\n        this.length = 4;\n        break;\n      case 'u64':\n      default:\n        this.length = 8;\n        break;\n    }\n  }\n\n  encode(value: number | bigint): Uint8Array {\n    let bytes;\n\n    try {\n      bytes = toArray(value);\n    } catch (error) {\n      this.throwError(`Invalid ${this.baseType}`, value);\n    }\n    if (bytes.length > this.length) {\n      this.throwError(`Invalid ${this.baseType}`, value);\n    }\n\n    return zeroPad(bytes, 8);\n  }\n\n  #decodeBigInt(data: Uint8Array, offset: number): [bigint, number] {\n    let bytes = data.slice(offset, offset + 8);\n    bytes = bytes.slice(8 - this.length, 8);\n    const num = toBigInt(bytes);\n    return [num, offset + 8];\n  }\n\n  decode(data: Uint8Array, offset: number): [ToDecodedType<TBaseType>, number] {\n    const [num, nextOffset] = this.#decodeBigInt(data, offset);\n    if (this.baseType === 'u64') {\n      return [num as ToDecodedType<TBaseType>, nextOffset];\n    }\n    return [toNumber(num) as ToDecodedType<TBaseType>, nextOffset];\n  }\n}\n","import { concat } from '@ethersproject/bytes';\nimport { toUtf8Bytes, toUtf8String } from '@ethersproject/strings';\n\nimport Coder from './abstract-coder';\n\nexport default class StringCoder<TLength extends number = number> extends Coder<string, string> {\n  length: TLength;\n  #paddingLength: number;\n\n  constructor(length: TLength) {\n    let paddingLength = (8 - length) % 8;\n    paddingLength = paddingLength < 0 ? paddingLength + 8 : paddingLength;\n    super('string', `str[${length}]`, length + paddingLength);\n    this.length = length;\n    this.#paddingLength = paddingLength;\n  }\n\n  encode(value: string): Uint8Array {\n    const encoded = toUtf8Bytes(value.slice(0, this.length));\n    const padding = new Uint8Array(this.#paddingLength);\n    return concat([encoded, padding]);\n  }\n\n  decode(data: Uint8Array, offset: number): [string, number] {\n    const bytes = data.slice(offset, offset + this.length);\n    const value = toUtf8String(bytes);\n\n    const padding = this.#paddingLength;\n    return [value, offset + this.length + padding];\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { concat } from '@ethersproject/bytes';\n\nimport type { TypesOfCoder } from './abstract-coder';\nimport Coder from './abstract-coder';\n\ntype InputValueOf<TCoders extends Record<string, Coder>> = {\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Input'];\n};\ntype DecodedValueOf<TCoders extends Record<string, Coder>> = {\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Decoded'];\n};\n\nexport default class StructCoder<TCoders extends Record<string, Coder>> extends Coder<\n  InputValueOf<TCoders>,\n  DecodedValueOf<TCoders>\n> {\n  name: string;\n  coders: TCoders;\n\n  constructor(name: string, coders: TCoders) {\n    const encodedLength = Object.values(coders).reduce(\n      (acc, coder) => acc + coder.encodedLength,\n      0\n    );\n    super('struct', `struct ${name}`, encodedLength);\n    this.name = name;\n    this.coders = coders;\n  }\n\n  encode(value: InputValueOf<TCoders>): any {\n    const encodedFields = Object.keys(this.coders).map((fieldName) => {\n      const fieldCoder = this.coders[fieldName];\n      const fieldValue = value[fieldName];\n      const encoded = fieldCoder.encode(fieldValue);\n      return encoded;\n    });\n    return concat(encodedFields);\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoders>, number] {\n    let newOffset = offset;\n    const decodedValue = Object.keys(this.coders).reduce((obj, fieldName) => {\n      const fieldCoder = this.coders[fieldName];\n      let decoded;\n      [decoded, newOffset] = fieldCoder.decode(data, newOffset);\n      // eslint-disable-next-line no-param-reassign\n      obj[fieldName as keyof DecodedValueOf<TCoders>] = decoded;\n      return obj;\n    }, {} as DecodedValueOf<TCoders>);\n\n    return [decodedValue, newOffset];\n  }\n}\n","import { concat } from '@ethersproject/bytes';\n\nimport type { TypesOfCoder } from './abstract-coder';\nimport Coder from './abstract-coder';\n\ntype InputValueOf<TCoders extends Coder[]> = {\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Input'];\n};\ntype DecodedValueOf<TCoders extends Coder[]> = {\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Decoded'];\n};\n\nexport default class TupleCoder<TCoders extends Coder[]> extends Coder<\n  InputValueOf<TCoders>,\n  DecodedValueOf<TCoders>\n> {\n  coders: TCoders;\n\n  constructor(coders: TCoders) {\n    const encodedLength = coders.reduce((acc, coder) => acc + coder.encodedLength, 0);\n    super('tuple', `(${coders.map((coder) => coder.type).join(', ')})`, encodedLength);\n    this.coders = coders;\n  }\n\n  encode(value: InputValueOf<TCoders>): Uint8Array {\n    if (this.coders.length !== value.length) {\n      this.throwError('Types/values length mismatch', { value });\n    }\n\n    return concat(this.coders.map((coder, i) => coder.encode(value[i])));\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoders>, number] {\n    let newOffset = offset;\n    const decodedValue = this.coders.map((coder) => {\n      let decoded;\n      [decoded, newOffset] = coder.decode(data, newOffset);\n      return decoded;\n    });\n\n    return [decodedValue as DecodedValueOf<TCoders>, newOffset];\n  }\n}\n","import type { ParamType } from '@ethersproject/abi';\n\nexport function filterEmptyParams<T>(types: T): T;\nexport function filterEmptyParams(types: ReadonlyArray<string | ParamType>) {\n  return types.filter((t) => (t as Readonly<ParamType>)?.type !== '()' && t !== '()');\n}\n","import type { ParamType } from '@ethersproject/abi';\n\ninterface FragmentParams {\n  readonly type: string;\n  readonly name: string;\n  readonly inputs: Array<ParamType>;\n  readonly outputs: Array<ParamType>;\n}\n\nexport abstract class Fragment {\n  readonly type: string;\n  readonly name: string;\n  readonly inputs: Array<ParamType> = [];\n  readonly outputs: Array<ParamType> = [];\n\n  constructor(params: FragmentParams) {\n    this.type = params.type;\n    this.name = params.name;\n    this.inputs = params.inputs;\n    this.outputs = params.outputs;\n  }\n\n  abstract format(format?: string): string;\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { FormatTypes, ParamType } from '@ethersproject/abi';\n\nimport { arrayRegEx, structRegEx } from '../abi-coder';\nimport type { JsonAbiFragment } from '../json-abi';\n\nimport { Fragment } from './fragment';\n\n/**\n * An override for the `format` method of Ethers' ParamType to handle Fuel/Ethereum ABI incompatibilities\n */\nfunction formatOverride(this: ParamType, format?: string): string {\n  if (!format || format === FormatTypes.sighash) {\n    const structMatch = structRegEx.exec(this.type)?.groups;\n    if (structMatch) {\n      return `s${this.format(format)}`;\n    }\n\n    const arrayMatch = arrayRegEx.exec(this.type)?.groups;\n    if (arrayMatch) {\n      return `[${arrayMatch.item}; ${arrayMatch.length}]`;\n    }\n  }\n\n  return this.format(format);\n}\n\nexport default class FunctionFragment extends Fragment {\n  static fromObject(value: JsonAbiFragment): FunctionFragment {\n    const { inputs = [], outputs = [] } = value;\n\n    const params = {\n      type: 'function',\n      name: value.name,\n      // TODO: Remove `as any`s when forc doesn't output nulls (https://github.com/FuelLabs/sway/issues/926)\n      inputs: (inputs as any).map(ParamType.fromObject),\n      outputs: (outputs as any).map(ParamType.fromObject),\n    };\n\n    return new FunctionFragment(params);\n  }\n\n  format(): string {\n    const inputFormat = this.inputs.map((input) => formatOverride.call(input));\n    return `${this.name}(${inputFormat.join(',')})`;\n  }\n}\n","// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\nimport type { BytesLike } from '@ethersproject/bytes';\nimport { arrayify } from '@ethersproject/bytes';\nimport { Logger } from '@ethersproject/logger';\n\nimport type { DecodedValue, InputValue } from './coders/abstract-coder';\nimport type Coder from './coders/abstract-coder';\nimport ArrayCoder from './coders/array';\nimport B256Coder from './coders/b256';\nimport BooleanCoder from './coders/boolean';\nimport ByteCoder from './coders/byte';\nimport EnumCoder from './coders/enum';\nimport NumberCoder from './coders/number';\nimport StringCoder from './coders/string';\nimport StructCoder from './coders/struct';\nimport TupleCoder from './coders/tuple';\nimport type { JsonAbiFragmentType } from './json-abi';\nimport { filterEmptyParams } from './utilities';\n\nexport const stringRegEx = /str\\[(?<length>[0-9]+)\\]/;\nexport const arrayRegEx = /\\[(?<item>[\\w\\s]+);\\s*(?<length>[0-9]+)\\]/;\nexport const structRegEx = /^struct (?<name>\\w+)$/;\nexport const enumRegEx = /^enum (?<name>\\w+)$/;\nexport const tupleRegEx = /^\\((?<items>.*)\\)$/;\n\nconst logger = new Logger(process.env.BUILD_VERSION || '~');\n\nexport default class AbiCoder {\n  constructor() {\n    logger.checkNew(new.target, AbiCoder);\n  }\n\n  getCoder(param: JsonAbiFragmentType): Coder {\n    switch (param.type) {\n      case 'u8':\n      case 'u16':\n      case 'u32':\n      case 'u64':\n        return new NumberCoder(param.type);\n      case 'bool':\n        return new BooleanCoder();\n      case 'byte':\n        return new ByteCoder();\n      case 'b256':\n        return new B256Coder();\n      default:\n    }\n\n    const stringMatch = stringRegEx.exec(param.type)?.groups;\n    if (stringMatch) {\n      const length = parseInt(stringMatch.length, 10);\n\n      return new StringCoder(length);\n    }\n\n    const arrayMatch = arrayRegEx.exec(param.type)?.groups;\n    if (arrayMatch) {\n      const length = parseInt(arrayMatch.length, 10);\n      const itemComponent = param.components?.[0];\n      if (!itemComponent) {\n        throw new Error('Expected array type to have an item component');\n      }\n      const itemCoder = this.getCoder(itemComponent);\n      return new ArrayCoder(itemCoder, length);\n    }\n\n    const structMatch = structRegEx.exec(param.type)?.groups;\n    if (structMatch && Array.isArray(param.components)) {\n      const coders = param.components.reduce((obj, component) => {\n        // eslint-disable-next-line no-param-reassign\n        obj[component.name] = this.getCoder(component);\n        return obj;\n      }, {});\n      return new StructCoder(structMatch.name, coders);\n    }\n\n    const enumMatch = enumRegEx.exec(param.type)?.groups;\n    if (enumMatch && Array.isArray(param.components)) {\n      const coders = param.components.reduce((obj, component) => {\n        // eslint-disable-next-line no-param-reassign\n        obj[component.name] = this.getCoder(component);\n        return obj;\n      }, {});\n      return new EnumCoder(enumMatch.name, coders);\n    }\n\n    const tupleMatch = tupleRegEx.exec(param.type)?.groups;\n    if (tupleMatch && Array.isArray(param.components)) {\n      const coders = param.components.map((component) => this.getCoder(component));\n      return new TupleCoder(coders);\n    }\n\n    return logger.throwArgumentError('Invalid type', 'type', param.type);\n  }\n\n  encode(types: ReadonlyArray<JsonAbiFragmentType>, values: InputValue[]): Uint8Array {\n    const nonEmptyTypes = filterEmptyParams(types);\n\n    if (Array.isArray(values) && nonEmptyTypes.length !== values.length) {\n      logger.throwError('Types/values length mismatch', Logger.errors.INVALID_ARGUMENT, {\n        count: { types: nonEmptyTypes.length, values: values.length },\n        value: { types, values },\n      });\n    }\n\n    const coders = nonEmptyTypes.map((type) => this.getCoder(type));\n    const coder = new TupleCoder(coders);\n    return coder.encode(values);\n  }\n\n  decode(types: ReadonlyArray<JsonAbiFragmentType>, data: BytesLike): DecodedValue[] | undefined {\n    const bytes = arrayify(data);\n    const nonEmptyTypes = filterEmptyParams(types);\n    const assertParamsMatch = (newOffset: number) => {\n      if (newOffset !== bytes.length) {\n        logger.throwError('Types/values length mismatch', Logger.errors.INVALID_ARGUMENT, {\n          count: { types: nonEmptyTypes.length, values: bytes.length },\n          value: { types: nonEmptyTypes, bytes },\n        });\n      }\n    };\n\n    if (types.length === 0 || nonEmptyTypes.length === 0) {\n      // The VM is current return 0x0000000000000000, but we should treat it as undefined / void\n      assertParamsMatch(bytes.length ? 8 : 0);\n      return undefined;\n    }\n\n    const coders = nonEmptyTypes.map((type) => this.getCoder(type));\n    const coder = new TupleCoder(coders);\n    const [decoded, newOffset] = coder.decode(bytes, 0);\n\n    assertParamsMatch(newOffset);\n\n    return decoded as DecodedValue[];\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { BytesLike } from '@ethersproject/bytes';\nimport { arrayify, concat, hexlify } from '@ethersproject/bytes';\nimport { Logger } from '@ethersproject/logger';\nimport { sha256 } from '@ethersproject/sha2';\nimport { toUtf8Bytes } from '@ethersproject/strings';\n\nimport AbiCoder from './abi-coder';\nimport type { InputValue } from './coders/abstract-coder';\nimport BooleanCoder from './coders/boolean';\nimport type { Fragment } from './fragments/fragment';\nimport FunctionFragment from './fragments/function-fragment';\nimport type { JsonAbi, JsonAbiFragment } from './json-abi';\nimport { isReferenceType } from './json-abi';\nimport { filterEmptyParams } from './utilities';\n\nconst logger = new Logger(process.env.BUILD_VERSION || '~');\n\nconst coerceFragments = (value: ReadonlyArray<JsonAbiFragment>): Array<Fragment> => {\n  const fragments: Array<Fragment> = [];\n\n  value.forEach((v) => {\n    if (v.type === 'function') {\n      fragments.push(FunctionFragment.fromObject(v));\n    }\n  });\n\n  return fragments;\n};\n\nexport default class Interface {\n  readonly fragments: Array<Fragment>;\n  readonly functions: { [name: string]: FunctionFragment };\n  readonly abiCoder: AbiCoder;\n\n  constructor(jsonAbi: JsonAbi) {\n    this.fragments = coerceFragments(jsonAbi);\n    this.abiCoder = new AbiCoder();\n    this.functions = {};\n    this.fragments.forEach((fragment) => {\n      let bucket: { [name: string]: Fragment } = {};\n      switch (fragment.type) {\n        case 'function':\n          bucket = this.functions;\n          break;\n        default:\n          return;\n      }\n      const signature = fragment.format();\n      if (bucket[signature]) {\n        logger.warn(`duplicate definition - ${signature}`);\n        return;\n      }\n      bucket[signature] = fragment;\n    });\n  }\n\n  static getSighash(fragment: FunctionFragment | string): Uint8Array {\n    const bytes =\n      typeof fragment === 'string' ? toUtf8Bytes(fragment) : toUtf8Bytes(fragment.format());\n\n    return concat([new Uint8Array(4), arrayify(sha256(bytes)).slice(0, 4)]);\n  }\n\n  getFunction(nameOrSignatureOrSighash: string): FunctionFragment {\n    if (this.functions[nameOrSignatureOrSighash]) {\n      return this.functions[nameOrSignatureOrSighash];\n    }\n\n    const functionFragment = Object.values(this.functions).find(\n      (fragment: Fragment) =>\n        hexlify(Interface.getSighash(fragment)) === nameOrSignatureOrSighash ||\n        fragment.name === nameOrSignatureOrSighash\n    );\n\n    if (functionFragment) {\n      return functionFragment;\n    }\n\n    return logger.throwArgumentError(\n      `function ${nameOrSignatureOrSighash} not found.`,\n      'data',\n      functionFragment\n    );\n  }\n\n  // Decode the data for a function call (e.g. tx.data)\n  decodeFunctionData(functionFragment: FunctionFragment | string, data: BytesLike): any {\n    const fragment =\n      typeof functionFragment === 'string' ? this.getFunction(functionFragment) : functionFragment;\n\n    const bytes = arrayify(data);\n    if (hexlify(bytes.slice(0, 8)) !== hexlify(Interface.getSighash(fragment))) {\n      logger.throwArgumentError(\n        `data signature does not match function ${fragment.name}.`,\n        'data',\n        hexlify(bytes)\n      );\n    }\n\n    return this.abiCoder.decode(fragment.inputs, bytes.slice(16));\n  }\n\n  encodeFunctionData(\n    functionFragment: FunctionFragment | string,\n    values: Array<InputValue>\n  ): Uint8Array {\n    const fragment =\n      typeof functionFragment === 'string' ? this.getFunction(functionFragment) : functionFragment;\n\n    if (!fragment) {\n      throw new Error('Fragment not found');\n    }\n\n    const selector = Interface.getSighash(fragment);\n    const inputs = filterEmptyParams(fragment.inputs);\n\n    if (inputs.length === 0) {\n      return selector;\n    }\n\n    const isRef = inputs.length > 1 || isReferenceType(inputs[0].type);\n    const args = this.abiCoder.encode(inputs, values);\n    return concat([selector, new BooleanCoder().encode(isRef), args]);\n  }\n\n  // Decode the result of a function call\n  decodeFunctionResult(functionFragment: FunctionFragment | string, data: BytesLike): any {\n    const fragment =\n      typeof functionFragment === 'string' ? this.getFunction(functionFragment) : functionFragment;\n\n    const bytes = arrayify(data);\n\n    return this.abiCoder.decode(fragment.outputs, bytes);\n  }\n\n  encodeFunctionResult(\n    functionFragment: FunctionFragment | string,\n    values: Array<InputValue>\n  ): Uint8Array {\n    const fragment =\n      typeof functionFragment === 'string' ? this.getFunction(functionFragment) : functionFragment;\n\n    if (!fragment) {\n      throw new Error('Fragment not found');\n    }\n\n    return this.abiCoder.encode(fragment.outputs, values);\n  }\n}\n","/**\n * Types for Fuel JSON ABI Format as defined on:\n * https://github.com/FuelLabs/fuel-specs/blob/master/specs/protocol/abi.md#json-abi-format\n */\n\nexport interface JsonAbiFragmentType {\n  readonly type: string;\n  readonly name?: string;\n  // TODO: Remove `null` when forc doesn't output nulls (https://github.com/FuelLabs/sway/issues/926)\n  readonly components?: ReadonlyArray<JsonAbiFragmentType> | null;\n}\n\nexport interface JsonAbiFragment {\n  readonly type:\n    | 'function'\n    // We actually shouldn't accept string here, but when importing a JSON file\n    // TS types string literals as strings so we have to.\n    // TODO: Remove when TS issue is resolved: https://github.com/microsoft/TypeScript/issues/32063\n    | string;\n  readonly name: string;\n  readonly inputs?: ReadonlyArray<JsonAbiFragmentType>;\n  readonly outputs?: ReadonlyArray<JsonAbiFragmentType>;\n}\n\n/**\n * A JSON ABI object\n */\nexport type JsonAbi = ReadonlyArray<JsonAbiFragment>;\n\n/**\n * Checks if a given type is a reference type\n * See: https://github.com/FuelLabs/sway/issues/1368\n */\nexport const isReferenceType = (type: string) => {\n  switch (type) {\n    case 'u8':\n    case 'u16':\n    case 'u32':\n    case 'u64':\n    case 'bool': {\n      return false;\n    }\n    default: {\n      return true;\n    }\n  }\n};\n"],"mappings":"qYACA,gDAEA,GAAM,IAAS,GAAI,IAAO,sBAAgC,EA2B1D,OAA0E,CAKxE,YAAY,EAAc,EAAc,EAAuB,CAC7D,KAAK,KAAO,EACZ,KAAK,KAAO,EACZ,KAAK,cAAgB,CACvB,CAEA,WAAW,EAAiB,EAAuB,CACjD,SAAO,mBAAmB,EAAS,KAAK,KAAM,CAAK,EAG7C,GAAI,OAAM,aAAa,CAC/B,CAKF,ECnDA,+CAQA,mBAA8D,EAG5D,CAIA,YAAY,EAAe,EAAgB,CACzC,MAAM,QAAS,IAAI,EAAM,SAAS,KAAW,EAAS,EAAM,aAAa,EACzE,KAAK,MAAQ,EACb,KAAK,OAAS,CAChB,CAEA,OAAO,EAAyC,CAC9C,MAAK,OAAM,QAAQ,CAAK,GACtB,KAAK,WAAW,uBAAwB,CAAK,EAG3C,KAAK,SAAW,EAAM,QACxB,KAAK,WAAW,+BAAgC,CAAK,EAGhD,GAAO,MAAM,KAAK,CAAK,EAAE,IAAI,AAAC,GAAM,KAAK,MAAM,OAAO,CAAC,CAAC,CAAC,CAClE,CAEA,OAAO,EAAkB,EAAkD,CACzE,GAAI,GAAY,EAShB,MAAO,CARc,MAAM,KAAK,MAAM,EACnC,KAAK,CAAC,EACN,IAAI,IAAM,CACT,GAAI,GACJ,OAAC,EAAS,CAAS,EAAI,KAAK,MAAM,OAAO,EAAM,CAAS,EACjD,CACT,CAAC,EAE6C,CAAS,CAC3D,CACF,EC7CA,+DACA,0CAIA,mBAAuC,EAAsB,CAC3D,aAAc,CACZ,MAAM,OAAQ,OAAQ,EAAE,CAC1B,CAEA,OAAO,EAA2B,CAChC,GAAI,GACJ,GAAI,CACF,EAAe,GAAS,CAAK,CAC/B,MAAE,CACA,KAAK,WAAW,WAAW,KAAK,OAAQ,CAAK,CAC/C,CACA,MAAI,GAAa,SAAW,IAC1B,KAAK,WAAW,WAAW,KAAK,OAAQ,CAAK,EAExC,CACT,CAEA,OAAO,EAAkB,EAAkC,CACzD,GAAI,GAAQ,EAAK,MAAM,EAAQ,EAAS,EAAE,EAE1C,MAAI,IAAS,CAAK,IAAM,IACtB,GAAQ,GAAI,YAAW,EAAE,GAGvB,EAAM,SAAW,IACnB,KAAK,WAAW,wBAAyB,CAAK,EAEzC,CAAC,GAAQ,CAAK,EAAG,EAAS,EAAE,CACrC,CACF,ECnCA,gDACA,wDAIA,mBAA0C,EAAwB,CAChE,aAAc,CACZ,MAAM,UAAW,UAAW,CAAC,CAC/B,CAEA,OAAO,EAA4B,CACjC,GAAI,GAEJ,GAAI,CACF,EAAQ,GAAQ,EAAQ,EAAI,CAAC,CAC/B,MAAE,CACA,KAAK,WAAW,eAAgB,CAAK,CACvC,CACA,MAAI,GAAM,OAAS,GACjB,KAAK,WAAW,eAAgB,CAAK,EAGhC,GAAQ,EAAO,CAAC,CACzB,CAEA,OAAO,EAAkB,EAAmC,CAC1D,GAAM,GAAQ,GAAS,EAAK,MAAM,EAAQ,EAAS,CAAC,CAAC,EACrD,MAAI,KAAU,GACL,CAAC,GAAO,EAAS,CAAC,EAEvB,KAAU,IACZ,KAAK,WAAW,wBAAyB,CAAK,EAEzC,CAAC,GAAM,EAAS,CAAC,EAC1B,CACF,ECnCA,gDACA,wDAIA,mBAAuC,EAAsB,CAC3D,aAAc,CACZ,MAAM,OAAQ,OAAQ,CAAC,CACzB,CAEA,OAAO,EAA2B,CAChC,GAAI,GAEJ,GAAI,CACF,EAAQ,GAAQ,CAAK,CACvB,MAAE,CACA,KAAK,WAAW,eAAgB,CAAK,CACvC,CACA,MAAI,GAAM,OAAS,GACjB,KAAK,WAAW,eAAgB,CAAK,EAGhC,GAAQ,EAAO,CAAC,CACzB,CAEA,OAAO,EAAkB,EAAkC,CACzD,GAAM,GAAQ,EAAK,MAAM,EAAQ,EAAS,CAAC,EACrC,EAAQ,GAAS,CAAK,EAC5B,MAAI,GAAQ,MACV,KAAK,WAAW,eAAgB,CAAK,EAGhC,CADM,OAAO,CAAK,EACX,EAAS,CAAC,CAC1B,CACF,EClCA,+CCAA,gDACA,uEADA,QASA,eAA8F,EAG5F,CAMA,YAAY,EAAqB,CAC/B,MAAM,SAAU,EAAU,CAAC,EAkC7B,UAjCE,YAAK,SAAW,EACR,OACD,KACH,KAAK,OAAS,EACd,UACG,MACH,KAAK,OAAS,EACd,UACG,MACH,KAAK,OAAS,EACd,UACG,cAEH,KAAK,OAAS,EACd,MAEN,CAEA,OAAO,EAAoC,CACzC,GAAI,GAEJ,GAAI,CACF,EAAQ,GAAQ,CAAK,CACvB,MAAE,CACA,KAAK,WAAW,WAAW,KAAK,WAAY,CAAK,CACnD,CACA,MAAI,GAAM,OAAS,KAAK,QACtB,KAAK,WAAW,WAAW,KAAK,WAAY,CAAK,EAG5C,GAAQ,EAAO,CAAC,CACzB,CASA,OAAO,EAAkB,EAAoD,CAC3E,GAAM,CAAC,EAAK,GAAc,OAAK,KAAL,UAAmB,EAAM,GACnD,MAAI,MAAK,WAAa,MACb,CAAC,EAAiC,CAAU,EAE9C,CAAC,GAAS,CAAG,EAA+B,CAAU,CAC/D,CACF,EAdE,gBAAa,SAAC,EAAkB,EAAkC,CAChE,GAAI,GAAQ,EAAK,MAAM,EAAQ,EAAS,CAAC,EACzC,SAAQ,EAAM,MAAM,EAAI,KAAK,OAAQ,CAAC,EAE/B,CADK,GAAS,CAAK,EACb,EAAS,CAAC,CACzB,ED1DF,QAcA,eAA8E,EAG5E,CAMA,YAAY,EAAc,EAAiB,CACzC,GAAM,GAAiB,GAAI,GAAY,KAAK,EACtC,EAAmB,OAAO,OAAO,CAAM,EAAE,OAC7C,CAAC,EAAK,IAAU,KAAK,IAAI,EAAK,EAAM,aAAa,EACjD,CACF,EACA,MAAM,OAAQ,QAAQ,IAAQ,EAAe,cAAgB,CAAgB,EAT/E,iBACA,iBASE,KAAK,KAAO,EACZ,KAAK,OAAS,EACd,OAAK,EAAkB,GACvB,OAAK,EAAoB,EAC3B,CAEA,OAAO,EAA0C,CAC/C,GAAM,CAAC,KAAY,GAAS,OAAO,KAAK,CAAK,EAC7C,GAAI,CAAC,EACH,KAAM,IAAI,OAAM,uCAAuC,EAEzD,GAAI,EAAM,SAAW,EACnB,KAAM,IAAI,OAAM,iCAAiC,EAEnD,GAAM,GAAa,KAAK,OAAO,GACzB,EAAY,OAAO,KAAK,KAAK,MAAM,EAAE,QAAQ,CAAO,EACpD,EAAe,EAAW,OAAO,EAAM,EAAQ,EAC/C,EAAU,GAAI,YAAW,OAAK,GAAoB,EAAW,aAAa,EAChF,MAAO,IAAO,CAAC,OAAK,GAAgB,OAAO,CAAS,EAAG,EAAS,CAAY,CAAC,CAC/E,CAEA,OAAO,EAAkB,EAAmD,CAC1E,GAAI,GAAY,EAEZ,EACJ,CAAC,EAAS,CAAS,EAAI,GAAI,GAAY,KAAK,EAAE,OAAO,EAAM,CAAS,EACpE,GAAM,GAAY,EACZ,EAAU,OAAO,KAAK,KAAK,MAAM,EAAE,OAAO,CAAS,GACzD,GAAI,CAAC,EACH,KAAM,IAAI,OAAM,sBAAsB,oBAA4B,OAAO,KAAK,KAAK,MAAM,GAAG,EAE9F,GAAM,GAAa,KAAK,OAAO,GAE/B,UADgB,OAAK,GAAoB,EAAW,cAEpD,CAAC,EAAS,CAAS,EAAI,EAAW,OAAO,EAAM,CAAS,EAEjD,CAAC,EAAG,GAAU,CAAQ,EAA8B,CAAS,CACtE,CACF,EAhDE,cACA,cErBF,+CACA,yEADA,MAKA,eAA0E,EAAsB,CAI9F,YAAY,EAAiB,CAC3B,GAAI,GAAiB,GAAI,GAAU,EACnC,EAAgB,EAAgB,EAAI,EAAgB,EAAI,EACxD,MAAM,SAAU,OAAO,KAAW,EAAS,CAAa,EAL1D,iBAME,KAAK,OAAS,EACd,OAAK,EAAiB,EACxB,CAEA,OAAO,EAA2B,CAChC,GAAM,GAAU,GAAY,EAAM,MAAM,EAAG,KAAK,MAAM,CAAC,EACjD,EAAU,GAAI,YAAW,OAAK,EAAc,EAClD,MAAO,IAAO,CAAC,EAAS,CAAO,CAAC,CAClC,CAEA,OAAO,EAAkB,EAAkC,CACzD,GAAM,GAAQ,EAAK,MAAM,EAAQ,EAAS,KAAK,MAAM,EAC/C,EAAQ,GAAa,CAAK,EAE1B,EAAU,OAAK,GACrB,MAAO,CAAC,EAAO,EAAS,KAAK,OAAS,CAAO,CAC/C,CACF,EAvBE,cCNF,+CAYA,mBAAgF,EAG9E,CAIA,YAAY,EAAc,EAAiB,CACzC,GAAM,GAAgB,OAAO,OAAO,CAAM,EAAE,OAC1C,CAAC,EAAK,IAAU,EAAM,EAAM,cAC5B,CACF,EACA,MAAM,SAAU,UAAU,IAAQ,CAAa,EAC/C,KAAK,KAAO,EACZ,KAAK,OAAS,CAChB,CAEA,OAAO,EAAmC,CACxC,GAAM,GAAgB,OAAO,KAAK,KAAK,MAAM,EAAE,IAAI,AAAC,GAAc,CAChE,GAAM,GAAa,KAAK,OAAO,GACzB,EAAa,EAAM,GAEzB,MADgB,GAAW,OAAO,CAAU,CAE9C,CAAC,EACD,MAAO,IAAO,CAAa,CAC7B,CAEA,OAAO,EAAkB,EAAmD,CAC1E,GAAI,GAAY,EAUhB,MAAO,CATc,OAAO,KAAK,KAAK,MAAM,EAAE,OAAO,CAAC,EAAK,IAAc,CACvE,GAAM,GAAa,KAAK,OAAO,GAC3B,EACJ,OAAC,EAAS,CAAS,EAAI,EAAW,OAAO,EAAM,CAAS,EAExD,EAAI,GAA8C,EAC3C,CACT,EAAG,CAAC,CAA4B,EAEV,CAAS,CACjC,CACF,ECrDA,+CAYA,mBAAiE,EAG/D,CAGA,YAAY,EAAiB,CAC3B,GAAM,GAAgB,EAAO,OAAO,CAAC,EAAK,IAAU,EAAM,EAAM,cAAe,CAAC,EAChF,MAAM,QAAS,IAAI,EAAO,IAAI,AAAC,GAAU,EAAM,IAAI,EAAE,KAAK,IAAI,KAAM,CAAa,EACjF,KAAK,OAAS,CAChB,CAEA,OAAO,EAA0C,CAC/C,MAAI,MAAK,OAAO,SAAW,EAAM,QAC/B,KAAK,WAAW,+BAAgC,CAAE,OAAM,CAAC,EAGpD,GAAO,KAAK,OAAO,IAAI,CAAC,EAAO,IAAM,EAAM,OAAO,EAAM,EAAE,CAAC,CAAC,CACrE,CAEA,OAAO,EAAkB,EAAmD,CAC1E,GAAI,GAAY,EAOhB,MAAO,CANc,KAAK,OAAO,IAAI,AAAC,GAAU,CAC9C,GAAI,GACJ,OAAC,EAAS,CAAS,EAAI,EAAM,OAAO,EAAM,CAAS,EAC5C,CACT,CAAC,EAEgD,CAAS,CAC5D,CACF,ECvCO,WAA2B,EAA0C,CAC1E,MAAO,GAAM,OAAO,AAAC,GAAO,kBAA2B,QAAS,MAAQ,IAAM,IAAI,CACpF,CCIO,WAAwB,CAM7B,YAAY,EAAwB,CAH3B,YAA2B,CAAC,EAC5B,aAA4B,CAAC,EAGpC,KAAK,KAAO,EAAO,KACnB,KAAK,KAAO,EAAO,KACnB,KAAK,OAAS,EAAO,OACrB,KAAK,QAAU,EAAO,OACxB,CAGF,ECtBA,iECCA,iDACA,+CAgBO,GAAM,IAAc,2BACd,EAAa,4CACb,EAAc,wBACd,GAAY,sBACZ,GAAa,qBAEpB,EAAS,GAAI,GAAO,sBAAgC,EAE1D,OAA8B,CAC5B,aAAc,CACZ,EAAO,SAAS,WAAY,CAAQ,CACtC,CAEA,SAAS,EAAmC,CAhC9C,gBAiCI,OAAQ,EAAM,UACP,SACA,UACA,UACA,MACH,MAAO,IAAI,GAAY,EAAM,IAAI,MAC9B,OACH,MAAO,IAAI,OACR,OACH,MAAO,IAAI,OACR,OACH,MAAO,IAAI,YAIf,GAAM,GAAc,MAAY,KAAK,EAAM,IAAI,IAA3B,cAA8B,OAClD,GAAI,EAAa,CACf,GAAM,GAAS,SAAS,EAAY,OAAQ,EAAE,EAE9C,MAAO,IAAI,GAAY,CAAM,CAC/B,CAEA,GAAM,GAAa,KAAW,KAAK,EAAM,IAAI,IAA1B,cAA6B,OAChD,GAAI,EAAY,CACd,GAAM,GAAS,SAAS,EAAW,OAAQ,EAAE,EACvC,EAAgB,KAAM,aAAN,cAAmB,GACzC,GAAI,CAAC,EACH,KAAM,IAAI,OAAM,+CAA+C,EAEjE,GAAM,GAAY,KAAK,SAAS,CAAa,EAC7C,MAAO,IAAI,GAAW,EAAW,CAAM,CACzC,CAEA,GAAM,GAAc,KAAY,KAAK,EAAM,IAAI,IAA3B,cAA8B,OAClD,GAAI,GAAe,MAAM,QAAQ,EAAM,UAAU,EAAG,CAClD,GAAM,GAAS,EAAM,WAAW,OAAO,CAAC,EAAK,IAE3C,GAAI,EAAU,MAAQ,KAAK,SAAS,CAAS,EACtC,GACN,CAAC,CAAC,EACL,MAAO,IAAI,GAAY,EAAY,KAAM,CAAM,CACjD,CAEA,GAAM,GAAY,MAAU,KAAK,EAAM,IAAI,IAAzB,cAA4B,OAC9C,GAAI,GAAa,MAAM,QAAQ,EAAM,UAAU,EAAG,CAChD,GAAM,GAAS,EAAM,WAAW,OAAO,CAAC,EAAK,IAE3C,GAAI,EAAU,MAAQ,KAAK,SAAS,CAAS,EACtC,GACN,CAAC,CAAC,EACL,MAAO,IAAI,GAAU,EAAU,KAAM,CAAM,CAC7C,CAGA,GAAI,AADe,OAAW,KAAK,EAAM,IAAI,IAA1B,cAA6B,SAC9B,MAAM,QAAQ,EAAM,UAAU,EAAG,CACjD,GAAM,GAAS,EAAM,WAAW,IAAI,AAAC,GAAc,KAAK,SAAS,CAAS,CAAC,EAC3E,MAAO,IAAI,GAAW,CAAM,CAC9B,CAEA,MAAO,GAAO,mBAAmB,eAAgB,OAAQ,EAAM,IAAI,CACrE,CAEA,OAAO,EAA2C,EAAkC,CAClF,GAAM,GAAgB,EAAkB,CAAK,EAE7C,AAAI,MAAM,QAAQ,CAAM,GAAK,EAAc,SAAW,EAAO,QAC3D,EAAO,WAAW,+BAAgC,EAAO,OAAO,iBAAkB,CAChF,MAAO,CAAE,MAAO,EAAc,OAAQ,OAAQ,EAAO,MAAO,EAC5D,MAAO,CAAE,QAAO,QAAO,CACzB,CAAC,EAGH,GAAM,GAAS,EAAc,IAAI,AAAC,GAAS,KAAK,SAAS,CAAI,CAAC,EAE9D,MAAO,AADO,IAAI,GAAW,CAAM,EACtB,OAAO,CAAM,CAC5B,CAEA,OAAO,EAA2C,EAA6C,CAC7F,GAAM,GAAQ,GAAS,CAAI,EACrB,EAAgB,EAAkB,CAAK,EACvC,EAAoB,AAAC,GAAsB,CAC/C,AAAI,IAAc,EAAM,QACtB,EAAO,WAAW,+BAAgC,EAAO,OAAO,iBAAkB,CAChF,MAAO,CAAE,MAAO,EAAc,OAAQ,OAAQ,EAAM,MAAO,EAC3D,MAAO,CAAE,MAAO,EAAe,OAAM,CACvC,CAAC,CAEL,EAEA,GAAI,EAAM,SAAW,GAAK,EAAc,SAAW,EAAG,CAEpD,EAAkB,EAAM,OAAS,EAAI,CAAC,EACtC,MACF,CAEA,GAAM,GAAS,EAAc,IAAI,AAAC,GAAS,KAAK,SAAS,CAAI,CAAC,EACxD,EAAQ,GAAI,GAAW,CAAM,EAC7B,CAAC,EAAS,GAAa,EAAM,OAAO,EAAO,CAAC,EAElD,SAAkB,CAAS,EAEpB,CACT,CACF,ED7HA,YAAyC,EAAyB,CAXlE,QAYE,GAAI,CAAC,GAAU,IAAW,GAAY,QAAS,CAE7C,GADoB,KAAY,KAAK,KAAK,IAAI,IAA1B,cAA6B,OAE/C,MAAO,IAAI,KAAK,OAAO,CAAM,IAG/B,GAAM,GAAa,KAAW,KAAK,KAAK,IAAI,IAAzB,cAA4B,OAC/C,GAAI,EACF,MAAO,IAAI,EAAW,SAAS,EAAW,SAE9C,CAEA,MAAO,MAAK,OAAO,CAAM,CAC3B,CAEA,mBAA8C,EAAS,OAC9C,YAAW,EAA0C,CAC1D,GAAM,CAAE,SAAS,CAAC,EAAG,UAAU,CAAC,GAAM,EAEhC,EAAS,CACb,KAAM,WACN,KAAM,EAAM,KAEZ,OAAS,EAAe,IAAI,EAAU,UAAU,EAChD,QAAU,EAAgB,IAAI,EAAU,UAAU,CACpD,EAEA,MAAO,IAAI,GAAiB,CAAM,CACpC,CAEA,QAAiB,CACf,GAAM,GAAc,KAAK,OAAO,IAAI,AAAC,GAAU,GAAe,KAAK,CAAK,CAAC,EACzE,MAAO,GAAG,KAAK,QAAQ,EAAY,KAAK,GAAG,IAC7C,CACF,EE5CA,yEACA,gDACA,8CACA,qDC4BO,GAAM,GAAkB,AAAC,GAAiB,CAC/C,OAAQ,OACD,SACA,UACA,UACA,UACA,OACH,MAAO,WAGP,MAAO,GAGb,ED9BA,GAAM,GAAS,GAAI,IAAO,sBAAgC,EAEpD,GAAkB,AAAC,GAA2D,CAClF,GAAM,GAA6B,CAAC,EAEpC,SAAM,QAAQ,AAAC,GAAM,CACnB,AAAI,EAAE,OAAS,YACb,EAAU,KAAK,EAAiB,WAAW,CAAC,CAAC,CAEjD,CAAC,EAEM,CACT,EAEA,OAA+B,CAK7B,YAAY,EAAkB,CAC5B,KAAK,UAAY,GAAgB,CAAO,EACxC,KAAK,SAAW,GAAI,GACpB,KAAK,UAAY,CAAC,EAClB,KAAK,UAAU,QAAQ,AAAC,GAAa,CACnC,GAAI,GAAuC,CAAC,EAC5C,OAAQ,EAAS,UACV,WACH,EAAS,KAAK,UACd,cAEA,OAEJ,GAAM,GAAY,EAAS,OAAO,EAClC,GAAI,EAAO,GAAY,CACrB,EAAO,KAAK,0BAA0B,GAAW,EACjD,MACF,CACA,EAAO,GAAa,CACtB,CAAC,CACH,OAEO,YAAW,EAAiD,CACjE,GAAM,GACJ,MAAO,IAAa,SAAW,EAAY,CAAQ,EAAI,EAAY,EAAS,OAAO,CAAC,EAEtF,MAAO,GAAO,CAAC,GAAI,YAAW,CAAC,EAAG,EAAS,GAAO,CAAK,CAAC,EAAE,MAAM,EAAG,CAAC,CAAC,CAAC,CACxE,CAEA,YAAY,EAAoD,CAC9D,GAAI,KAAK,UAAU,GACjB,MAAO,MAAK,UAAU,GAGxB,GAAM,GAAmB,OAAO,OAAO,KAAK,SAAS,EAAE,KACrD,AAAC,GACC,EAAQ,EAAU,WAAW,CAAQ,CAAC,IAAM,GAC5C,EAAS,OAAS,CACtB,EAEA,MAAI,IAIG,EAAO,mBACZ,YAAY,eACZ,OACA,CACF,CACF,CAGA,mBAAmB,EAA6C,EAAsB,CACpF,GAAM,GACJ,MAAO,IAAqB,SAAW,KAAK,YAAY,CAAgB,EAAI,EAExE,EAAQ,EAAS,CAAI,EAC3B,MAAI,GAAQ,EAAM,MAAM,EAAG,CAAC,CAAC,IAAM,EAAQ,EAAU,WAAW,CAAQ,CAAC,GACvE,EAAO,mBACL,0CAA0C,EAAS,QACnD,OACA,EAAQ,CAAK,CACf,EAGK,KAAK,SAAS,OAAO,EAAS,OAAQ,EAAM,MAAM,EAAE,CAAC,CAC9D,CAEA,mBACE,EACA,EACY,CACZ,GAAM,GACJ,MAAO,IAAqB,SAAW,KAAK,YAAY,CAAgB,EAAI,EAE9E,GAAI,CAAC,EACH,KAAM,IAAI,OAAM,oBAAoB,EAGtC,GAAM,GAAW,EAAU,WAAW,CAAQ,EACxC,EAAS,EAAkB,EAAS,MAAM,EAEhD,GAAI,EAAO,SAAW,EACpB,MAAO,GAGT,GAAM,GAAQ,EAAO,OAAS,GAAK,EAAgB,EAAO,GAAG,IAAI,EAC3D,EAAO,KAAK,SAAS,OAAO,EAAQ,CAAM,EAChD,MAAO,GAAO,CAAC,EAAU,GAAI,GAAa,EAAE,OAAO,CAAK,EAAG,CAAI,CAAC,CAClE,CAGA,qBAAqB,EAA6C,EAAsB,CACtF,GAAM,GACJ,MAAO,IAAqB,SAAW,KAAK,YAAY,CAAgB,EAAI,EAExE,EAAQ,EAAS,CAAI,EAE3B,MAAO,MAAK,SAAS,OAAO,EAAS,QAAS,CAAK,CACrD,CAEA,qBACE,EACA,EACY,CACZ,GAAM,GACJ,MAAO,IAAqB,SAAW,KAAK,YAAY,CAAgB,EAAI,EAE9E,GAAI,CAAC,EACH,KAAM,IAAI,OAAM,oBAAoB,EAGtC,MAAO,MAAK,SAAS,OAAO,EAAS,QAAS,CAAM,CACtD,CACF","names":[]}