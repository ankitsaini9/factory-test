{"version":3,"sources":["../src/aes-ctr.ts","../src/universal-crypto.ts","../src/randomBytes.ts","../src/aes-ctr-node.ts","../src/aes-ctr-web.ts","../src/keystore.ts"],"sourcesContent":["import { arrayify } from '@ethersproject/bytes';\nimport { pbkdf2 } from '@ethersproject/pbkdf2';\n\nimport { strategy } from './universal-crypto';\n\nexport interface Keystore {\n  data: string;\n  iv: string;\n  salt: string;\n}\n\nexport function bufferFromString(\n  string: string,\n  encoding: 'utf-8' | 'base64' = 'base64'\n): Uint8Array {\n  if (strategy === 'Node') {\n    return Buffer.from(string, encoding);\n  }\n  if (encoding === 'utf-8') {\n    return new TextEncoder().encode(string);\n  }\n\n  return new Uint8Array(\n    atob(string)\n      .split('')\n      .map((c) => c.charCodeAt(0))\n  );\n}\n\nexport function stringFromBuffer(\n  buffer: Uint8Array,\n  encoding: 'utf-8' | 'base64' = 'base64'\n): string {\n  if (strategy === 'Node') {\n    return Buffer.from(buffer).toString(encoding);\n  }\n\n  return btoa(String.fromCharCode.apply(null, new Uint8Array(buffer) as unknown as number[]));\n}\n\n/**\n * Generate a pbkdf2 key from a password and random salt\n */\nexport function keyFromPassword(password: string, saltBuffer: Uint8Array): Uint8Array {\n  const passBuffer = bufferFromString(String(password).normalize('NFKC'), 'utf-8');\n  const key = pbkdf2(passBuffer, saltBuffer, 100000, 32, 'sha256');\n\n  return arrayify(key);\n}\n","import type { createCipheriv, createDecipheriv } from 'crypto';\n\ntype UniversalCrypto = {\n  getRandomValues: (length: number) => Uint8Array;\n  randomBytes: (length: number) => Uint8Array;\n  subtle: SubtleCrypto;\n  createCipheriv: typeof createCipheriv;\n  createDecipheriv: typeof createDecipheriv;\n};\nlet selectedCrypto;\nlet selectedStrategy: 'Node' | 'Web' = 'Node';\n\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nif (typeof globalThis !== 'undefined' && globalThis.crypto) {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  selectedCrypto = globalThis.crypto;\n  selectedStrategy = 'Web';\n}\n\nif (!selectedCrypto && typeof require === 'function') {\n  try {\n    // eslint-disable-next-line global-require\n    selectedCrypto = require('crypto');\n    selectedStrategy = 'Node';\n  } catch (error) {\n    // eslint-disable-next-line no-console\n    console.error('keystore expects a standard Web browser or Node environment.', error);\n  }\n}\n\nexport const crypto: UniversalCrypto = selectedCrypto;\nexport const strategy = selectedStrategy;\n","import { crypto, strategy } from './universal-crypto';\n\nexport const randomBytes = (length: number) =>\n  strategy === 'Node'\n    ? crypto.randomBytes(length)\n    : crypto.getRandomValues(new Uint8Array(length) as unknown as number);\n","import type { Keystore } from './aes-ctr';\nimport { bufferFromString, stringFromBuffer, keyFromPassword } from './aes-ctr';\nimport { randomBytes } from './randomBytes';\nimport { crypto } from './universal-crypto';\n\nconst ALGORITHM = 'aes-256-ctr';\n\n/**\n * Encrypts a data object that can be any serializable value using\n * a provided password.\n *\n * @returns Promise<Keystore> object\n */\nexport async function encrypt<T>(password: string, data: T): Promise<Keystore> {\n  const iv = randomBytes(16);\n  const salt = randomBytes(32);\n  const secret = keyFromPassword(password, salt);\n  const dataBuffer = Uint8Array.from(Buffer.from(JSON.stringify(data), 'utf-8'));\n\n  const cipher = crypto.createCipheriv(ALGORITHM, secret, iv);\n  let cipherData = cipher.update(dataBuffer);\n  cipherData = Buffer.concat([cipherData, cipher.final()]);\n\n  return {\n    data: stringFromBuffer(cipherData),\n    iv: stringFromBuffer(iv),\n    salt: stringFromBuffer(salt),\n  };\n}\n\n/**\n * Given a password and a keystore object, decrypts the text and returns\n * the resulting value\n */\nexport async function decrypt<T>(password: string, keystore: Keystore): Promise<T> {\n  const iv = bufferFromString(keystore.iv);\n  const salt = bufferFromString(keystore.salt);\n  const secret = keyFromPassword(password, salt);\n  const encryptedText = bufferFromString(keystore.data);\n\n  const decipher = crypto.createDecipheriv(ALGORITHM, secret, iv);\n  const decrypted = decipher.update(encryptedText);\n  const deBuff = Buffer.concat([decrypted, decipher.final()]);\n  const decryptedData = Buffer.from(deBuff).toString('utf-8');\n\n  try {\n    return JSON.parse(decryptedData);\n  } catch {\n    throw new Error('Invalid credentials');\n  }\n}\n","import type { Keystore } from './aes-ctr';\nimport { bufferFromString, stringFromBuffer, keyFromPassword } from './aes-ctr';\nimport { randomBytes } from './randomBytes';\nimport { crypto } from './universal-crypto';\n\nconst ALGORITHM = 'AES-CTR';\n\n/**\n * Encrypts a data object that can be any serializable value using\n * a provided password.\n *\n * @returns Promise<Keystore> object\n */\nexport async function encrypt<T>(password: string, data: T): Promise<Keystore> {\n  const iv = randomBytes(16);\n  const salt = randomBytes(32);\n  const secret = keyFromPassword(password, salt);\n  const dataBuffer = Uint8Array.from(Buffer.from(JSON.stringify(data), 'utf-8'));\n  const alg = {\n    name: ALGORITHM,\n    counter: iv,\n    length: 64,\n  };\n  const key = await crypto.subtle.importKey('raw', secret, alg, false, ['encrypt']);\n  const encBuffer = await crypto.subtle.encrypt(alg, key, dataBuffer);\n\n  return {\n    data: stringFromBuffer(encBuffer),\n    iv: stringFromBuffer(iv),\n    salt: stringFromBuffer(salt),\n  };\n}\n\n/**\n * Given a password and a keystore object, decrypts the text and returns\n * the resulting value\n */\nexport async function decrypt<T>(password: string, keystore: Keystore): Promise<T> {\n  const iv = bufferFromString(keystore.iv);\n  const salt = bufferFromString(keystore.salt);\n  const secret = keyFromPassword(password, salt);\n  const encryptedText = bufferFromString(keystore.data);\n\n  const alg = {\n    name: ALGORITHM,\n    counter: iv,\n    length: 64,\n  };\n  const key = await crypto.subtle.importKey('raw', secret, alg, false, ['decrypt']);\n\n  const ptBuffer = await crypto.subtle.decrypt(alg, key, encryptedText);\n  const decryptedData = new TextDecoder().decode(ptBuffer);\n\n  try {\n    return JSON.parse(decryptedData);\n  } catch {\n    throw new Error('Invalid credentials');\n  }\n}\n","import type { Keystore } from './aes-ctr';\nimport { encrypt as encNode, decrypt as decNode } from './aes-ctr-node';\nimport { encrypt as encWeb, decrypt as decWeb } from './aes-ctr-web';\nimport { strategy } from './universal-crypto';\n\nexport type { Keystore } from './aes-ctr';\nexport { keyFromPassword } from './aes-ctr';\nexport { randomBytes } from './randomBytes';\n\n/**\n * Encrypts a data object that can be any serializable value using\n * a provided password.\n *\n * @returns Promise<Keystore> Keystore object\n */\nexport async function encrypt<T>(password: string, data: T): Promise<Keystore> {\n  return strategy === 'Node' ? encNode<T>(password, data) : encWeb<T>(password, data);\n}\n\n/**\n * Given a password and a keystore object, decrypts the text and returns\n * the resulting value\n *\n *  @returns Promise<T> T object\n */\nexport async function decrypt<T>(password: string, keystore: Keystore): Promise<T> {\n  return strategy === 'Node' ? decNode<T>(password, keystore) : decWeb<T>(password, keystore);\n}\n"],"mappings":"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","names":[]}