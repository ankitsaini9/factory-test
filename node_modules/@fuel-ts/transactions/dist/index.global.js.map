{"version":3,"sources":["../../../node_modules/.pnpm/@ethersproject+logger@5.6.0/node_modules/@ethersproject/logger/src.ts/_version.ts","../../../node_modules/.pnpm/@ethersproject+logger@5.6.0/node_modules/@ethersproject/logger/src.ts/index.ts","../../../node_modules/.pnpm/@ethersproject+bytes@5.6.1/node_modules/@ethersproject/bytes/src.ts/_version.ts","../../../node_modules/.pnpm/@ethersproject+bytes@5.6.1/node_modules/@ethersproject/bytes/src.ts/index.ts","../../abi-coder/src/coders/abstract-coder.ts","../../abi-coder/src/coders/array.ts","../../math/src/convert.ts","../../abi-coder/src/coders/b256.ts","../../abi-coder/src/coders/number.ts","../../abi-coder/src/coders/enum.ts","../../../node_modules/.pnpm/@ethersproject+strings@5.6.0/node_modules/@ethersproject/strings/src.ts/_version.ts","../../../node_modules/.pnpm/@ethersproject+strings@5.6.0/node_modules/@ethersproject/strings/src.ts/utf8.ts","../../abi-coder/src/coders/string.ts","../../abi-coder/src/coders/struct.ts","../../abi-coder/src/abi-coder.ts","../../abi-coder/src/interface.ts","../src/coders/byte-array.ts","../src/coders/utxo-id.ts","../src/coders/input.ts","../src/coders/output.ts","../src/coders/receipt.ts","../src/coders/storage-slot.ts","../src/coders/witness.ts","../src/coders/transaction.ts","../src/consts.ts"],"sourcesContent":[null,null,null,null,"import type { BytesLike } from '@ethersproject/bytes';\nimport { Logger } from '@ethersproject/logger';\n\nconst logger = new Logger(process.env.BUILD_VERSION || '~');\n\ntype Primitive = string | number | boolean | bigint;\n\n/**\n * The type of value you can provide to `Coder.encode`\n */\nexport type InputValue =\n  | Primitive\n  | BytesLike\n  | InputValue[]\n  | { [key: string]: InputValue }\n  | Record<string, Primitive | BytesLike>;\n\n/**\n * The type of value you can get from `Coder.decode`\n */\nexport type DecodedValue =\n  | Primitive\n  | DecodedValue[]\n  | { [key: string]: DecodedValue }\n  | Record<string, Primitive>;\n\nexport type TypesOfCoder<TCoder> = TCoder extends Coder<infer TInput, infer TDecoded>\n  ? { Input: TInput; Decoded: TDecoded }\n  : never;\n\nexport default abstract class Coder<TInput = unknown, TDecoded = unknown> {\n  readonly name: string;\n  readonly type: string;\n  readonly encodedLength: number;\n\n  constructor(name: string, type: string, encodedLength: number) {\n    this.name = name;\n    this.type = type;\n    this.encodedLength = encodedLength;\n  }\n\n  throwError(message: string, value: unknown): never {\n    logger.throwArgumentError(message, this.name, value);\n    // `logger.throwArgumentError` throws, but TS doesn't know it\n    // so we throw here to make sure our `never` works\n    throw new Error('unreachable');\n  }\n\n  abstract encode(value: TInput, length?: number): Uint8Array;\n\n  abstract decode(data: Uint8Array, offset: number, length?: number): [TDecoded, number];\n}\n","import { concat } from '@ethersproject/bytes';\n\nimport type { TypesOfCoder } from './abstract-coder';\nimport Coder from './abstract-coder';\n\ntype InputValueOf<TCoder extends Coder> = Array<TypesOfCoder<TCoder>['Input']>;\ntype DecodedValueOf<TCoder extends Coder> = Array<TypesOfCoder<TCoder>['Decoded']>;\n\nexport default class ArrayCoder<TCoder extends Coder> extends Coder<\n  InputValueOf<TCoder>,\n  DecodedValueOf<TCoder>\n> {\n  coder: TCoder;\n  length: number;\n\n  constructor(coder: TCoder, length: number) {\n    super('array', `[${coder.type}; ${length}]`, length * coder.encodedLength);\n    this.coder = coder;\n    this.length = length;\n  }\n\n  encode(value: InputValueOf<TCoder>): Uint8Array {\n    if (!Array.isArray(value)) {\n      this.throwError('expected array value', value);\n    }\n\n    if (this.length !== value.length) {\n      this.throwError('Types/values length mismatch', value);\n    }\n\n    return concat(Array.from(value).map((v) => this.coder.encode(v)));\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoder>, number] {\n    let newOffset = offset;\n    const decodedValue = Array(this.length)\n      .fill(0)\n      .map(() => {\n        let decoded;\n        [decoded, newOffset] = this.coder.decode(data, newOffset);\n        return decoded;\n      });\n\n    return [decodedValue as DecodedValueOf<TCoder>, newOffset];\n  }\n}\n","/* eslint-disable no-restricted-syntax */\n/**\n * From: https://github.dev/ethers-io/ethers.js/blob/9ca3dc557de8d1556096ea4140316e7f7711a0f3/packages/math/src.ts/convert.ts\n */\n\nimport type { BigNumberish } from './types';\n\n// IEEE 754 support 53-bits of mantissa\nconst maxValue = 0x1fffffffffffff;\n\nconst nibbles = '0123456789abcdef';\n\n// Converts a value to a BigInt, including big endian data\nexport function toBigInt(_value: BigNumberish | Uint8Array): bigint {\n  if (_value instanceof Uint8Array) {\n    let result = '0x0';\n    for (const v of _value) {\n      result += nibbles[v >> 4];\n      result += nibbles[v & 0x0f];\n    }\n    return BigInt(result);\n  }\n  return BigInt(_value);\n}\n\nexport function toNumber(_value: BigNumberish | Uint8Array): number {\n  const value = toBigInt(_value);\n  if (value < -maxValue || value > maxValue) {\n    throw new Error(`Value out of range: ${_value}`);\n  }\n  return Number(value);\n}\n\n// Converts value to hex, optionally padding on the left to width bytes\nexport function toHex(_value: BigNumberish, width?: number): string {\n  const value = BigInt(_value);\n  if (value < 0) {\n    throw new Error('cannot convert negative value to hex');\n  }\n\n  let result = value.toString(16);\n\n  if (width == null) {\n    // Ensure the value is of even length\n    if (result.length % 2) {\n      result = `0${result}`;\n    }\n  } else {\n    if (width * 2 < result.length) {\n      throw new Error(`value ${value} exceeds width ${width}`);\n    }\n\n    // Pad the value to the required width\n    while (result.length < width * 2) {\n      result = `0${result}`;\n    }\n  }\n\n  return `0x${result}`;\n}\n\nexport function toArray(_value: BigNumberish): Uint8Array {\n  const value = BigInt(_value);\n  if (value < 0) {\n    throw new Error('cannot convert negative value to hex');\n  }\n\n  if (value === 0n) {\n    return new Uint8Array([]);\n  }\n\n  let hex = value.toString(16);\n  if (hex.length % 2) {\n    hex = `0${hex}`;\n  }\n\n  const result = new Uint8Array(hex.length / 2);\n  for (let i = 0; i < result.length; i += 1) {\n    const offset = i * 2;\n    result[i] = parseInt(hex.substring(offset, offset + 2), 16);\n  }\n\n  return result;\n}\n","import { hexlify, arrayify } from '@ethersproject/bytes';\nimport { toBigInt } from '@fuel-ts/math';\n\nimport Coder from './abstract-coder';\n\nexport default class B256Coder extends Coder<string, string> {\n  constructor() {\n    super('b256', 'b256', 32);\n  }\n\n  encode(value: string): Uint8Array {\n    let encodedValue;\n    try {\n      encodedValue = arrayify(value);\n    } catch (error) {\n      this.throwError(`Invalid ${this.type}`, value);\n    }\n    if (encodedValue.length !== 32) {\n      this.throwError(`Invalid ${this.type}`, value);\n    }\n    return encodedValue;\n  }\n\n  decode(data: Uint8Array, offset: number): [string, number] {\n    let bytes = data.slice(offset, offset + 32);\n\n    if (toBigInt(bytes) === 0n) {\n      bytes = new Uint8Array(32);\n    }\n\n    if (bytes.length !== 32) {\n      this.throwError('Invalid size for b256', bytes);\n    }\n    return [hexlify(bytes), offset + 32];\n  }\n}\n","import { zeroPad } from '@ethersproject/bytes';\nimport { toArray, toBigInt, toNumber } from '@fuel-ts/math';\n\nimport Coder from './abstract-coder';\n\ntype NumberCoderType = 'u8' | 'u16' | 'u32' | 'u64';\n\ntype ToDecodedType<TBaseType extends NumberCoderType> = TBaseType extends 'u64' ? bigint : number;\n\nexport default class NumberCoder<TBaseType extends NumberCoderType = NumberCoderType> extends Coder<\n  number | bigint,\n  ToDecodedType<TBaseType>\n> {\n  // This is to align the bits to the total bytes\n  // See https://github.com/FuelLabs/fuel-specs/blob/master/specs/protocol/abi.md#unsigned-integers\n  length: number;\n  baseType: TBaseType;\n\n  constructor(baseType: TBaseType) {\n    super('number', baseType, 8);\n    this.baseType = baseType;\n    switch (baseType) {\n      case 'u8':\n        this.length = 1;\n        break;\n      case 'u16':\n        this.length = 2;\n        break;\n      case 'u32':\n        this.length = 4;\n        break;\n      case 'u64':\n      default:\n        this.length = 8;\n        break;\n    }\n  }\n\n  encode(value: number | bigint): Uint8Array {\n    let bytes;\n\n    try {\n      bytes = toArray(value);\n    } catch (error) {\n      this.throwError(`Invalid ${this.baseType}`, value);\n    }\n    if (bytes.length > this.length) {\n      this.throwError(`Invalid ${this.baseType}`, value);\n    }\n\n    return zeroPad(bytes, 8);\n  }\n\n  #decodeBigInt(data: Uint8Array, offset: number): [bigint, number] {\n    let bytes = data.slice(offset, offset + 8);\n    bytes = bytes.slice(8 - this.length, 8);\n    const num = toBigInt(bytes);\n    return [num, offset + 8];\n  }\n\n  decode(data: Uint8Array, offset: number): [ToDecodedType<TBaseType>, number] {\n    const [num, nextOffset] = this.#decodeBigInt(data, offset);\n    if (this.baseType === 'u64') {\n      return [num as ToDecodedType<TBaseType>, nextOffset];\n    }\n    return [toNumber(num) as ToDecodedType<TBaseType>, nextOffset];\n  }\n}\n","import { concat } from '@ethersproject/bytes';\nimport type { RequireExactlyOne } from 'type-fest';\n\nimport type { TypesOfCoder } from './abstract-coder';\nimport Coder from './abstract-coder';\nimport NumberCoder from './number';\n\ntype InputValueOf<TCoders extends Record<string, Coder>> = RequireExactlyOne<{\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Input'];\n}>;\ntype DecodedValueOf<TCoders extends Record<string, Coder>> = RequireExactlyOne<{\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Decoded'];\n}>;\n\nexport default class EnumCoder<TCoders extends Record<string, Coder>> extends Coder<\n  InputValueOf<TCoders>,\n  DecodedValueOf<TCoders>\n> {\n  name: string;\n  coders: TCoders;\n  #caseIndexCoder: NumberCoder<'u64'>;\n  #encodedValueSize: number;\n\n  constructor(name: string, coders: TCoders) {\n    const caseIndexCoder = new NumberCoder('u64');\n    const encodedValueSize = Object.values(coders).reduce(\n      (max, coder) => Math.max(max, coder.encodedLength),\n      0\n    );\n    super('enum', `enum ${name}`, caseIndexCoder.encodedLength + encodedValueSize);\n    this.name = name;\n    this.coders = coders;\n    this.#caseIndexCoder = caseIndexCoder;\n    this.#encodedValueSize = encodedValueSize;\n  }\n\n  encode(value: InputValueOf<TCoders>): Uint8Array {\n    const [caseKey, ...empty] = Object.keys(value);\n    if (!caseKey) {\n      throw new Error('A field for the case must be provided');\n    }\n    if (empty.length !== 0) {\n      throw new Error('Only one field must be provided');\n    }\n    const valueCoder = this.coders[caseKey];\n    const caseIndex = Object.keys(this.coders).indexOf(caseKey);\n    const encodedValue = valueCoder.encode(value[caseKey]);\n    const padding = new Uint8Array(this.#encodedValueSize - valueCoder.encodedLength);\n    return concat([this.#caseIndexCoder.encode(caseIndex), padding, encodedValue]);\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoders>, number] {\n    let newOffset = offset;\n\n    let decoded;\n    [decoded, newOffset] = new NumberCoder('u64').decode(data, newOffset);\n    const caseIndex = decoded;\n    const caseKey = Object.keys(this.coders)[Number(caseIndex)];\n    if (!caseKey) {\n      throw new Error(`Invalid caseIndex \"${caseIndex}\". Valid cases: ${Object.keys(this.coders)}`);\n    }\n    const valueCoder = this.coders[caseKey];\n    const padding = this.#encodedValueSize - valueCoder.encodedLength;\n    newOffset += padding;\n    [decoded, newOffset] = valueCoder.decode(data, newOffset);\n\n    return [{ [caseKey]: decoded } as DecodedValueOf<TCoders>, newOffset];\n  }\n}\n",null,null,"import { concat } from '@ethersproject/bytes';\nimport { toUtf8Bytes, toUtf8String } from '@ethersproject/strings';\n\nimport Coder from './abstract-coder';\n\nexport default class StringCoder<TLength extends number = number> extends Coder<string, string> {\n  length: TLength;\n  #paddingLength: number;\n\n  constructor(length: TLength) {\n    let paddingLength = (8 - length) % 8;\n    paddingLength = paddingLength < 0 ? paddingLength + 8 : paddingLength;\n    super('string', `str[${length}]`, length + paddingLength);\n    this.length = length;\n    this.#paddingLength = paddingLength;\n  }\n\n  encode(value: string): Uint8Array {\n    const encoded = toUtf8Bytes(value.slice(0, this.length));\n    const padding = new Uint8Array(this.#paddingLength);\n    return concat([encoded, padding]);\n  }\n\n  decode(data: Uint8Array, offset: number): [string, number] {\n    const bytes = data.slice(offset, offset + this.length);\n    const value = toUtf8String(bytes);\n\n    const padding = this.#paddingLength;\n    return [value, offset + this.length + padding];\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { concat } from '@ethersproject/bytes';\n\nimport type { TypesOfCoder } from './abstract-coder';\nimport Coder from './abstract-coder';\n\ntype InputValueOf<TCoders extends Record<string, Coder>> = {\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Input'];\n};\ntype DecodedValueOf<TCoders extends Record<string, Coder>> = {\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Decoded'];\n};\n\nexport default class StructCoder<TCoders extends Record<string, Coder>> extends Coder<\n  InputValueOf<TCoders>,\n  DecodedValueOf<TCoders>\n> {\n  name: string;\n  coders: TCoders;\n\n  constructor(name: string, coders: TCoders) {\n    const encodedLength = Object.values(coders).reduce(\n      (acc, coder) => acc + coder.encodedLength,\n      0\n    );\n    super('struct', `struct ${name}`, encodedLength);\n    this.name = name;\n    this.coders = coders;\n  }\n\n  encode(value: InputValueOf<TCoders>): any {\n    const encodedFields = Object.keys(this.coders).map((fieldName) => {\n      const fieldCoder = this.coders[fieldName];\n      const fieldValue = value[fieldName];\n      const encoded = fieldCoder.encode(fieldValue);\n      return encoded;\n    });\n    return concat(encodedFields);\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoders>, number] {\n    let newOffset = offset;\n    const decodedValue = Object.keys(this.coders).reduce((obj, fieldName) => {\n      const fieldCoder = this.coders[fieldName];\n      let decoded;\n      [decoded, newOffset] = fieldCoder.decode(data, newOffset);\n      // eslint-disable-next-line no-param-reassign\n      obj[fieldName as keyof DecodedValueOf<TCoders>] = decoded;\n      return obj;\n    }, {} as DecodedValueOf<TCoders>);\n\n    return [decodedValue, newOffset];\n  }\n}\n","// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\nimport type { BytesLike } from '@ethersproject/bytes';\nimport { arrayify } from '@ethersproject/bytes';\nimport { Logger } from '@ethersproject/logger';\n\nimport type { DecodedValue, InputValue } from './coders/abstract-coder';\nimport type Coder from './coders/abstract-coder';\nimport ArrayCoder from './coders/array';\nimport B256Coder from './coders/b256';\nimport BooleanCoder from './coders/boolean';\nimport ByteCoder from './coders/byte';\nimport EnumCoder from './coders/enum';\nimport NumberCoder from './coders/number';\nimport StringCoder from './coders/string';\nimport StructCoder from './coders/struct';\nimport TupleCoder from './coders/tuple';\nimport type { JsonAbiFragmentType } from './json-abi';\nimport { filterEmptyParams } from './utilities';\n\nexport const stringRegEx = /str\\[(?<length>[0-9]+)\\]/;\nexport const arrayRegEx = /\\[(?<item>[\\w\\s]+);\\s*(?<length>[0-9]+)\\]/;\nexport const structRegEx = /^struct (?<name>\\w+)$/;\nexport const enumRegEx = /^enum (?<name>\\w+)$/;\nexport const tupleRegEx = /^\\((?<items>.*)\\)$/;\n\nconst logger = new Logger(process.env.BUILD_VERSION || '~');\n\nexport default class AbiCoder {\n  constructor() {\n    logger.checkNew(new.target, AbiCoder);\n  }\n\n  getCoder(param: JsonAbiFragmentType): Coder {\n    switch (param.type) {\n      case 'u8':\n      case 'u16':\n      case 'u32':\n      case 'u64':\n        return new NumberCoder(param.type);\n      case 'bool':\n        return new BooleanCoder();\n      case 'byte':\n        return new ByteCoder();\n      case 'b256':\n        return new B256Coder();\n      default:\n    }\n\n    const stringMatch = stringRegEx.exec(param.type)?.groups;\n    if (stringMatch) {\n      const length = parseInt(stringMatch.length, 10);\n\n      return new StringCoder(length);\n    }\n\n    const arrayMatch = arrayRegEx.exec(param.type)?.groups;\n    if (arrayMatch) {\n      const length = parseInt(arrayMatch.length, 10);\n      const itemComponent = param.components?.[0];\n      if (!itemComponent) {\n        throw new Error('Expected array type to have an item component');\n      }\n      const itemCoder = this.getCoder(itemComponent);\n      return new ArrayCoder(itemCoder, length);\n    }\n\n    const structMatch = structRegEx.exec(param.type)?.groups;\n    if (structMatch && Array.isArray(param.components)) {\n      const coders = param.components.reduce((obj, component) => {\n        // eslint-disable-next-line no-param-reassign\n        obj[component.name] = this.getCoder(component);\n        return obj;\n      }, {});\n      return new StructCoder(structMatch.name, coders);\n    }\n\n    const enumMatch = enumRegEx.exec(param.type)?.groups;\n    if (enumMatch && Array.isArray(param.components)) {\n      const coders = param.components.reduce((obj, component) => {\n        // eslint-disable-next-line no-param-reassign\n        obj[component.name] = this.getCoder(component);\n        return obj;\n      }, {});\n      return new EnumCoder(enumMatch.name, coders);\n    }\n\n    const tupleMatch = tupleRegEx.exec(param.type)?.groups;\n    if (tupleMatch && Array.isArray(param.components)) {\n      const coders = param.components.map((component) => this.getCoder(component));\n      return new TupleCoder(coders);\n    }\n\n    return logger.throwArgumentError('Invalid type', 'type', param.type);\n  }\n\n  encode(types: ReadonlyArray<JsonAbiFragmentType>, values: InputValue[]): Uint8Array {\n    const nonEmptyTypes = filterEmptyParams(types);\n\n    if (Array.isArray(values) && nonEmptyTypes.length !== values.length) {\n      logger.throwError('Types/values length mismatch', Logger.errors.INVALID_ARGUMENT, {\n        count: { types: nonEmptyTypes.length, values: values.length },\n        value: { types, values },\n      });\n    }\n\n    const coders = nonEmptyTypes.map((type) => this.getCoder(type));\n    const coder = new TupleCoder(coders);\n    return coder.encode(values);\n  }\n\n  decode(types: ReadonlyArray<JsonAbiFragmentType>, data: BytesLike): DecodedValue[] | undefined {\n    const bytes = arrayify(data);\n    const nonEmptyTypes = filterEmptyParams(types);\n    const assertParamsMatch = (newOffset: number) => {\n      if (newOffset !== bytes.length) {\n        logger.throwError('Types/values length mismatch', Logger.errors.INVALID_ARGUMENT, {\n          count: { types: nonEmptyTypes.length, values: bytes.length },\n          value: { types: nonEmptyTypes, bytes },\n        });\n      }\n    };\n\n    if (types.length === 0 || nonEmptyTypes.length === 0) {\n      // The VM is current return 0x0000000000000000, but we should treat it as undefined / void\n      assertParamsMatch(bytes.length ? 8 : 0);\n      return undefined;\n    }\n\n    const coders = nonEmptyTypes.map((type) => this.getCoder(type));\n    const coder = new TupleCoder(coders);\n    const [decoded, newOffset] = coder.decode(bytes, 0);\n\n    assertParamsMatch(newOffset);\n\n    return decoded as DecodedValue[];\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { BytesLike } from '@ethersproject/bytes';\nimport { arrayify, concat, hexlify } from '@ethersproject/bytes';\nimport { Logger } from '@ethersproject/logger';\nimport { sha256 } from '@ethersproject/sha2';\nimport { toUtf8Bytes } from '@ethersproject/strings';\n\nimport AbiCoder from './abi-coder';\nimport type { InputValue } from './coders/abstract-coder';\nimport BooleanCoder from './coders/boolean';\nimport type { Fragment } from './fragments/fragment';\nimport FunctionFragment from './fragments/function-fragment';\nimport type { JsonAbi, JsonAbiFragment } from './json-abi';\nimport { isReferenceType } from './json-abi';\nimport { filterEmptyParams } from './utilities';\n\nconst logger = new Logger(process.env.BUILD_VERSION || '~');\n\nconst coerceFragments = (value: ReadonlyArray<JsonAbiFragment>): Array<Fragment> => {\n  const fragments: Array<Fragment> = [];\n\n  value.forEach((v) => {\n    if (v.type === 'function') {\n      fragments.push(FunctionFragment.fromObject(v));\n    }\n  });\n\n  return fragments;\n};\n\nexport default class Interface {\n  readonly fragments: Array<Fragment>;\n  readonly functions: { [name: string]: FunctionFragment };\n  readonly abiCoder: AbiCoder;\n\n  constructor(jsonAbi: JsonAbi) {\n    this.fragments = coerceFragments(jsonAbi);\n    this.abiCoder = new AbiCoder();\n    this.functions = {};\n    this.fragments.forEach((fragment) => {\n      let bucket: { [name: string]: Fragment } = {};\n      switch (fragment.type) {\n        case 'function':\n          bucket = this.functions;\n          break;\n        default:\n          return;\n      }\n      const signature = fragment.format();\n      if (bucket[signature]) {\n        logger.warn(`duplicate definition - ${signature}`);\n        return;\n      }\n      bucket[signature] = fragment;\n    });\n  }\n\n  static getSighash(fragment: FunctionFragment | string): Uint8Array {\n    const bytes =\n      typeof fragment === 'string' ? toUtf8Bytes(fragment) : toUtf8Bytes(fragment.format());\n\n    return concat([new Uint8Array(4), arrayify(sha256(bytes)).slice(0, 4)]);\n  }\n\n  getFunction(nameOrSignatureOrSighash: string): FunctionFragment {\n    if (this.functions[nameOrSignatureOrSighash]) {\n      return this.functions[nameOrSignatureOrSighash];\n    }\n\n    const functionFragment = Object.values(this.functions).find(\n      (fragment: Fragment) =>\n        hexlify(Interface.getSighash(fragment)) === nameOrSignatureOrSighash ||\n        fragment.name === nameOrSignatureOrSighash\n    );\n\n    if (functionFragment) {\n      return functionFragment;\n    }\n\n    return logger.throwArgumentError(\n      `function ${nameOrSignatureOrSighash} not found.`,\n      'data',\n      functionFragment\n    );\n  }\n\n  // Decode the data for a function call (e.g. tx.data)\n  decodeFunctionData(functionFragment: FunctionFragment | string, data: BytesLike): any {\n    const fragment =\n      typeof functionFragment === 'string' ? this.getFunction(functionFragment) : functionFragment;\n\n    const bytes = arrayify(data);\n    if (hexlify(bytes.slice(0, 8)) !== hexlify(Interface.getSighash(fragment))) {\n      logger.throwArgumentError(\n        `data signature does not match function ${fragment.name}.`,\n        'data',\n        hexlify(bytes)\n      );\n    }\n\n    return this.abiCoder.decode(fragment.inputs, bytes.slice(16));\n  }\n\n  encodeFunctionData(\n    functionFragment: FunctionFragment | string,\n    values: Array<InputValue>\n  ): Uint8Array {\n    const fragment =\n      typeof functionFragment === 'string' ? this.getFunction(functionFragment) : functionFragment;\n\n    if (!fragment) {\n      throw new Error('Fragment not found');\n    }\n\n    const selector = Interface.getSighash(fragment);\n    const inputs = filterEmptyParams(fragment.inputs);\n\n    if (inputs.length === 0) {\n      return selector;\n    }\n\n    const isRef = inputs.length > 1 || isReferenceType(inputs[0].type);\n    const args = this.abiCoder.encode(inputs, values);\n    return concat([selector, new BooleanCoder().encode(isRef), args]);\n  }\n\n  // Decode the result of a function call\n  decodeFunctionResult(functionFragment: FunctionFragment | string, data: BytesLike): any {\n    const fragment =\n      typeof functionFragment === 'string' ? this.getFunction(functionFragment) : functionFragment;\n\n    const bytes = arrayify(data);\n\n    return this.abiCoder.decode(fragment.outputs, bytes);\n  }\n\n  encodeFunctionResult(\n    functionFragment: FunctionFragment | string,\n    values: Array<InputValue>\n  ): Uint8Array {\n    const fragment =\n      typeof functionFragment === 'string' ? this.getFunction(functionFragment) : functionFragment;\n\n    if (!fragment) {\n      throw new Error('Fragment not found');\n    }\n\n    return this.abiCoder.encode(fragment.outputs, values);\n  }\n}\n","import type { BytesLike } from '@ethersproject/bytes';\nimport { arrayify, concat, hexlify } from '@ethersproject/bytes';\nimport { Coder } from '@fuel-ts/abi-coder';\n\nexport class ByteArrayCoder extends Coder<BytesLike, string> {\n  length: number;\n  #paddingLength: number;\n\n  constructor(length: number) {\n    const paddingLength = (8 - (length % 8)) % 8;\n    const encodedLength = length + paddingLength;\n    super(\n      'ByteArray',\n      // While this might sound like a [u8; N] coder it's actually not.\n      // A [u8; N] coder would pad every u8 to 8 bytes which would\n      // make every u8 have the same size as a u64.\n      // We are packing four u8s into u64s here, avoiding this padding.\n      `[u64; ${encodedLength / 4}]`,\n      encodedLength\n    );\n    this.length = length;\n    this.#paddingLength = paddingLength;\n  }\n\n  encode(value: BytesLike): Uint8Array {\n    const parts: Uint8Array[] = [];\n\n    const data = arrayify(value);\n    parts.push(data);\n    // Write padding\n    if (this.#paddingLength) {\n      parts.push(new Uint8Array(this.#paddingLength));\n    }\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [string, number] {\n    let decoded;\n    let o = offset;\n\n    [decoded, o] = [hexlify(data.slice(o, o + this.length)), o + this.length];\n    const value = decoded;\n    // Read padding\n    if (this.#paddingLength) {\n      [decoded, o] = [null, o + this.#paddingLength];\n    }\n\n    return [value, o];\n  }\n}\n","import { B256Coder, NumberCoder, StructCoder } from '@fuel-ts/abi-coder';\n\nexport type UtxoId = {\n  /** Transaction ID (b256) */\n  transactionId: string;\n  /** Output index (u8) */\n  outputIndex: number;\n};\n\nexport class UtxoIdCoder extends StructCoder<{\n  transactionId: B256Coder;\n  outputIndex: NumberCoder<'u8'>;\n}> {\n  constructor() {\n    super('UtxoId', {\n      transactionId: new B256Coder(),\n      outputIndex: new NumberCoder('u8'),\n    });\n  }\n}\n","/* eslint-disable max-classes-per-file */\n\nimport { concat } from '@ethersproject/bytes';\nimport { Coder, B256Coder, NumberCoder } from '@fuel-ts/abi-coder';\n\nimport { ByteArrayCoder } from './byte-array';\nimport type { UtxoId } from './utxo-id';\nimport { UtxoIdCoder } from './utxo-id';\n\nexport enum InputType /* u8 */ {\n  Coin = 0,\n  Contract = 1,\n}\n\nexport type InputCoin = {\n  type: InputType.Coin;\n  /** UTXO ID (UtxoId) */\n  utxoID: UtxoId;\n  /** Owning address or script hash (b256) */\n  owner: string;\n  /** Amount of coins (u64) */\n  amount: bigint;\n  /** Asset ID of the coins (b256) */\n  assetId: string;\n  /** Index of witness that authorizes spending the coin (u8) */\n  witnessIndex: number;\n  /** UTXO being spent must have been created at least this many blocks ago (u64) */\n  maturity: bigint;\n  /** Length of predicate, in instructions (u16) */\n  predicateLength: number;\n  /** Length of predicate input data, in bytes (u16) */\n  predicateDataLength: number;\n  /** Predicate bytecode (byte[]) */\n  predicate: string;\n  /** Predicate input data (parameters) (byte[]) */\n  predicateData: string;\n};\n\nexport class InputCoinCoder extends Coder<InputCoin, InputCoin> {\n  constructor() {\n    super('InputCoin', 'struct InputCoin', 0);\n  }\n\n  encode(value: InputCoin): Uint8Array {\n    const parts: Uint8Array[] = [];\n\n    parts.push(new UtxoIdCoder().encode(value.utxoID));\n    parts.push(new B256Coder().encode(value.owner));\n    parts.push(new NumberCoder('u64').encode(value.amount));\n    parts.push(new B256Coder().encode(value.assetId));\n    parts.push(new NumberCoder('u8').encode(value.witnessIndex));\n    parts.push(new NumberCoder('u64').encode(value.maturity));\n    parts.push(new NumberCoder('u16').encode(value.predicateLength));\n    parts.push(new NumberCoder('u16').encode(value.predicateDataLength));\n    parts.push(new ByteArrayCoder(value.predicateLength).encode(value.predicate));\n    parts.push(new ByteArrayCoder(value.predicateDataLength).encode(value.predicateData));\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [InputCoin, number] {\n    let decoded;\n    let o = offset;\n\n    [decoded, o] = new UtxoIdCoder().decode(data, o);\n    const utxoID = decoded;\n    [decoded, o] = new B256Coder().decode(data, o);\n    const owner = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const amount = decoded;\n    [decoded, o] = new B256Coder().decode(data, o);\n    const assetId = decoded;\n    [decoded, o] = new NumberCoder('u8').decode(data, o);\n    const witnessIndex = Number(decoded);\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const maturity = decoded;\n    [decoded, o] = new NumberCoder('u16').decode(data, o);\n    [decoded, o] = new NumberCoder('u16').decode(data, o);\n    const predicateLength = decoded;\n    const predicateDataLength = decoded;\n    [decoded, o] = new ByteArrayCoder(predicateLength).decode(data, o);\n    const predicate = decoded;\n    [decoded, o] = new ByteArrayCoder(predicateDataLength).decode(data, o);\n    const predicateData = decoded;\n\n    return [\n      {\n        type: InputType.Coin,\n        utxoID,\n        owner,\n        amount,\n        assetId,\n        witnessIndex,\n        maturity,\n        predicateLength,\n        predicateDataLength,\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        predicate,\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        predicateData,\n      },\n      o,\n    ];\n  }\n}\n\nexport type InputContract = {\n  type: InputType.Contract;\n  /** UTXO ID (UtxoId) */\n  utxoID: UtxoId;\n  /** Root of amount of coins owned by contract before transaction execution (b256) */\n  balanceRoot: string;\n  /** State root of contract before transaction execution (b256) */\n  stateRoot: string;\n  /** Contract ID (b256) */\n  contractID: string;\n};\n\nexport class InputContractCoder extends Coder<InputContract, InputContract> {\n  constructor() {\n    super('InputContract', 'struct InputContract', 0);\n  }\n\n  encode(value: InputContract): Uint8Array {\n    const parts: Uint8Array[] = [];\n\n    parts.push(new UtxoIdCoder().encode(value.utxoID));\n    parts.push(new B256Coder().encode(value.balanceRoot));\n    parts.push(new B256Coder().encode(value.stateRoot));\n    parts.push(new B256Coder().encode(value.contractID));\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [InputContract, number] {\n    let decoded;\n    let o = offset;\n\n    [decoded, o] = new UtxoIdCoder().decode(data, o);\n    const utxoID = decoded;\n    [decoded, o] = new B256Coder().decode(data, o);\n    const balanceRoot = decoded;\n    [decoded, o] = new B256Coder().decode(data, o);\n    const stateRoot = decoded;\n    [decoded, o] = new B256Coder().decode(data, o);\n    const contractID = decoded;\n\n    return [\n      {\n        type: InputType.Contract,\n        utxoID,\n        balanceRoot,\n        stateRoot,\n        contractID,\n      },\n      o,\n    ];\n  }\n}\n\nexport type Input = InputCoin | InputContract;\n\nexport class InputCoder extends Coder<Input, Input> {\n  constructor() {\n    super('Input', 'struct Input', 0);\n  }\n\n  encode(value: Input): Uint8Array {\n    const parts: Uint8Array[] = [];\n\n    parts.push(new NumberCoder('u8').encode(value.type));\n    switch (value.type) {\n      case InputType.Coin: {\n        parts.push(new InputCoinCoder().encode(value));\n        break;\n      }\n      case InputType.Contract: {\n        parts.push(new InputContractCoder().encode(value));\n        break;\n      }\n      default: {\n        throw new Error('Invalid Input type');\n      }\n    }\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [Input, number] {\n    let decoded;\n    let o = offset;\n\n    [decoded, o] = new NumberCoder('u8').decode(data, o);\n    const type = decoded as InputType;\n    switch (type) {\n      case InputType.Coin: {\n        [decoded, o] = new InputCoinCoder().decode(data, o);\n        return [decoded, o];\n      }\n      case InputType.Contract: {\n        [decoded, o] = new InputContractCoder().decode(data, o);\n        return [decoded, o];\n      }\n      default: {\n        throw new Error('Invalid Input type');\n      }\n    }\n  }\n}\n","/* eslint-disable max-classes-per-file */\nimport { concat } from '@ethersproject/bytes';\nimport { Coder, B256Coder, NumberCoder } from '@fuel-ts/abi-coder';\n\nexport enum OutputType /* u8 */ {\n  Coin = 0,\n  Contract = 1,\n  Withdrawal = 2,\n  Change = 3,\n  Variable = 4,\n  ContractCreated = 5,\n}\n\nexport type OutputCoin = {\n  type: OutputType.Coin;\n  /** Receiving address or script hash (b256) */\n  to: string;\n  /** Amount of coins to send (u64) */\n  amount: bigint;\n  /** Asset ID of coins (b256) */\n  assetId: string;\n};\n\nexport class OutputCoinCoder extends Coder<OutputCoin, OutputCoin> {\n  constructor() {\n    super('OutputCoin', 'struct OutputCoin', 0);\n  }\n\n  encode(value: OutputCoin): Uint8Array {\n    const parts: Uint8Array[] = [];\n\n    parts.push(new B256Coder().encode(value.to));\n    parts.push(new NumberCoder('u64').encode(value.amount));\n    parts.push(new B256Coder().encode(value.assetId));\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [OutputCoin, number] {\n    let decoded;\n    let o = offset;\n\n    [decoded, o] = new B256Coder().decode(data, o);\n    const to = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const amount = decoded;\n    [decoded, o] = new B256Coder().decode(data, o);\n    const assetId = decoded;\n\n    return [\n      {\n        type: OutputType.Coin,\n        to,\n        amount,\n        assetId,\n      },\n      o,\n    ];\n  }\n}\n\nexport type OutputContract = {\n  type: OutputType.Contract;\n  /** Index of input contract (u8) */\n  inputIndex: number;\n  /** Root of amount of coins owned by contract after transaction execution (b256) */\n  balanceRoot: string;\n  /** State root of contract after transaction execution (b256) */\n  stateRoot: string;\n};\n\nexport class OutputContractCoder extends Coder<OutputContract, OutputContract> {\n  constructor() {\n    super('OutputContract', 'struct OutputContract', 0);\n  }\n\n  encode(value: OutputContract): Uint8Array {\n    const parts: Uint8Array[] = [];\n\n    parts.push(new NumberCoder('u8').encode(value.inputIndex));\n    parts.push(new B256Coder().encode(value.balanceRoot));\n    parts.push(new B256Coder().encode(value.stateRoot));\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [OutputContract, number] {\n    let decoded;\n    let o = offset;\n\n    [decoded, o] = new NumberCoder('u8').decode(data, o);\n    const inputIndex = decoded;\n    [decoded, o] = new B256Coder().decode(data, o);\n    const balanceRoot = decoded;\n    [decoded, o] = new B256Coder().decode(data, o);\n    const stateRoot = decoded;\n\n    return [\n      {\n        type: OutputType.Contract,\n        inputIndex,\n        balanceRoot,\n        stateRoot,\n      },\n      o,\n    ];\n  }\n}\n\nexport type OutputWithdrawal = {\n  type: OutputType.Withdrawal;\n  /** Receiving address (b256) */\n  to: string;\n  /** Amount of coins to withdraw (u64) */\n  amount: bigint;\n  /** Asset ID of coins (b256) */\n  assetId: string;\n};\n\nexport class OutputWithdrawalCoder extends Coder<OutputWithdrawal, OutputWithdrawal> {\n  constructor() {\n    super('OutputWithdrawal', 'struct OutputWithdrawal', 0);\n  }\n\n  encode(value: OutputWithdrawal): Uint8Array {\n    const parts: Uint8Array[] = [];\n\n    parts.push(new B256Coder().encode(value.to));\n    parts.push(new NumberCoder('u64').encode(value.amount));\n    parts.push(new B256Coder().encode(value.assetId));\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [OutputWithdrawal, number] {\n    let decoded;\n    let o = offset;\n\n    [decoded, o] = new B256Coder().decode(data, o);\n    const to = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const amount = decoded;\n    [decoded, o] = new B256Coder().decode(data, o);\n    const assetId = decoded;\n\n    return [\n      {\n        type: OutputType.Withdrawal,\n        to,\n        amount,\n        assetId,\n      },\n      o,\n    ];\n  }\n}\n\nexport type OutputChange = {\n  type: OutputType.Change;\n  /** Receiving address or script hash (b256) */\n  to: string;\n  /** Amount of coins to send (u64) */\n  amount: bigint;\n  /** Asset ID of coins (b256) */\n  assetId: string;\n};\n\nexport class OutputChangeCoder extends Coder<OutputChange, OutputChange> {\n  constructor() {\n    super('OutputChange', 'struct OutputChange', 0);\n  }\n\n  encode(value: OutputChange): Uint8Array {\n    const parts: Uint8Array[] = [];\n\n    parts.push(new B256Coder().encode(value.to));\n    parts.push(new NumberCoder('u64').encode(value.amount));\n    parts.push(new B256Coder().encode(value.assetId));\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [OutputChange, number] {\n    let decoded;\n    let o = offset;\n\n    [decoded, o] = new B256Coder().decode(data, o);\n    const to = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const amount = decoded;\n    [decoded, o] = new B256Coder().decode(data, o);\n    const assetId = decoded;\n\n    return [\n      {\n        type: OutputType.Change,\n        to,\n        amount,\n        assetId,\n      },\n      o,\n    ];\n  }\n}\n\nexport type OutputVariable = {\n  type: OutputType.Variable;\n  /** Receiving address or script hash (b256) */\n  to: string;\n  /** Amount of coins to send (u64) */\n  amount: bigint;\n  /** Asset ID of coins (b256) */\n  assetId: string;\n};\n\nexport class OutputVariableCoder extends Coder<OutputVariable, OutputVariable> {\n  constructor() {\n    super('OutputVariable', 'struct OutputVariable', 0);\n  }\n\n  encode(value: OutputVariable): Uint8Array {\n    const parts: Uint8Array[] = [];\n\n    parts.push(new B256Coder().encode(value.to));\n    parts.push(new NumberCoder('u64').encode(value.amount));\n    parts.push(new B256Coder().encode(value.assetId));\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [OutputVariable, number] {\n    let decoded;\n    let o = offset;\n\n    [decoded, o] = new B256Coder().decode(data, o);\n    const to = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const amount = decoded;\n    [decoded, o] = new B256Coder().decode(data, o);\n    const assetId = decoded;\n\n    return [\n      {\n        type: OutputType.Variable,\n        to,\n        amount,\n        assetId,\n      },\n      o,\n    ];\n  }\n}\n\nexport type OutputContractCreated = {\n  type: OutputType.ContractCreated;\n  /** Contract ID (b256) */\n  contractId: string;\n  /** State root of contract (b256) */\n  stateRoot: string;\n};\n\nexport class OutputContractCreatedCoder extends Coder<\n  OutputContractCreated,\n  OutputContractCreated\n> {\n  constructor() {\n    super('OutputContractCreated', 'struct OutputContractCreated', 0);\n  }\n\n  encode(value: OutputContractCreated): Uint8Array {\n    const parts: Uint8Array[] = [];\n\n    parts.push(new B256Coder().encode(value.contractId));\n    parts.push(new B256Coder().encode(value.stateRoot));\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [OutputContractCreated, number] {\n    let decoded;\n    let o = offset;\n\n    [decoded, o] = new B256Coder().decode(data, o);\n    const contractId = decoded;\n    [decoded, o] = new B256Coder().decode(data, o);\n    const stateRoot = decoded;\n\n    return [\n      {\n        type: OutputType.ContractCreated,\n        contractId,\n        stateRoot,\n      },\n      o,\n    ];\n  }\n}\n\nexport type Output =\n  | OutputCoin\n  | OutputContract\n  | OutputWithdrawal\n  | OutputChange\n  | OutputVariable\n  | OutputContractCreated;\n\nexport class OutputCoder extends Coder<Output, Output> {\n  constructor() {\n    super('Output', ' struct Output', 0);\n  }\n\n  encode(value: Output): Uint8Array {\n    const parts: Uint8Array[] = [];\n\n    parts.push(new NumberCoder('u8').encode(value.type));\n    switch (value.type) {\n      case OutputType.Coin: {\n        parts.push(new OutputCoinCoder().encode(value));\n        break;\n      }\n      case OutputType.Contract: {\n        parts.push(new OutputContractCoder().encode(value));\n        break;\n      }\n      case OutputType.Withdrawal: {\n        parts.push(new OutputWithdrawalCoder().encode(value));\n        break;\n      }\n      case OutputType.Change: {\n        parts.push(new OutputChangeCoder().encode(value));\n        break;\n      }\n      case OutputType.Variable: {\n        parts.push(new OutputVariableCoder().encode(value));\n        break;\n      }\n      case OutputType.ContractCreated: {\n        parts.push(new OutputContractCreatedCoder().encode(value));\n        break;\n      }\n      default: {\n        throw new Error('Invalid Output type');\n      }\n    }\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [Output, number] {\n    let decoded;\n    let o = offset;\n\n    [decoded, o] = new NumberCoder('u8').decode(data, o);\n    const type = decoded as OutputType;\n    switch (type) {\n      case OutputType.Coin: {\n        [decoded, o] = new OutputCoinCoder().decode(data, o);\n        return [decoded, o];\n      }\n      case OutputType.Contract: {\n        [decoded, o] = new OutputContractCoder().decode(data, o);\n        return [decoded, o];\n      }\n      case OutputType.Withdrawal: {\n        [decoded, o] = new OutputWithdrawalCoder().decode(data, o);\n        return [decoded, o];\n      }\n      case OutputType.Change: {\n        [decoded, o] = new OutputChangeCoder().decode(data, o);\n        return [decoded, o];\n      }\n      case OutputType.Variable: {\n        [decoded, o] = new OutputVariableCoder().decode(data, o);\n        return [decoded, o];\n      }\n      case OutputType.ContractCreated: {\n        [decoded, o] = new OutputContractCreatedCoder().decode(data, o);\n        return [decoded, o];\n      }\n      default: {\n        throw new Error('Invalid Output type');\n      }\n    }\n  }\n}\n","/* eslint-disable max-classes-per-file */\n\nimport { concat } from '@ethersproject/bytes';\nimport { Coder, B256Coder, NumberCoder } from '@fuel-ts/abi-coder';\n\nexport enum ReceiptType /* u8 */ {\n  Call = 0,\n  Return = 1,\n  ReturnData = 2,\n  Panic = 3,\n  Revert = 4,\n  Log = 5,\n  LogData = 6,\n  Transfer = 7,\n  TransferOut = 8,\n  ScriptResult = 9,\n}\n\nexport type ReceiptCall = {\n  type: ReceiptType.Call;\n  /** Contract ID of current context if in an internal context, zero otherwise (b256) */\n  from: string;\n  /** Contract ID of called contract (b256) */\n  to: string;\n  /** Amount of coins to forward, i.e. $rB (u64) */\n  amount: bigint;\n  /** Asset ID of coins to forward, i.e. MEM[$rC, 32] (b256) */\n  assetId: string;\n  /** Gas to forward, i.e. $rD (u64) */\n  gas: bigint;\n  /** First parameter (u64) */\n  param1: bigint;\n  /** Second parameter (u64) */\n  param2: bigint;\n  /** Value of register $pc (u64) */\n  pc: bigint;\n  /** Value of register $is (u64) */\n  is: bigint;\n};\n\nexport class ReceiptCallCoder extends Coder<ReceiptCall, ReceiptCall> {\n  constructor() {\n    super('ReceiptCall', 'struct ReceiptCall', 0);\n  }\n\n  encode(value: ReceiptCall): Uint8Array {\n    const parts: Uint8Array[] = [];\n\n    parts.push(new B256Coder().encode(value.from));\n    parts.push(new B256Coder().encode(value.to));\n    parts.push(new NumberCoder('u64').encode(value.amount));\n    parts.push(new B256Coder().encode(value.assetId));\n    parts.push(new NumberCoder('u64').encode(value.gas));\n    parts.push(new NumberCoder('u64').encode(value.param1));\n    parts.push(new NumberCoder('u64').encode(value.param2));\n    parts.push(new NumberCoder('u64').encode(value.pc));\n    parts.push(new NumberCoder('u64').encode(value.is));\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [ReceiptCall, number] {\n    let decoded;\n    let o = offset;\n\n    [decoded, o] = new B256Coder().decode(data, o);\n    const from = decoded;\n    [decoded, o] = new B256Coder().decode(data, o);\n    const to = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const amount = decoded;\n    [decoded, o] = new B256Coder().decode(data, o);\n    const assetId = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const gas = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const param1 = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const param2 = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const pc = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const is = decoded;\n\n    return [\n      {\n        type: ReceiptType.Call,\n        from,\n        to,\n        amount,\n        assetId,\n        gas,\n        param1,\n        param2,\n        pc,\n        is,\n      },\n      o,\n    ];\n  }\n}\n\nexport type ReceiptReturn = {\n  type: ReceiptType.Return;\n  /** Contract ID of current context if in an internal context, zero otherwise (b256) */\n  id: string;\n  /** Value of register $rA (u64) */\n  val: bigint;\n  /** Value of register $pc (u64) */\n  pc: bigint;\n  /** Value of register $is (u64) */\n  is: bigint;\n};\n\nexport class ReceiptReturnCoder extends Coder<ReceiptReturn, ReceiptReturn> {\n  constructor() {\n    super('ReceiptReturn', 'struct ReceiptReturn', 0);\n  }\n\n  encode(value: ReceiptReturn): Uint8Array {\n    const parts: Uint8Array[] = [];\n\n    parts.push(new B256Coder().encode(value.id));\n    parts.push(new NumberCoder('u64').encode(value.val));\n    parts.push(new NumberCoder('u64').encode(value.pc));\n    parts.push(new NumberCoder('u64').encode(value.is));\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [ReceiptReturn, number] {\n    let decoded;\n    let o = offset;\n\n    [decoded, o] = new B256Coder().decode(data, o);\n    const id = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const val = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const pc = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const is = decoded;\n\n    return [\n      {\n        type: ReceiptType.Return,\n        id,\n        val,\n        pc,\n        is,\n      },\n      o,\n    ];\n  }\n}\n\nexport type ReceiptReturnData = {\n  type: ReceiptType.ReturnData;\n  /** Contract ID of current context if in an internal context, zero otherwise (b256) */\n  id: string;\n  /** Value of register $rA (u64) */\n  ptr: bigint;\n  /** Value of register $rB (u64) */\n  len: bigint;\n  /** Hash of MEM[$rA, $rB] (b256) */\n  digest: string;\n  /** Value of register $pc (u64) */\n  pc: bigint;\n  /** Value of register $is (u64) */\n  is: bigint;\n};\n\nexport class ReceiptReturnDataCoder extends Coder<ReceiptReturnData, ReceiptReturnData> {\n  constructor() {\n    super('ReceiptReturnData', 'struct ReceiptReturnData', 0);\n  }\n\n  encode(value: ReceiptReturnData): Uint8Array {\n    const parts: Uint8Array[] = [];\n\n    parts.push(new B256Coder().encode(value.id));\n    parts.push(new NumberCoder('u64').encode(value.ptr));\n    parts.push(new NumberCoder('u64').encode(value.len));\n    parts.push(new B256Coder().encode(value.digest));\n    parts.push(new NumberCoder('u64').encode(value.pc));\n    parts.push(new NumberCoder('u64').encode(value.is));\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [ReceiptReturnData, number] {\n    let decoded;\n    let o = offset;\n\n    [decoded, o] = new B256Coder().decode(data, o);\n    const id = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const ptr = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const len = decoded;\n    [decoded, o] = new B256Coder().decode(data, o);\n    const digest = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const pc = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const is = decoded;\n\n    return [\n      {\n        type: ReceiptType.ReturnData,\n        id,\n        ptr,\n        len,\n        digest,\n        pc,\n        is,\n      },\n      o,\n    ];\n  }\n}\n\nexport type ReceiptPanic = {\n  type: ReceiptType.Panic;\n  /** Contract ID of current context if in an internal context, zero otherwise (b256) */\n  id: string;\n  /** Panic reason (u64) */\n  reason: bigint;\n  /** Value of register $pc (u64) */\n  pc: bigint;\n  /** Value of register $is (u64) */\n  is: bigint;\n};\n\nexport class ReceiptPanicCoder extends Coder<ReceiptPanic, ReceiptPanic> {\n  constructor() {\n    super('ReceiptPanic', 'struct ReceiptPanic', 0);\n  }\n\n  encode(value: ReceiptPanic): Uint8Array {\n    const parts: Uint8Array[] = [];\n\n    parts.push(new B256Coder().encode(value.id));\n    parts.push(new NumberCoder('u64').encode(value.reason));\n    parts.push(new NumberCoder('u64').encode(value.pc));\n    parts.push(new NumberCoder('u64').encode(value.is));\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [ReceiptPanic, number] {\n    let decoded;\n    let o = offset;\n\n    [decoded, o] = new B256Coder().decode(data, o);\n    const id = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const reason = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const pc = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const is = decoded;\n\n    return [\n      {\n        type: ReceiptType.Panic,\n        id,\n        reason,\n        pc,\n        is,\n      },\n      o,\n    ];\n  }\n}\n\nexport type ReceiptRevert = {\n  type: ReceiptType.Revert;\n  /** Contract ID of current context if in an internal context, zero otherwise (b256) */\n  id: string;\n  /** Value of register $rA (u64) */\n  val: bigint;\n  /** Value of register $pc (u64) */\n  pc: bigint;\n  /** Value of register $is (u64) */\n  is: bigint;\n};\n\nexport class ReceiptRevertCoder extends Coder<ReceiptRevert, ReceiptRevert> {\n  constructor() {\n    super('ReceiptRevert', 'struct ReceiptRevert', 0);\n  }\n\n  encode(value: ReceiptRevert): Uint8Array {\n    const parts: Uint8Array[] = [];\n\n    parts.push(new B256Coder().encode(value.id));\n    parts.push(new NumberCoder('u64').encode(value.val));\n    parts.push(new NumberCoder('u64').encode(value.pc));\n    parts.push(new NumberCoder('u64').encode(value.is));\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [ReceiptRevert, number] {\n    let decoded;\n    let o = offset;\n\n    [decoded, o] = new B256Coder().decode(data, o);\n    const id = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const val = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const pc = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const is = decoded;\n\n    return [\n      {\n        type: ReceiptType.Revert,\n        id,\n        val,\n        pc,\n        is,\n      },\n      o,\n    ];\n  }\n}\n\nexport type ReceiptLog = {\n  type: ReceiptType.Log;\n  /** Contract ID of current context if in an internal context, zero otherwise (b256) */\n  id: string;\n  /** Value of register $rA (u64) */\n  val0: bigint;\n  /** Value of register $rB (u64) */\n  val1: bigint;\n  /** Value of register $rC (u64) */\n  val2: bigint;\n  /** Value of register $rD (u64) */\n  val3: bigint;\n  /** Value of register $pc (u64) */\n  pc: bigint;\n  /** Value of register $is (u64) */\n  is: bigint;\n};\n\nexport class ReceiptLogCoder extends Coder<ReceiptLog, ReceiptLog> {\n  constructor() {\n    super('ReceiptLog', 'struct ReceiptLog', 0);\n  }\n\n  encode(value: ReceiptLog): Uint8Array {\n    const parts: Uint8Array[] = [];\n\n    parts.push(new B256Coder().encode(value.id));\n    parts.push(new NumberCoder('u64').encode(value.val0));\n    parts.push(new NumberCoder('u64').encode(value.val1));\n    parts.push(new NumberCoder('u64').encode(value.val2));\n    parts.push(new NumberCoder('u64').encode(value.val3));\n    parts.push(new NumberCoder('u64').encode(value.pc));\n    parts.push(new NumberCoder('u64').encode(value.is));\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [ReceiptLog, number] {\n    let decoded;\n    let o = offset;\n\n    [decoded, o] = new B256Coder().decode(data, o);\n    const id = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const val0 = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const val1 = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const val2 = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const val3 = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const pc = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const is = decoded;\n\n    return [\n      {\n        type: ReceiptType.Log,\n        id,\n        val0,\n        val1,\n        val2,\n        val3,\n        pc,\n        is,\n      },\n      o,\n    ];\n  }\n}\n\nexport type ReceiptLogData = {\n  type: ReceiptType.LogData;\n  /** Contract ID of current context if in an internal context, zero otherwise (b256) */\n  id: string;\n  /** Value of register $rA (u64) */\n  val0: bigint;\n  /** Value of register $rB (u64) */\n  val1: bigint;\n  /** Value of register $rC (u64) */\n  ptr: bigint;\n  /** Value of register $rD (u64) */\n  len: bigint;\n  /** Hash of MEM[$rC, $rD] (b256) */\n  digest: string;\n  /** Value of register $pc (u64) */\n  pc: bigint;\n  /** Value of register $is (u64) */\n  is: bigint;\n};\n\nexport class ReceiptLogDataCoder extends Coder<ReceiptLogData, ReceiptLogData> {\n  constructor() {\n    super('ReceiptLogData', 'struct ReceiptLogData', 0);\n  }\n\n  encode(value: ReceiptLogData): Uint8Array {\n    const parts: Uint8Array[] = [];\n\n    parts.push(new B256Coder().encode(value.id));\n    parts.push(new NumberCoder('u64').encode(value.val0));\n    parts.push(new NumberCoder('u64').encode(value.val1));\n    parts.push(new NumberCoder('u64').encode(value.ptr));\n    parts.push(new NumberCoder('u64').encode(value.len));\n    parts.push(new B256Coder().encode(value.digest));\n    parts.push(new NumberCoder('u64').encode(value.pc));\n    parts.push(new NumberCoder('u64').encode(value.is));\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [ReceiptLogData, number] {\n    let decoded;\n    let o = offset;\n\n    [decoded, o] = new B256Coder().decode(data, o);\n    const id = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const val0 = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const val1 = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const ptr = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const len = decoded;\n    [decoded, o] = new B256Coder().decode(data, o);\n    const digest = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const pc = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const is = decoded;\n\n    return [\n      {\n        type: ReceiptType.LogData,\n        id,\n        val0,\n        val1,\n        ptr,\n        len,\n        digest,\n        pc,\n        is,\n      },\n      o,\n    ];\n  }\n}\n\nexport type ReceiptTransfer = {\n  type: ReceiptType.Transfer;\n  /** Contract ID of current context if in an internal context, zero otherwise (b256) */\n  from: string;\n  /** Contract ID of contract to transfer coins to (b256) */\n  to: string;\n  /** Amount of coins transferred (u64) */\n  amount: bigint;\n  /** Asset ID of coins transferred (b256) */\n  assetId: string;\n  /** Value of register $pc (u64) */\n  pc: bigint;\n  /** Value of register $is (u64) */\n  is: bigint;\n};\n\nexport class ReceiptTransferCoder extends Coder<ReceiptTransfer, ReceiptTransfer> {\n  constructor() {\n    super('ReceiptTransfer', 'struct ReceiptTransfer', 0);\n  }\n\n  encode(value: ReceiptTransfer): Uint8Array {\n    const parts: Uint8Array[] = [];\n\n    parts.push(new B256Coder().encode(value.from));\n    parts.push(new B256Coder().encode(value.to));\n    parts.push(new NumberCoder('u64').encode(value.amount));\n    parts.push(new B256Coder().encode(value.assetId));\n    parts.push(new NumberCoder('u64').encode(value.pc));\n    parts.push(new NumberCoder('u64').encode(value.is));\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [ReceiptTransfer, number] {\n    let decoded;\n    let o = offset;\n\n    [decoded, o] = new B256Coder().decode(data, o);\n    const from = decoded;\n    [decoded, o] = new B256Coder().decode(data, o);\n    const to = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const amount = decoded;\n    [decoded, o] = new B256Coder().decode(data, o);\n    const assetId = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const pc = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const is = decoded;\n\n    return [\n      {\n        type: ReceiptType.Transfer,\n        from,\n        to,\n        amount,\n        assetId,\n        pc,\n        is,\n      },\n      o,\n    ];\n  }\n}\n\nexport type ReceiptTransferOut = {\n  type: ReceiptType.TransferOut;\n  /** Contract ID of current context if in an internal context, zero otherwise (b256) */\n  from: string;\n  /** Address to transfer coins to (b256) */\n  to: string;\n  /** Amount of coins transferred (u64) */\n  amount: bigint;\n  /** Asset ID of coins transferred (b256) */\n  assetId: string;\n  /** Value of register $pc (u64) */\n  pc: bigint;\n  /** Value of register $is (u64) */\n  is: bigint;\n};\n\nexport class ReceiptTransferOutCoder extends Coder<ReceiptTransferOut, ReceiptTransferOut> {\n  constructor() {\n    super('ReceiptTransferOut', 'struct ReceiptTransferOut', 0);\n  }\n\n  encode(value: ReceiptTransferOut): Uint8Array {\n    const parts: Uint8Array[] = [];\n\n    parts.push(new B256Coder().encode(value.from));\n    parts.push(new B256Coder().encode(value.to));\n    parts.push(new NumberCoder('u64').encode(value.amount));\n    parts.push(new B256Coder().encode(value.assetId));\n    parts.push(new NumberCoder('u64').encode(value.pc));\n    parts.push(new NumberCoder('u64').encode(value.is));\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [ReceiptTransferOut, number] {\n    let decoded;\n    let o = offset;\n\n    [decoded, o] = new B256Coder().decode(data, o);\n    const from = decoded;\n    [decoded, o] = new B256Coder().decode(data, o);\n    const to = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const amount = decoded;\n    [decoded, o] = new B256Coder().decode(data, o);\n    const assetId = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const pc = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const is = decoded;\n\n    return [\n      {\n        type: ReceiptType.TransferOut,\n        from,\n        to,\n        amount,\n        assetId,\n        pc,\n        is,\n      },\n      o,\n    ];\n  }\n}\n\nexport type ReceiptScriptResult = {\n  type: ReceiptType.ScriptResult;\n  /** Result variant with embedded `PanicReason` in first 8 bits and `instr` (u64) */\n  result: bigint;\n  /** Gas consumed by the script (u64) */\n  gasUsed: bigint;\n};\n\nexport class ReceiptScriptResultCoder extends Coder<ReceiptScriptResult, ReceiptScriptResult> {\n  constructor() {\n    super('ReceiptScriptResult', 'struct ReceiptScriptResult', 0);\n  }\n\n  encode(value: ReceiptScriptResult): Uint8Array {\n    const parts: Uint8Array[] = [];\n\n    parts.push(new NumberCoder('u64').encode(value.result));\n    parts.push(new NumberCoder('u64').encode(value.gasUsed));\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [ReceiptScriptResult, number] {\n    let decoded;\n    let o = offset;\n\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const result = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const gasUsed = decoded;\n\n    return [\n      {\n        type: ReceiptType.ScriptResult,\n        result,\n        gasUsed,\n      },\n      o,\n    ];\n  }\n}\n\nexport type Receipt =\n  | ReceiptCall\n  | ReceiptReturn\n  | ReceiptReturnData\n  | ReceiptPanic\n  | ReceiptRevert\n  | ReceiptLog\n  | ReceiptLogData\n  | ReceiptTransfer\n  | ReceiptTransferOut\n  | ReceiptScriptResult;\n\nexport class ReceiptCoder extends Coder<Receipt, Receipt> {\n  constructor() {\n    super('Receipt', 'struct Receipt', 0);\n  }\n\n  encode(value: Receipt): Uint8Array {\n    const parts: Uint8Array[] = [];\n\n    parts.push(new NumberCoder('u8').encode(value.type));\n    switch (value.type) {\n      case ReceiptType.Call: {\n        parts.push(new ReceiptCallCoder().encode(value));\n        break;\n      }\n      case ReceiptType.Return: {\n        parts.push(new ReceiptReturnCoder().encode(value));\n        break;\n      }\n      case ReceiptType.ReturnData: {\n        parts.push(new ReceiptReturnDataCoder().encode(value));\n        break;\n      }\n      case ReceiptType.Panic: {\n        parts.push(new ReceiptPanicCoder().encode(value));\n        break;\n      }\n      case ReceiptType.Revert: {\n        parts.push(new ReceiptRevertCoder().encode(value));\n        break;\n      }\n      case ReceiptType.Log: {\n        parts.push(new ReceiptLogCoder().encode(value));\n        break;\n      }\n      case ReceiptType.LogData: {\n        parts.push(new ReceiptLogDataCoder().encode(value));\n        break;\n      }\n      case ReceiptType.Transfer: {\n        parts.push(new ReceiptTransferCoder().encode(value));\n        break;\n      }\n      case ReceiptType.TransferOut: {\n        parts.push(new ReceiptTransferOutCoder().encode(value));\n        break;\n      }\n      case ReceiptType.ScriptResult: {\n        parts.push(new ReceiptScriptResultCoder().encode(value));\n        break;\n      }\n      default: {\n        throw new Error('Invalid Receipt type');\n      }\n    }\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [Receipt, number] {\n    let decoded;\n    let o = offset;\n\n    [decoded, o] = new NumberCoder('u8').decode(data, o);\n    const type = decoded as ReceiptType;\n    switch (type) {\n      case ReceiptType.Call: {\n        [decoded, o] = new ReceiptCallCoder().decode(data, o);\n        return [decoded, o];\n      }\n      case ReceiptType.Return: {\n        [decoded, o] = new ReceiptReturnCoder().decode(data, o);\n        return [decoded, o];\n      }\n      case ReceiptType.ReturnData: {\n        [decoded, o] = new ReceiptReturnDataCoder().decode(data, o);\n        return [decoded, o];\n      }\n      case ReceiptType.Panic: {\n        [decoded, o] = new ReceiptPanicCoder().decode(data, o);\n        return [decoded, o];\n      }\n      case ReceiptType.Revert: {\n        [decoded, o] = new ReceiptRevertCoder().decode(data, o);\n        return [decoded, o];\n      }\n      case ReceiptType.Log: {\n        [decoded, o] = new ReceiptLogCoder().decode(data, o);\n        return [decoded, o];\n      }\n      case ReceiptType.LogData: {\n        [decoded, o] = new ReceiptLogDataCoder().decode(data, o);\n        return [decoded, o];\n      }\n      case ReceiptType.Transfer: {\n        [decoded, o] = new ReceiptTransferCoder().decode(data, o);\n        return [decoded, o];\n      }\n      case ReceiptType.TransferOut: {\n        [decoded, o] = new ReceiptTransferOutCoder().decode(data, o);\n        return [decoded, o];\n      }\n      case ReceiptType.ScriptResult: {\n        [decoded, o] = new ReceiptScriptResultCoder().decode(data, o);\n        return [decoded, o];\n      }\n      default: {\n        throw new Error('Invalid Receipt type');\n      }\n    }\n  }\n}\n","import { B256Coder, StructCoder } from '@fuel-ts/abi-coder';\n\nexport type StorageSlot = {\n  /** Key (b256) */\n  key: string;\n  /** Value (b256) */\n  value: string;\n};\n\nexport class StorageSlotCoder extends StructCoder<{\n  key: B256Coder;\n  value: B256Coder;\n}> {\n  constructor() {\n    super('StorageSlot', {\n      key: new B256Coder(),\n      value: new B256Coder(),\n    });\n  }\n}\n","import { concat } from '@ethersproject/bytes';\nimport { Coder, NumberCoder } from '@fuel-ts/abi-coder';\n\nimport { ByteArrayCoder } from './byte-array';\n\nexport type Witness = {\n  /** Length of witness data, in bytes (u32) */\n  dataLength: number;\n  /** Witness data (byte[]) */\n  data: string;\n};\n\nexport class WitnessCoder extends Coder<Witness, Witness> {\n  constructor() {\n    super(\n      'Witness',\n      // Types of dynamic length are not supported in the ABI\n      'unknown',\n      0\n    );\n  }\n\n  encode(value: Witness): Uint8Array {\n    const parts: Uint8Array[] = [];\n\n    parts.push(new NumberCoder('u32').encode(value.dataLength));\n    parts.push(new ByteArrayCoder(value.dataLength).encode(value.data));\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [Witness, number] {\n    let decoded;\n    let o = offset;\n\n    [decoded, o] = new NumberCoder('u32').decode(data, o);\n    const dataLength = decoded;\n    [decoded, o] = new ByteArrayCoder(dataLength).decode(data, o);\n    const witnessData = decoded;\n\n    return [\n      {\n        dataLength,\n        data: witnessData,\n      },\n      o,\n    ];\n  }\n}\n","/* eslint-disable max-classes-per-file */\n\nimport { concat } from '@ethersproject/bytes';\nimport { Coder, ArrayCoder, B256Coder, NumberCoder } from '@fuel-ts/abi-coder';\n\nimport { ByteArrayCoder } from './byte-array';\nimport type { Input } from './input';\nimport { InputCoder } from './input';\nimport type { Output } from './output';\nimport { OutputCoder } from './output';\nimport { StorageSlotCoder } from './storage-slot';\nimport type { StorageSlot } from './storage-slot';\nimport type { Witness } from './witness';\nimport { WitnessCoder } from './witness';\n\nexport enum TransactionType /* u8 */ {\n  Script = 0,\n  Create = 1,\n}\n\nexport type TransactionScript = {\n  type: TransactionType.Script;\n  /** Gas price for transaction (u64) */\n  gasPrice: bigint;\n  /** Gas limit for transaction (u64) */\n  gasLimit: bigint;\n  /** Price per transaction byte (u64) */\n  bytePrice: bigint;\n  /** Block until which tx cannot be included (u64) */\n  maturity: bigint;\n  /** Script length, in instructions (u16) */\n  scriptLength: number;\n  /** Length of script input data, in bytes (u16) */\n  scriptDataLength: number;\n  /** Number of inputs (u8) */\n  inputsCount: number;\n  /** Number of outputs (u8) */\n  outputsCount: number;\n  /** Number of witnesses (u8) */\n  witnessesCount: number;\n  /** Merkle root of receipts (b256) */\n  receiptsRoot: string;\n  /** Script to execute (byte[]) */\n  script: string;\n  /** Script input data (parameters) (byte[]) */\n  scriptData: string;\n  /** List of inputs (Input[]) */\n  inputs: Input[];\n  /** List of outputs (Output[]) */\n  outputs: Output[];\n  /** List of witnesses (Witness[]) */\n  witnesses: Witness[];\n};\n\nexport class TransactionScriptCoder extends Coder<TransactionScript, TransactionScript> {\n  constructor() {\n    super('TransactionScript', 'struct TransactionScript', 0);\n  }\n\n  encode(value: TransactionScript): Uint8Array {\n    const parts: Uint8Array[] = [];\n\n    parts.push(new NumberCoder('u64').encode(value.gasPrice));\n    parts.push(new NumberCoder('u64').encode(value.gasLimit));\n    parts.push(new NumberCoder('u64').encode(value.bytePrice));\n    parts.push(new NumberCoder('u64').encode(value.maturity));\n    parts.push(new NumberCoder('u16').encode(value.scriptLength));\n    parts.push(new NumberCoder('u16').encode(value.scriptDataLength));\n    parts.push(new NumberCoder('u8').encode(value.inputsCount));\n    parts.push(new NumberCoder('u8').encode(value.outputsCount));\n    parts.push(new NumberCoder('u8').encode(value.witnessesCount));\n    parts.push(new B256Coder().encode(value.receiptsRoot));\n    parts.push(new ByteArrayCoder(value.scriptLength).encode(value.script));\n    parts.push(new ByteArrayCoder(value.scriptDataLength).encode(value.scriptData));\n    parts.push(new ArrayCoder(new InputCoder(), value.inputsCount).encode(value.inputs));\n    parts.push(new ArrayCoder(new OutputCoder(), value.outputsCount).encode(value.outputs));\n    parts.push(new ArrayCoder(new WitnessCoder(), value.witnessesCount).encode(value.witnesses));\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [TransactionScript, number] {\n    let decoded;\n    let o = offset;\n\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const gasPrice = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const gasLimit = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const bytePrice = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const maturity = decoded;\n    [decoded, o] = new NumberCoder('u16').decode(data, o);\n    [decoded, o] = new NumberCoder('u16').decode(data, o);\n    [decoded, o] = new NumberCoder('u8').decode(data, o);\n    [decoded, o] = new NumberCoder('u8').decode(data, o);\n    [decoded, o] = new NumberCoder('u8').decode(data, o);\n    const scriptLength = decoded;\n    const scriptDataLength = decoded;\n    const inputsCount = decoded;\n    const outputsCount = decoded;\n    const witnessesCount = decoded;\n    [decoded, o] = new B256Coder().decode(data, o);\n    const receiptsRoot = decoded;\n    [decoded, o] = new ByteArrayCoder(scriptLength).decode(data, o);\n    const script = decoded;\n    [decoded, o] = new ByteArrayCoder(scriptDataLength).decode(data, o);\n    const scriptData = decoded;\n    [decoded, o] = new ArrayCoder(new InputCoder(), inputsCount).decode(data, o);\n    const inputs = decoded;\n    [decoded, o] = new ArrayCoder(new OutputCoder(), outputsCount).decode(data, o);\n    const outputs = decoded;\n    [decoded, o] = new ArrayCoder(new WitnessCoder(), witnessesCount).decode(data, o);\n    const witnesses = decoded;\n\n    return [\n      {\n        type: TransactionType.Script,\n        gasPrice,\n        gasLimit,\n        bytePrice,\n        maturity,\n        scriptLength,\n        scriptDataLength,\n        inputsCount,\n        outputsCount,\n        witnessesCount,\n        receiptsRoot,\n        script,\n        scriptData,\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        inputs,\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        outputs,\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        witnesses,\n      },\n      o,\n    ];\n  }\n}\n\nexport type TransactionCreate = {\n  type: TransactionType.Create;\n  /** Gas price for transaction (u64) */\n  gasPrice: bigint;\n  /** Gas limit for transaction (u64) */\n  gasLimit: bigint;\n  /** Price per transaction byte (u64) */\n  bytePrice: bigint;\n  /** Block until which tx cannot be included (u64) */\n  maturity: bigint;\n  /** Contract bytecode length, in instructions (u32) */\n  bytecodeLength: number;\n  /** Witness index of contract bytecode to create (u8) */\n  bytecodeWitnessIndex: number;\n  /** Number of static contracts (u8) */\n  staticContractsCount: number;\n  /** Number of storage slots to initialize (u16) */\n  storageSlotsCount: number;\n  /** Number of inputs (u8) */\n  inputsCount: number;\n  /** Number of outputs (u8) */\n  outputsCount: number;\n  /** Number of witnesses (u8) */\n  witnessesCount: number;\n  /** Salt (b256) */\n  salt: string;\n  /** List of static contracts (b256[]) */\n  staticContracts: string[];\n  /** List of inputs (StorageSlot[]) */\n  storageSlots: StorageSlot[];\n  /** List of inputs (Input[]) */\n  inputs: Input[];\n  /** List of outputs (Output[]) */\n  outputs: Output[];\n  /** List of witnesses (Witness[]) */\n  witnesses: Witness[];\n};\n\nexport class TransactionCreateCoder extends Coder<TransactionCreate, TransactionCreate> {\n  constructor() {\n    super('TransactionCreate', 'struct TransactionCreate', 0);\n  }\n\n  encode(value: TransactionCreate): Uint8Array {\n    const parts: Uint8Array[] = [];\n\n    parts.push(new NumberCoder('u64').encode(value.gasPrice));\n    parts.push(new NumberCoder('u64').encode(value.gasLimit));\n    parts.push(new NumberCoder('u64').encode(value.bytePrice));\n    parts.push(new NumberCoder('u64').encode(value.maturity));\n    parts.push(new NumberCoder('u32').encode(value.bytecodeLength));\n    parts.push(new NumberCoder('u8').encode(value.bytecodeWitnessIndex));\n    parts.push(new NumberCoder('u8').encode(value.staticContractsCount));\n    parts.push(new NumberCoder('u16').encode(value.storageSlotsCount));\n    parts.push(new NumberCoder('u8').encode(value.inputsCount));\n    parts.push(new NumberCoder('u8').encode(value.outputsCount));\n    parts.push(new NumberCoder('u8').encode(value.witnessesCount));\n    parts.push(new B256Coder().encode(value.salt));\n    parts.push(\n      new ArrayCoder(new B256Coder(), value.staticContractsCount).encode(value.staticContracts)\n    );\n    parts.push(\n      new ArrayCoder(new StorageSlotCoder(), value.storageSlotsCount).encode(value.storageSlots)\n    );\n    parts.push(new ArrayCoder(new InputCoder(), value.inputsCount).encode(value.inputs));\n    parts.push(new ArrayCoder(new OutputCoder(), value.outputsCount).encode(value.outputs));\n    parts.push(new ArrayCoder(new WitnessCoder(), value.witnessesCount).encode(value.witnesses));\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [TransactionCreate, number] {\n    let decoded;\n    let o = offset;\n\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const gasPrice = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const gasLimit = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const bytePrice = decoded;\n    [decoded, o] = new NumberCoder('u64').decode(data, o);\n    const maturity = decoded;\n    [decoded, o] = new NumberCoder('u16').decode(data, o);\n    [decoded, o] = new NumberCoder('u8').decode(data, o);\n    [decoded, o] = new NumberCoder('u8').decode(data, o);\n    [decoded, o] = new NumberCoder('u16').decode(data, o);\n    [decoded, o] = new NumberCoder('u8').decode(data, o);\n    [decoded, o] = new NumberCoder('u8').decode(data, o);\n    [decoded, o] = new NumberCoder('u8').decode(data, o);\n    const bytecodeLength = decoded;\n    const bytecodeWitnessIndex = decoded;\n    const staticContractsCount = decoded;\n    const storageSlotsCount = decoded;\n    const inputsCount = decoded;\n    const outputsCount = decoded;\n    const witnessesCount = decoded;\n    [decoded, o] = new B256Coder().decode(data, o);\n    const salt = decoded;\n    [decoded, o] = new ArrayCoder(new B256Coder(), staticContractsCount).decode(data, o);\n    const staticContracts = decoded;\n    [decoded, o] = new ArrayCoder(new StorageSlotCoder(), storageSlotsCount).decode(data, o);\n    const storageSlots = decoded;\n    [decoded, o] = new ArrayCoder(new InputCoder(), inputsCount).decode(data, o);\n    const inputs = decoded;\n    [decoded, o] = new ArrayCoder(new OutputCoder(), outputsCount).decode(data, o);\n    const outputs = decoded;\n    [decoded, o] = new ArrayCoder(new WitnessCoder(), witnessesCount).decode(data, o);\n    const witnesses = decoded;\n\n    return [\n      {\n        type: TransactionType.Create,\n        gasPrice,\n        gasLimit,\n        bytePrice,\n        maturity,\n        bytecodeLength,\n        bytecodeWitnessIndex,\n        staticContractsCount,\n        storageSlotsCount,\n        inputsCount,\n        outputsCount,\n        witnessesCount,\n        salt,\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignores\n        staticContracts,\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        storageSlots,\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        inputs,\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        outputs,\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        witnesses,\n      },\n      o,\n    ];\n  }\n}\n\nexport type Transaction = TransactionScript | TransactionCreate;\n\nexport class TransactionCoder extends Coder<Transaction, Transaction> {\n  constructor() {\n    super('Transaction', 'struct Transaction', 0);\n  }\n\n  encode(value: Transaction): Uint8Array {\n    const parts: Uint8Array[] = [];\n\n    parts.push(new NumberCoder('u8').encode(value.type));\n    switch (value.type) {\n      case TransactionType.Script: {\n        parts.push(new TransactionScriptCoder().encode(value));\n        break;\n      }\n      case TransactionType.Create: {\n        parts.push(new TransactionCreateCoder().encode(value));\n        break;\n      }\n      default: {\n        throw new Error('Invalid Transaction type');\n      }\n    }\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [Transaction, number] {\n    let decoded;\n    let o = offset;\n\n    [decoded, o] = new NumberCoder('u8').decode(data, o);\n    const type = decoded as TransactionType;\n    switch (type) {\n      case TransactionType.Script: {\n        [decoded, o] = new TransactionScriptCoder().decode(data, o);\n        return [decoded, o];\n      }\n      case TransactionType.Create: {\n        [decoded, o] = new TransactionCreateCoder().decode(data, o);\n        return [decoded, o];\n      }\n      default: {\n        throw new Error('Invalid Input type');\n      }\n    }\n  }\n}\n","/** Maximum contract size, in bytes. */\nexport const CONTRACT_MAX_SIZE = 16 * 1024;\n\n/** Maximum number of inputs. */\nexport const MAX_INPUTS = 8;\n\n/** Maximum number of outputs. */\nexport const MAX_OUTPUTS = 8;\n\n/** Maximum number of witnesses. */\nexport const MAX_WITNESSES = 16;\n\n/** Maximum gas per transaction. */\nexport const MAX_GAS_PER_TX = 1000000;\n\n// TODO: set max script length const\n/** Maximum length of script, in instructions. */\nexport const MAX_SCRIPT_LENGTH = 1024 * 1024 * 1024;\n\n// TODO: set max script length const\n/** Maximum length of script data, in bytes. */\nexport const MAX_SCRIPT_DATA_LENGTH = 1024 * 1024 * 1024;\n\n/** Maximum number of static contracts. */\nexport const MAX_STATIC_CONTRACTS = 255;\n\n// TODO: set max predicate length value\n/** Maximum length of predicate, in instructions. */\nexport const MAX_PREDICATE_LENGTH = 1024 * 1024;\n\n// TODO: set max predicate data length value\n/** Maximum length of predicate data, in bytes. */\nexport const MAX_PREDICATE_DATA_LENGTH = 1024 * 1024;\n"],"mappings":"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","names":[]}