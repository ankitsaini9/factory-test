{"version":3,"sources":["../src/index.ts","../src/mnemonic.ts","../src/utils.ts"],"sourcesContent":["export { default as Mnemonic } from './mnemonic';\nexport type { MnemonicPhrase } from './utils';\n","import { Base58 } from '@ethersproject/basex';\nimport type { BytesLike } from '@ethersproject/bytes';\nimport { hexDataSlice, concat, hexlify, arrayify } from '@ethersproject/bytes';\nimport { pbkdf2 } from '@ethersproject/pbkdf2';\nimport { computeHmac, sha256, SupportedAlgorithm } from '@ethersproject/sha2';\nimport { randomBytes } from '@fuel-ts/keystore';\nimport { english } from '@fuel-ts/wordlists';\n\nimport type { MnemonicPhrase } from './utils';\nimport {\n  entropyToMnemonicIndices,\n  getWords,\n  getPhrase,\n  mnemonicWordsToEntropy,\n  toUtf8Bytes,\n} from './utils';\n\n//\n// Constants\n//\n// \"Bitcoin seed\"\nconst MasterSecret = toUtf8Bytes('Bitcoin seed');\n// 4 byte: version bytes (mainnet: 0x0488B21E public, 0x0488ADE4 private; testnet: 0x043587CF public, 0x04358394 private)\nconst MainnetPRV = 0x0488ade4;\nconst TestnetPRV = 0x04358394;\n\nfunction assertWordList(wordlist: Array<string>) {\n  if (wordlist.length !== 2048) {\n    throw new Error('Invalid word list length');\n  }\n}\n\nfunction assertEntropy(entropy: BytesLike) {\n  if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {\n    throw new Error('invalid entropy');\n  }\n}\n\nfunction assertMnemonic(words: Array<string>) {\n  if (![12, 15, 18, 21, 24].includes(words.length)) {\n    throw new Error('invalid mnemonic size');\n  }\n}\n\nclass Mnemonic {\n  wordlist: Array<string>;\n\n  /**\n   *\n   * @param wordlist - Provide a wordlist with the list of words used to generate the mnemonic phrase. The default value is the English list.\n   * @returns Mnemonic instance\n   */\n  constructor(wordlist: Array<string> = english) {\n    this.wordlist = wordlist;\n\n    assertWordList(this.wordlist);\n  }\n\n  /**\n   *\n   * @param phrase - Mnemonic phrase composed by words from the provided wordlist\n   * @returns Entropy hash\n   */\n  mnemonicToEntropy(phrase: MnemonicPhrase) {\n    return Mnemonic.mnemonicToEntropy(phrase, this.wordlist);\n  }\n\n  /**\n   *\n   * @param entropy - Entropy source to the mnemonic phrase.\n   * @returns Mnemonic phrase\n   */\n  entropyToMnemonic(entropy: BytesLike) {\n    return Mnemonic.entropyToMnemonic(entropy, this.wordlist);\n  }\n\n  /**\n   *\n   * @param phrase - Mnemonic phrase composed by words from the provided wordlist\n   * @param wordlist - Provide a wordlist with the list of words used to generate the mnemonic phrase. The default value is the English list.\n   * @returns Mnemonic phrase\n   */\n  static mnemonicToEntropy(phrase: MnemonicPhrase, wordlist: Array<string> = english): string {\n    const words = getWords(phrase);\n\n    assertMnemonic(words);\n\n    return hexlify(mnemonicWordsToEntropy(words, wordlist));\n  }\n\n  /**\n   * @param entropy - Entropy source to the mnemonic phrase.\n   * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).\n   * @returns 64-byte array contains privateKey and chainCode as described on BIP39\n   */\n  static entropyToMnemonic(entropy: BytesLike, wordlist: Array<string> = english): string {\n    const entropyBytes = arrayify(entropy, {\n      allowMissingPrefix: true,\n    });\n\n    assertWordList(wordlist);\n    assertEntropy(entropyBytes);\n\n    return entropyToMnemonicIndices(entropyBytes)\n      .map((i) => wordlist[i])\n      .join(' ');\n  }\n\n  /**\n   * @param phrase - Mnemonic phrase composed by words from the provided wordlist\n   * @param passphrase - Add additional security to protect the generated seed with a memorized passphrase. `Note: if the owner forgot the passphrase, all wallets and accounts derive from the phrase will be lost.`\n   * @returns 64-byte array contains privateKey and chainCode as described on BIP39\n   */\n  static mnemonicToSeed(phrase: MnemonicPhrase, passphrase: BytesLike = '') {\n    assertMnemonic(getWords(phrase));\n\n    const phraseBytes = toUtf8Bytes(getPhrase(phrase));\n    const salt = toUtf8Bytes(`mnemonic${passphrase}`);\n\n    return pbkdf2(phraseBytes, salt, 2048, 64, 'sha512');\n  }\n\n  /**\n   * @param phrase - Mnemonic phrase composed by words from the provided wordlist\n   * @param passphrase - Add additional security to protect the generated seed with a memorized passphrase. `Note: if the owner forgot the passphrase, all wallets and accounts derive from the phrase will be lost.`\n   * @returns 64-byte array contains privateKey and chainCode as described on BIP39\n   */\n  static mnemonicToMasterKeys(phrase: MnemonicPhrase, passphrase: BytesLike = '') {\n    const seed = Mnemonic.mnemonicToSeed(phrase, passphrase);\n    return Mnemonic.masterKeysFromSeed(seed);\n  }\n\n  /**\n   * @param seed - BIP39 seed\n   * @param testnet - Inform if should use testnet or mainnet prefix, the default value is true (`mainnet`).\n   * @returns 64-byte array contains privateKey and chainCode as described on BIP39\n   */\n  static masterKeysFromSeed(seed: string): Uint8Array {\n    const seedArray = arrayify(seed);\n\n    if (seedArray.length < 16 || seedArray.length > 64) {\n      throw new Error('invalid seed');\n    }\n\n    return arrayify(computeHmac(SupportedAlgorithm.sha512, MasterSecret, seedArray));\n  }\n\n  /**\n   * Get the extendKey as defined on BIP-32 from the provided seed\n   *\n   * @param seed - BIP39 seed\n   * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).\n   * @returns BIP-32 extended private key\n   */\n  static seedToExtendedKey(seed: string, testnet: boolean = false): string {\n    const masterKey = Mnemonic.masterKeysFromSeed(seed);\n    const prefix = arrayify(testnet ? TestnetPRV : MainnetPRV);\n    const depth = '0x00';\n    const fingerprint = '0x00000000';\n    const index = '0x00000000';\n    // last 32 bites from the key\n    const chainCode = masterKey.slice(32);\n    // first 32 bites from the key\n    const privateKey = masterKey.slice(0, 32);\n    const extendedKey = concat([\n      prefix,\n      depth,\n      fingerprint,\n      index,\n      chainCode,\n      concat(['0x00', privateKey]),\n    ]);\n    const checksum = hexDataSlice(sha256(sha256(extendedKey)), 0, 4);\n\n    return Base58.encode(concat([extendedKey, checksum]));\n  }\n\n  /**\n   *  Create a new mnemonic using a randomly generated number as entropy.\n   *  As defined in BIP39, the entropy must be a multiple of 32 bits, and its size must be between 128 and 256 bits.\n   *  Therefore, the possible values for `strength` are 128, 160, 192, 224, and 256.\n   *  If not provided, the default entropy length will be set to 256 bits.\n   *  The return is a list of words that encodes the generated entropy.\n   *\n   *\n   * @param size - Number of bytes used as an entropy\n   * @param extraEntropy - Optional extra entropy to increase randomness\n   * @returns A randomly generated mnemonic\n   */\n  static generate(size: number = 32, extraEntropy: BytesLike = '') {\n    const entropy = extraEntropy\n      ? sha256(concat([randomBytes(size), arrayify(extraEntropy)]))\n      : randomBytes(size);\n    return Mnemonic.entropyToMnemonic(entropy);\n  }\n}\n\nexport default Mnemonic;\n","import type { BytesLike } from '@ethersproject/bytes';\nimport { arrayify } from '@ethersproject/bytes';\nimport { sha256 } from '@ethersproject/sha2';\n\n/* Mnemonic phrase composed by words from the provided wordlist it can be a text or a array of words */\nexport type MnemonicPhrase = string | Array<string>;\n\nexport function toUtf8Bytes(stri: string): Uint8Array {\n  const str = stri.normalize('NFKD');\n\n  const result = [];\n  for (let i = 0; i < str.length; i += 1) {\n    const c = str.charCodeAt(i);\n\n    if (c < 0x80) {\n      result.push(c);\n    } else if (c < 0x800) {\n      result.push((c >> 6) | 0xc0);\n      result.push((c & 0x3f) | 0x80);\n    } else if ((c & 0xfc00) === 0xd800) {\n      i += 1;\n      const c2 = str.charCodeAt(i);\n\n      if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n        throw new Error('invalid utf-8 string');\n      }\n\n      // Surrogate Pair\n      const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n      result.push((pair >> 18) | 0xf0);\n      result.push(((pair >> 12) & 0x3f) | 0x80);\n      result.push(((pair >> 6) & 0x3f) | 0x80);\n      result.push((pair & 0x3f) | 0x80);\n    } else {\n      result.push((c >> 12) | 0xe0);\n      result.push(((c >> 6) & 0x3f) | 0x80);\n      result.push((c & 0x3f) | 0x80);\n    }\n  }\n\n  return arrayify(result);\n}\n\n// Returns a byte with the LSB bits set\nfunction getLowerMask(bits: number): number {\n  return (1 << bits) - 1;\n}\n\n// Returns a byte with the MSB bits set\nfunction getUpperMask(bits: number): number {\n  return ((1 << bits) - 1) << (8 - bits);\n}\n\nexport function getWords(mnemonic: MnemonicPhrase): Array<string> {\n  if (!Array.isArray(mnemonic)) {\n    return mnemonic.split(' ');\n  }\n  return mnemonic;\n}\n\nexport function getPhrase(mnemonic: MnemonicPhrase): string {\n  if (Array.isArray(mnemonic)) {\n    return mnemonic.join(' ');\n  }\n  return mnemonic;\n}\n\nexport function entropyToMnemonicIndices(entropy: Uint8Array): Array<number> {\n  const indices: Array<number> = [0];\n\n  let remainingBits = 11;\n  for (let i = 0; i < entropy.length; i += 1) {\n    if (remainingBits > 8) {\n      indices[indices.length - 1] <<= 8;\n      indices[indices.length - 1] |= entropy[i];\n\n      remainingBits -= 8;\n      // This byte will complete an 11-bit index\n    } else {\n      indices[indices.length - 1] <<= remainingBits;\n      indices[indices.length - 1] |= entropy[i] >> (8 - remainingBits);\n\n      // Start the next word\n      indices.push(entropy[i] & getLowerMask(8 - remainingBits));\n\n      remainingBits += 3;\n    }\n  }\n\n  // Compute the checksum bits\n  const checksumBits = entropy.length / 4;\n  const checksum = arrayify(sha256(entropy))[0] & getUpperMask(checksumBits);\n\n  // Shift the checksum into the word indices\n  indices[indices.length - 1] <<= checksumBits;\n  indices[indices.length - 1] |= checksum >> (8 - checksumBits);\n\n  return indices;\n}\n\nexport function mnemonicWordsToEntropy(words: Array<string>, wordlist: Array<string>): BytesLike {\n  const size = Math.ceil((11 * words.length) / 8);\n  const entropy = arrayify(new Uint8Array(size));\n\n  let offset = 0;\n  for (let i = 0; i < words.length; i += 1) {\n    const index = wordlist.indexOf(words[i].normalize('NFKD'));\n    if (index === -1) {\n      throw new Error('invalid mnemonic');\n    }\n\n    for (let bit = 0; bit < 11; bit += 1) {\n      if (index & (1 << (10 - bit))) {\n        entropy[offset >> 3] |= 1 << (7 - (offset % 8));\n      }\n      offset += 1;\n    }\n  }\n  const entropyBits = (32 * words.length) / 3;\n  const checksumBits = words.length / 3;\n  const checksumMask = getUpperMask(checksumBits);\n  const checksum = arrayify(sha256(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;\n\n  if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {\n    throw new Error('invalid checksum');\n  }\n\n  return entropy.slice(0, entropyBits / 8);\n}\n"],"mappings":"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","names":[]}