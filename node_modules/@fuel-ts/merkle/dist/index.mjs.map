{"version":3,"sources":["../src/binaryMerkleTree.ts","../src/types/node.ts"],"sourcesContent":["// A set of useful helper methods for testing binary Merkle trees.\nimport { EMPTY, hash } from '@fuel-ts/merkle-shared';\n\nimport Node from './types/node';\n\n/**\n * Slice off the '0x' on each argument to simulate abi.encodePacked\n */\nexport function hashLeaf(data: string): string {\n  return hash('0x00'.concat(data.slice(2)));\n}\n\n/**\n * Slice off the '0x' on each argument to simulate abi.encodePacked\n * hash(prefix +  left + right)\n */\nexport function hashNode(left: string, right: string): string {\n  return hash('0x01'.concat(left.slice(2)).concat(right.slice(2)));\n}\n\n/**\n * Construct tree\n */\nexport function constructTree(data: string[]): Node[] {\n  const nodes = [];\n  for (let i = 0; i < data.length; i += 1) {\n    const hashed = hashLeaf(data[i]);\n    const leaf = new Node(-1, -1, -1, hashed, data[i]);\n    leaf.index = i;\n    nodes.push(leaf);\n  }\n\n  const nodesList = [...nodes];\n  let pNodes = [...nodes];\n\n  let size = (nodes.length + 1) >> 1;\n  let odd = nodes.length & 1;\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    let i = 0;\n    for (; i < size - odd; i += 1) {\n      const j = i << 1;\n      const hashed = hashNode(pNodes[j].hash, pNodes[j + 1].hash);\n      nodes[i] = new Node(pNodes[j].index, pNodes[j + 1].index, -1, hashed, '');\n      const nextIndex = nodesList.length;\n      nodes[i].index = nextIndex;\n\n      nodesList[pNodes[j].index].parent = nextIndex;\n      nodesList[pNodes[j + 1].index].parent = nextIndex;\n      nodesList.push(nodes[i]);\n    }\n\n    if (size === 1) {\n      break;\n    }\n\n    if (odd === 1) {\n      nodes[i] = pNodes[i << 1];\n    }\n\n    odd = size & 1;\n    size = (size + 1) >> 1;\n    pNodes = [...nodes];\n  }\n  return nodesList;\n}\n\n/**\n * Compute the merkle root\n */\nexport function calcRoot(data: string[]): string {\n  if (!data.length) {\n    return EMPTY;\n  }\n  const nodes = [];\n  for (let i = 0; i < data.length; i += 1) {\n    const hashed = hashLeaf(data[i]);\n    nodes.push(new Node(-1, -1, -1, hashed, data[i]));\n  }\n  let pNodes = nodes;\n  let size = (nodes.length + 1) >> 1;\n  let odd = nodes.length & 1;\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    let i = 0;\n    for (; i < size - odd; i += 1) {\n      const j = i << 1;\n      const hashed = hashNode(pNodes[j].hash, pNodes[j + 1].hash);\n      nodes[i] = new Node(pNodes[j].index, pNodes[j + 1].index, -1, hashed, '');\n    }\n    if (odd === 1) {\n      nodes[i] = pNodes[i << 1];\n    }\n    if (size === 1) {\n      break;\n    }\n    odd = size & 1;\n    size = (size + 1) >> 1;\n    pNodes = nodes;\n  }\n  return nodes[0].hash;\n}\n\n/**\n * Get proof for the leaf\n */\nexport function getProof(nodes: Node[], id: number): string[] {\n  const proof: string[] = [];\n  for (let prev = id, cur = nodes[id].parent; cur !== -1; prev = cur, cur = nodes[cur].parent) {\n    if (nodes[cur].left === prev) {\n      proof.push(nodes[nodes[cur].right].hash);\n    } else {\n      proof.push(nodes[nodes[cur].left].hash);\n    }\n  }\n  return proof;\n}\n","class Node {\n  left: number;\n  right: number;\n  parent: number;\n  hash: string;\n  data: string;\n  index: number;\n\n  constructor(\n    left: number,\n    right: number,\n    parent: number,\n    hash: string,\n    data: string,\n    index: number = 0\n  ) {\n    this.left = left;\n    this.right = right;\n    this.parent = parent;\n    this.hash = hash;\n    this.data = data;\n    this.index = index;\n  }\n}\n\nexport default Node;\n"],"mappings":"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","names":[]}