import{concat as l,hexlify as c,arrayify as s,zeroPad as u}from"@ethersproject/bytes";import{hash as n}from"@fuel-ts/hasher";import{randomBytes as P}from"@fuel-ts/keystore";import{ec as p}from"elliptic";function o(){return new p("secp256k1")}var y=class{constructor(e){typeof e=="string"&&e.match(/^[0-9a-f]*$/i)&&e.length===64&&(e=`0x${e}`);let r=s(e),t=o().keyFromPrivate(r,"hex");this.compressedPublicKey=c(t.getPublic(!0,"array")),this.publicKey=c(t.getPublic(!1,"array").slice(1)),this.privateKey=c(r),this.address=n(this.publicKey)}sign(e){let t=o().keyFromPrivate(s(this.privateKey),"hex").sign(s(e),{canonical:!0}),a=u(t.r.toArray(),32),i=u(t.s.toArray(),32);return i[0]|=(t.recoveryParam||0)<<7,c(l([a,i]))}addPoint(e){let r=o().keyFromPublic(s(this.compressedPublicKey)),t=o().keyFromPublic(s(e)),a=r.getPublic().add(t.getPublic());return c(a.encode("array",!0))}static recoverPublicKey(e,r){let t=s(r),a=t.slice(0,32),i=t.slice(32,64),d=(i[0]&128)>>7;return i[0]&=127,o().recoverPubKey(s(e),{r:a,s:i},d).encode("array",!1).slice(1)}static recoverAddress(e,r){return n(y.recoverPublicKey(e,r))}static generatePrivateKey(e){return e?n(l([P(32),s(e)])):P(32)}static extendPublicKey(e){let r=o().keyFromPublic(s(e));return c(r.getPublic(!1,"array").slice(1))}},f=y;export{f as Signer,o as getCurve};
//# sourceMappingURL=index.mjs.map