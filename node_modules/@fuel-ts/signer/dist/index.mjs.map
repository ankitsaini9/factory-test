{"version":3,"sources":["../src/signer.ts"],"sourcesContent":["import type { BytesLike } from '@ethersproject/bytes';\nimport { concat, hexlify, arrayify, zeroPad } from '@ethersproject/bytes';\nimport { hash } from '@fuel-ts/hasher';\nimport { randomBytes } from '@fuel-ts/keystore';\nimport { ec as EC } from 'elliptic';\n\n/**\n * Return elliptic instance with curve secp256k1\n */\nexport function getCurve() {\n  return new EC('secp256k1');\n}\n\nclass Signer {\n  readonly address: string;\n\n  readonly publicKey: string;\n\n  readonly compressedPublicKey: string;\n\n  readonly privateKey: string;\n\n  /**\n   * Create a Signer instance from a given private key\n   *\n   * @param privateKey - The private key to use for signing\n   * @returns A new Signer instance\n   */\n  constructor(privateKey: BytesLike) {\n    // A lot of common tools do not prefix private keys with a 0x\n    if (typeof privateKey === 'string') {\n      if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {\n        // eslint-disable-next-line no-param-reassign\n        privateKey = `0x${privateKey}`;\n      }\n    }\n\n    // Convert to byte array, normalize private key input allowing it to be BytesLike\n    // like remove 0x prefix and accept array of bytes\n    const privateKeyBytes = arrayify(privateKey);\n    const keyPair = getCurve().keyFromPrivate(privateKeyBytes, 'hex');\n\n    // @TODO: defineReadOnly these properties\n    // Slice(1) removes the encoding scheme from the public key\n    this.compressedPublicKey = hexlify(keyPair.getPublic(true, 'array'));\n    this.publicKey = hexlify(keyPair.getPublic(false, 'array').slice(1));\n    this.privateKey = hexlify(privateKeyBytes);\n    this.address = hash(this.publicKey);\n  }\n\n  /**\n   * Sign data using the Signer instance\n   *\n   * Signature is a 64 byte array of the concatenated r and s values with the compressed recoveryParam byte. [Read more](FuelLabs/fuel-specs/specs/protocol/cryptographic_primitives.md#public-key-cryptography)\n   *\n   * @param data - The data to be sign\n   * @returns hashed signature\n   */\n  sign(data: BytesLike) {\n    const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey), 'hex');\n    const signature = keyPair.sign(arrayify(data), {\n      canonical: true,\n    });\n    const r = zeroPad(signature.r.toArray(), 32);\n    const s = zeroPad(signature.s.toArray(), 32);\n\n    // add recoveryParam to first s byte\n    s[0] |= (signature.recoveryParam || 0) << 7;\n\n    return hexlify(concat([r, s]));\n  }\n\n  /**\n   * Add point on the current elliptic curve\n   *\n   * @param point - Point to add on the curve\n   * @returns compressed point on the curve\n   */\n  addPoint(point: BytesLike) {\n    const p0 = getCurve().keyFromPublic(arrayify(this.compressedPublicKey));\n    const p1 = getCurve().keyFromPublic(arrayify(point));\n    const result = p0.getPublic().add(p1.getPublic());\n\n    return hexlify(result.encode('array', true));\n  }\n\n  /**\n   * Recover the public key from a signature performed with [`sign`](#sign).\n   *\n   * @param data - Data\n   * @param signature - hashed signature\n   * @returns public key from signature from the\n   */\n  static recoverPublicKey(data: BytesLike, signature: BytesLike) {\n    const signedMessageBytes = arrayify(signature);\n    const r = signedMessageBytes.slice(0, 32);\n    const s = signedMessageBytes.slice(32, 64);\n    const recoveryParam = (s[0] & 0x80) >> 7;\n\n    // remove recoveryParam from s first byte\n    s[0] &= 0x7f;\n\n    const publicKey = getCurve()\n      .recoverPubKey(arrayify(data), { r, s }, recoveryParam)\n      .encode('array', false)\n      .slice(1);\n\n    return publicKey;\n  }\n\n  /**\n   * Recover the address from a signature performed with [`sign`](#sign).\n   *\n   * @param data - Data\n   * @param signature - Signature\n   * @returns address from signature. The address is a sha256 hash from the public key.\n   */\n  static recoverAddress(data: BytesLike, signature: BytesLike) {\n    return hash(Signer.recoverPublicKey(data, signature));\n  }\n\n  /**\n   * Generate a random privateKey\n   *\n   * @param entropy - Adds extra entropy to generate the privateKey\n   * @returns random 32-byte hashed\n   */\n  static generatePrivateKey(entropy?: BytesLike) {\n    return entropy ? hash(concat([randomBytes(32), arrayify(entropy)])) : randomBytes(32);\n  }\n\n  /**\n   * Extended publicKey from a compact publicKey\n   *\n   * @param publicKey - Compact publicKey\n   * @returns extended publicKey\n   */\n  static extendPublicKey(publicKey: BytesLike) {\n    const keyPair = getCurve().keyFromPublic(arrayify(publicKey));\n    return hexlify(keyPair.getPublic(false, 'array').slice(1));\n  }\n}\n\nexport default Signer;\n"],"mappings":"AACA,sFACA,uCACA,gDACA,8BAKO,YAAoB,CACzB,MAAO,IAAI,GAAG,WAAW,CAC3B,CAEA,WAAa,CAeX,YAAY,EAAuB,CAEjC,AAAI,MAAO,IAAe,UACpB,EAAW,MAAM,cAAc,GAAK,EAAW,SAAW,IAE5D,GAAa,KAAK,KAMtB,GAAM,GAAkB,EAAS,CAAU,EACrC,EAAU,EAAS,EAAE,eAAe,EAAiB,KAAK,EAIhE,KAAK,oBAAsB,EAAQ,EAAQ,UAAU,GAAM,OAAO,CAAC,EACnE,KAAK,UAAY,EAAQ,EAAQ,UAAU,GAAO,OAAO,EAAE,MAAM,CAAC,CAAC,EACnE,KAAK,WAAa,EAAQ,CAAe,EACzC,KAAK,QAAU,EAAK,KAAK,SAAS,CACpC,CAUA,KAAK,EAAiB,CAEpB,GAAM,GAAY,AADF,EAAS,EAAE,eAAe,EAAS,KAAK,UAAU,EAAG,KAAK,EAChD,KAAK,EAAS,CAAI,EAAG,CAC7C,UAAW,EACb,CAAC,EACK,EAAI,EAAQ,EAAU,EAAE,QAAQ,EAAG,EAAE,EACrC,EAAI,EAAQ,EAAU,EAAE,QAAQ,EAAG,EAAE,EAG3C,SAAE,IAAO,GAAU,eAAiB,IAAM,EAEnC,EAAQ,EAAO,CAAC,EAAG,CAAC,CAAC,CAAC,CAC/B,CAQA,SAAS,EAAkB,CACzB,GAAM,GAAK,EAAS,EAAE,cAAc,EAAS,KAAK,mBAAmB,CAAC,EAChE,EAAK,EAAS,EAAE,cAAc,EAAS,CAAK,CAAC,EAC7C,EAAS,EAAG,UAAU,EAAE,IAAI,EAAG,UAAU,CAAC,EAEhD,MAAO,GAAQ,EAAO,OAAO,QAAS,EAAI,CAAC,CAC7C,OASO,kBAAiB,EAAiB,EAAsB,CAC7D,GAAM,GAAqB,EAAS,CAAS,EACvC,EAAI,EAAmB,MAAM,EAAG,EAAE,EAClC,EAAI,EAAmB,MAAM,GAAI,EAAE,EACnC,EAAiB,GAAE,GAAK,MAAS,EAGvC,SAAE,IAAM,IAEU,EAAS,EACxB,cAAc,EAAS,CAAI,EAAG,CAAE,IAAG,GAAE,EAAG,CAAa,EACrD,OAAO,QAAS,EAAK,EACrB,MAAM,CAAC,CAGZ,OASO,gBAAe,EAAiB,EAAsB,CAC3D,MAAO,GAAK,EAAO,iBAAiB,EAAM,CAAS,CAAC,CACtD,OAQO,oBAAmB,EAAqB,CAC7C,MAAO,GAAU,EAAK,EAAO,CAAC,EAAY,EAAE,EAAG,EAAS,CAAO,CAAC,CAAC,CAAC,EAAI,EAAY,EAAE,CACtF,OAQO,iBAAgB,EAAsB,CAC3C,GAAM,GAAU,EAAS,EAAE,cAAc,EAAS,CAAS,CAAC,EAC5D,MAAO,GAAQ,EAAQ,UAAU,GAAO,OAAO,EAAE,MAAM,CAAC,CAAC,CAC3D,CACF,EAEO,EAAQ","names":[]}