var k=Object.defineProperty;var S=Object.getOwnPropertySymbols;var K=Object.prototype.hasOwnProperty,L=Object.prototype.propertyIsEnumerable;var C=(r,n,t)=>n in r?k(r,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[n]=t,P=(r,n)=>{for(var t in n||(n={}))K.call(n,t)&&C(r,t,n[t]);if(S)for(var t of S(n))L.call(n,t)&&C(r,t,n[t]);return r};var v=(r=>typeof require!="undefined"?require:typeof Proxy!="undefined"?new Proxy(r,{get:(n,t)=>(typeof require!="undefined"?require:n)[t]}):r)(function(r){if(typeof require!="undefined")return require.apply(this,arguments);throw new Error('Dynamic require of "'+r+'" is not supported')});var N=(r,n)=>()=>(r&&(n=r(r=0)),n);var o=N(()=>{});o();o();o();o();o();import{arrayify as j}from"@ethersproject/bytes";o();var l,w="Node";typeof globalThis<"u"&&globalThis.crypto&&(l=globalThis.crypto,w="Web");if(!l&&typeof v=="function")try{l=v("crypto"),w="Node"}catch(r){console.error("keystore expects a standard Web browser or Node environment.",r)}var f=l,g=w;o();var y=r=>g==="Node"?f.randomBytes(r):f.getRandomValues(new Uint8Array(r));o();import{coinQuantityfy as G,ScriptTransactionRequest as M}from"@fuel-ts/providers";o();import{NativeAssetId as h}from"@fuel-ts/constants";import{hashMessage as E,hashTransaction as U}from"@fuel-ts/hasher";import{HDWallet as b}from"@fuel-ts/hdwallet";import{AbstractWallet as F}from"@fuel-ts/interfaces";import{Mnemonic as D}from"@fuel-ts/mnemonic";import{ScriptTransactionRequest as z,transactionRequestify as T,Provider as I}from"@fuel-ts/providers";import{Signer as B}from"@fuel-ts/signer";var Q="http://127.0.0.1:4000/graphql",d=class extends F{constructor(t,e=Q){super();let s=new B(t);this.signer=()=>s,this.provider=this.connect(e)}get address(){return this.signer().address}get privateKey(){return this.signer().privateKey}get publicKey(){return this.signer().publicKey}connect(t){if(t)typeof t=="string"?this.provider=new I(t):this.provider=t;else throw new Error("Provider is required");return this.provider}signMessage(t){return this.signer().sign(E(t))}signTransaction(t){let e=T(t),s=U(e);return this.signer().sign(s)}populateTransactionWitnessesSignature(t){let e=T(t),s=e.getCoinInputWitnessIndexByOwner(this.address);if(typeof s=="number"){let i=this.signTransaction(e);e.updateWitness(s,i)}return e}async getCoinsToSpend(t){return this.provider.getCoinsToSpend(this.address,t)}async getCoins(){let t=[],s;for(;;){let i=await this.provider.getCoins(this.address,void 0,{first:9999,after:s});if(t.push(...i),!(i.length>=9999))break;throw new Error(`Wallets with more than ${9999} coins are not yet supported`)}return t}async getBalance(t=h){return await this.provider.getBalance(this.address,t)}async getBalances(){let t=[],s;for(;;){let i=await this.provider.getBalances(this.address,{first:9999,after:s});if(t.push(...i),!(i.length>=9999))break;throw new Error(`Wallets with more than ${9999} balances are not yet supported`)}return t}async fund(t){let e=t.calculateFee(),s=await this.getCoinsToSpend([[e,h]]);t.addCoins(s)}async transfer(t,e,s=h,i={}){let u=P({gasLimit:1e4},i),a=new z(u);a.addCoinOutput(t,e,s);let R=a.calculateFee(),W=await this.getCoinsToSpend([[e,s],[R,h]]);return a.addCoins(W),this.sendTransaction(a)}async sendTransaction(t){let e=T(t);return this.provider.sendTransaction(this.populateTransactionWitnessesSignature(e))}async simulateTransaction(t){let e=T(t);return this.provider.call(this.populateTransactionWitnessesSignature(e),{utxoValidation:!0})}static generate(t){let e=B.generatePrivateKey(t==null?void 0:t.entropy);return new d(e,t==null?void 0:t.provider)}static fromSeed(t,e){let i=b.fromSeed(t).derivePath(e||d.defaultPath);return new d(i.privateKey)}static fromMnemonic(t,e,s){let i=D.mnemonicToSeed(t,s),a=b.fromSeed(i).derivePath(e||d.defaultPath);return new d(a.privateKey)}static fromExtendedKey(t){let e=b.fromExtendedKey(t);return new d(e.privateKey)}},m=d;m.defaultPath="m/44'/1179993420'/0'/0/0";var J=async(r,n)=>{let t=new m(process.env.GENESIS_SECRET||y(32),r.provider),e=await t.getCoinsToSpend(n),s=new M({gasLimit:1e4});s.addCoins(e),n.map(G).forEach(({amount:u,assetId:a})=>s.addCoinOutput(r.address,u,a)),await(await t.sendTransaction(s)).wait()},Lt=async(r,n)=>{let t=m.generate({provider:r});return n&&await J(t,n),t};export{Lt as generateTestWallet,J as seedWallet};
//# sourceMappingURL=test-utils.mjs.map