{"version":3,"sources":["../../../node_modules/.pnpm/tsup@5.12.6_v73b3xgw6ydytm4gxrazwris7i/node_modules/tsup/assets/esm_shims.js","../src/index.ts","../src/wallet.ts","../src/test-utils.ts","../../keystore/src/index.ts","../../keystore/src/keystore.ts","../../keystore/src/aes-ctr-node.ts","../../keystore/src/aes-ctr.ts","../../keystore/src/universal-crypto.ts","../../keystore/src/randomBytes.ts","../../keystore/src/aes-ctr-web.ts"],"sourcesContent":["// Shim globals in esm bundle\nimport { fileURLToPath } from 'url'\nimport path from 'path'\n\nconst getFilename = () => fileURLToPath(import.meta.url)\nconst getDirname = () => path.dirname(getFilename())\n\nexport const __dirname = /* @__PURE__ */ getDirname()\nexport const __filename = /* @__PURE__ */ getFilename()\n","export { default as Wallet } from './wallet';\nexport * as TestUtils from './test-utils';\n","import type { BytesLike } from '@ethersproject/bytes';\nimport { NativeAssetId } from '@fuel-ts/constants';\nimport { hashMessage, hashTransaction } from '@fuel-ts/hasher';\nimport { HDWallet } from '@fuel-ts/hdwallet';\nimport { AbstractWallet } from '@fuel-ts/interfaces';\nimport type { BigNumberish } from '@fuel-ts/math';\nimport { Mnemonic } from '@fuel-ts/mnemonic';\nimport { ScriptTransactionRequest, transactionRequestify, Provider } from '@fuel-ts/providers';\nimport type {\n  TransactionRequest,\n  TransactionResponse,\n  Coin,\n  TransactionRequestLike,\n  CoinQuantityLike,\n  CoinQuantity,\n  CallResult,\n} from '@fuel-ts/providers';\nimport { Signer } from '@fuel-ts/signer';\n\nimport type { GenerateOptions } from './types/GenerateOptions';\n\n// TODO: import using .env file\nconst FUEL_NETWORK_URL = 'http://127.0.0.1:4000/graphql';\n\nexport default class Wallet extends AbstractWallet {\n  /* default HDWallet path */\n  static defaultPath = \"m/44'/1179993420'/0'/0/0\";\n\n  provider: Provider;\n\n  readonly signer: () => Signer;\n\n  constructor(privateKey: BytesLike, provider: string | Provider = FUEL_NETWORK_URL) {\n    super();\n    const signer = new Signer(privateKey);\n\n    this.signer = () => signer;\n    this.provider = this.connect(provider);\n  }\n\n  get address(): string {\n    return this.signer().address;\n  }\n\n  get privateKey(): string {\n    return this.signer().privateKey;\n  }\n\n  get publicKey(): string {\n    return this.signer().publicKey;\n  }\n\n  /**\n   * Change provider connection\n   */\n  connect(provider: string | Provider) {\n    if (!provider) {\n      throw new Error('Provider is required');\n    } else if (typeof provider === 'string') {\n      this.provider = new Provider(provider);\n    } else {\n      this.provider = provider;\n    }\n    return this.provider;\n  }\n\n  /**\n   * Sign message with wallet instance privateKey\n   *\n   * @param message - Message\n   * @returns string - Signature a ECDSA 64 bytes\n   */\n  signMessage(message: string): string {\n    return this.signer().sign(hashMessage(message));\n  }\n\n  /**\n   * Sign transaction with wallet instance privateKey\n   *\n   * @param transactionRequestLike - TransactionRequestLike\n   * @returns string - Signature a ECDSA 64 bytes\n   */\n  signTransaction(transactionRequestLike: TransactionRequestLike): string {\n    const transactionRequest = transactionRequestify(transactionRequestLike);\n    const hashedTransaction = hashTransaction(transactionRequest);\n    const signature = this.signer().sign(hashedTransaction);\n\n    return signature;\n  }\n\n  populateTransactionWitnessesSignature(transactionRequestLike: TransactionRequestLike) {\n    const transactionRequest = transactionRequestify(transactionRequestLike);\n\n    const witnessIndex = transactionRequest.getCoinInputWitnessIndexByOwner(this.address);\n    if (typeof witnessIndex === 'number') {\n      const signedTransaction = this.signTransaction(transactionRequest);\n      transactionRequest.updateWitness(witnessIndex, signedTransaction);\n    }\n\n    return transactionRequest;\n  }\n\n  /**\n   * Returns coins satisfying the spend query.\n   */\n  async getCoinsToSpend(quantities: CoinQuantityLike[]): Promise<Coin[]> {\n    return this.provider.getCoinsToSpend(this.address, quantities);\n  }\n\n  /**\n   * Gets coins owned by the wallet address.\n   */\n  async getCoins(): Promise<Coin[]> {\n    const coins = [];\n\n    const pageSize = 9999;\n    let cursor;\n    // eslint-disable-next-line no-unreachable-loop\n    for (;;) {\n      const pageCoins = await this.provider.getCoins(this.address, undefined, {\n        first: pageSize,\n        after: cursor,\n      });\n\n      coins.push(...pageCoins);\n\n      const hasNextPage = pageCoins.length >= pageSize;\n      if (!hasNextPage) {\n        break;\n      }\n\n      // TODO: implement pagination\n      throw new Error(`Wallets with more than ${pageSize} coins are not yet supported`);\n    }\n\n    return coins;\n  }\n\n  /**\n   * Gets balance for the given asset.\n   */\n  async getBalance(assetId: BytesLike = NativeAssetId): Promise<bigint> {\n    const amount = await this.provider.getBalance(this.address, assetId);\n    return amount;\n  }\n\n  /**\n   * Gets balances.\n   */\n  async getBalances(): Promise<CoinQuantity[]> {\n    const balances = [];\n\n    const pageSize = 9999;\n    let cursor;\n    // eslint-disable-next-line no-unreachable-loop\n    for (;;) {\n      const pageBalances = await this.provider.getBalances(this.address, {\n        first: pageSize,\n        after: cursor,\n      });\n\n      balances.push(...pageBalances);\n\n      const hasNextPage = pageBalances.length >= pageSize;\n      if (!hasNextPage) {\n        break;\n      }\n\n      // TODO: implement pagination\n      throw new Error(`Wallets with more than ${pageSize} balances are not yet supported`);\n    }\n\n    return balances;\n  }\n\n  /**\n   * Adds coins to the transaction enough to fund it.\n   */\n  async fund<T extends TransactionRequest>(request: T): Promise<void> {\n    const feeAmount = request.calculateFee();\n    const coins = await this.getCoinsToSpend([[feeAmount, NativeAssetId]]);\n\n    request.addCoins(coins);\n  }\n\n  /**\n   * Returns coins satisfying the spend query.\n   */\n  async transfer(\n    /** Address of the destination */\n    destination: BytesLike,\n    /** Amount of coins */\n    amount: BigNumberish,\n    /** Asset ID of coins */\n    assetId: BytesLike = NativeAssetId,\n    /** Tx Params */\n    txParams: Pick<TransactionRequestLike, 'gasLimit' | 'gasPrice' | 'bytePrice' | 'maturity'> = {}\n  ): Promise<TransactionResponse> {\n    const params = { gasLimit: 10000, ...txParams };\n    const request = new ScriptTransactionRequest(params);\n    request.addCoinOutput(destination, amount, assetId);\n    const feeAmount = request.calculateFee();\n    const coins = await this.getCoinsToSpend([\n      [amount, assetId],\n      [feeAmount, NativeAssetId],\n    ]);\n    request.addCoins(coins);\n\n    return this.sendTransaction(request);\n  }\n\n  /**\n   * Populates witnesses signature and send it to the network using `provider.sendTransaction`.\n   *\n   * @param transactionRequest - TransactionRequest\n   * @returns TransactionResponse\n   */\n  async sendTransaction(\n    transactionRequestLike: TransactionRequestLike\n  ): Promise<TransactionResponse> {\n    const transactionRequest = transactionRequestify(transactionRequestLike);\n\n    return this.provider.sendTransaction(\n      this.populateTransactionWitnessesSignature(transactionRequest)\n    );\n  }\n\n  /**\n   * Populates witnesses signature and send a call it to the network using `provider.call`.\n   *\n   * @param transactionRequest - TransactionRequest\n   * @returns CallResult\n   */\n  async simulateTransaction(transactionRequestLike: TransactionRequestLike): Promise<CallResult> {\n    const transactionRequest = transactionRequestify(transactionRequestLike);\n\n    return this.provider.call(this.populateTransactionWitnessesSignature(transactionRequest), {\n      utxoValidation: true,\n    });\n  }\n\n  /**\n   * Generate a new Wallet with a random keyPair\n   *\n   * @param options - GenerateOptions\n   * @returns wallet - Wallet instance\n   */\n  static generate(generateOptions?: GenerateOptions) {\n    const privateKey = Signer.generatePrivateKey(generateOptions?.entropy);\n\n    return new Wallet(privateKey, generateOptions?.provider);\n  }\n\n  /**\n   * Create wallet from a seed\n   */\n  static fromSeed(seed: string, path?: string): Wallet {\n    const hdWallet = HDWallet.fromSeed(seed);\n    const childWallet = hdWallet.derivePath(path || Wallet.defaultPath);\n\n    return new Wallet(<string>childWallet.privateKey);\n  }\n\n  /**\n   * Create wallet from mnemonic phrase\n   */\n  static fromMnemonic(mnemonic: string, path?: string, passphrase?: BytesLike): Wallet {\n    const seed = Mnemonic.mnemonicToSeed(mnemonic, passphrase);\n    const hdWallet = HDWallet.fromSeed(seed);\n    const childWallet = hdWallet.derivePath(path || Wallet.defaultPath);\n\n    return new Wallet(<string>childWallet.privateKey);\n  }\n\n  /**\n   * Create wallet from extended key\n   */\n  static fromExtendedKey(extendedKey: string): Wallet {\n    const hdWallet = HDWallet.fromExtendedKey(extendedKey);\n\n    return new Wallet(<string>hdWallet.privateKey);\n  }\n}\n","import { randomBytes } from '@fuel-ts/keystore';\nimport type { Provider, CoinQuantityLike } from '@fuel-ts/providers';\nimport { coinQuantityfy, ScriptTransactionRequest } from '@fuel-ts/providers';\n\nimport Wallet from './wallet';\n\nexport const seedWallet = async (wallet: Wallet, quantities: CoinQuantityLike[]) => {\n  const genesisWallet = new Wallet(process.env.GENESIS_SECRET || randomBytes(32), wallet.provider);\n  // Connect to the same Provider as wallet\n  const coins = await genesisWallet.getCoinsToSpend(quantities);\n  // Create transaction\n  const request = new ScriptTransactionRequest({\n    gasLimit: 10000,\n  });\n  request.addCoins(coins);\n  quantities\n    .map(coinQuantityfy)\n    .forEach(({ amount, assetId }) => request.addCoinOutput(wallet.address, amount, assetId));\n  const response = await genesisWallet.sendTransaction(request);\n\n  await response.wait();\n};\n\nexport const generateTestWallet = async (\n  provider: Provider,\n  quantities?: CoinQuantityLike[]\n): Promise<Wallet> => {\n  const wallet = Wallet.generate({ provider });\n  if (quantities) {\n    await seedWallet(wallet, quantities);\n  }\n  return wallet;\n};\n","export * from './keystore';\n","import type { Keystore } from './aes-ctr';\nimport { encrypt as encNode, decrypt as decNode } from './aes-ctr-node';\nimport { encrypt as encWeb, decrypt as decWeb } from './aes-ctr-web';\nimport { strategy } from './universal-crypto';\n\nexport type { Keystore } from './aes-ctr';\nexport { keyFromPassword } from './aes-ctr';\nexport { randomBytes } from './randomBytes';\n\n/**\n * Encrypts a data object that can be any serializable value using\n * a provided password.\n *\n * @returns Promise<Keystore> Keystore object\n */\nexport async function encrypt<T>(password: string, data: T): Promise<Keystore> {\n  return strategy === 'Node' ? encNode<T>(password, data) : encWeb<T>(password, data);\n}\n\n/**\n * Given a password and a keystore object, decrypts the text and returns\n * the resulting value\n *\n *  @returns Promise<T> T object\n */\nexport async function decrypt<T>(password: string, keystore: Keystore): Promise<T> {\n  return strategy === 'Node' ? decNode<T>(password, keystore) : decWeb<T>(password, keystore);\n}\n","import type { Keystore } from './aes-ctr';\nimport { bufferFromString, stringFromBuffer, keyFromPassword } from './aes-ctr';\nimport { randomBytes } from './randomBytes';\nimport { crypto } from './universal-crypto';\n\nconst ALGORITHM = 'aes-256-ctr';\n\n/**\n * Encrypts a data object that can be any serializable value using\n * a provided password.\n *\n * @returns Promise<Keystore> object\n */\nexport async function encrypt<T>(password: string, data: T): Promise<Keystore> {\n  const iv = randomBytes(16);\n  const salt = randomBytes(32);\n  const secret = keyFromPassword(password, salt);\n  const dataBuffer = Uint8Array.from(Buffer.from(JSON.stringify(data), 'utf-8'));\n\n  const cipher = crypto.createCipheriv(ALGORITHM, secret, iv);\n  let cipherData = cipher.update(dataBuffer);\n  cipherData = Buffer.concat([cipherData, cipher.final()]);\n\n  return {\n    data: stringFromBuffer(cipherData),\n    iv: stringFromBuffer(iv),\n    salt: stringFromBuffer(salt),\n  };\n}\n\n/**\n * Given a password and a keystore object, decrypts the text and returns\n * the resulting value\n */\nexport async function decrypt<T>(password: string, keystore: Keystore): Promise<T> {\n  const iv = bufferFromString(keystore.iv);\n  const salt = bufferFromString(keystore.salt);\n  const secret = keyFromPassword(password, salt);\n  const encryptedText = bufferFromString(keystore.data);\n\n  const decipher = crypto.createDecipheriv(ALGORITHM, secret, iv);\n  const decrypted = decipher.update(encryptedText);\n  const deBuff = Buffer.concat([decrypted, decipher.final()]);\n  const decryptedData = Buffer.from(deBuff).toString('utf-8');\n\n  try {\n    return JSON.parse(decryptedData);\n  } catch {\n    throw new Error('Invalid credentials');\n  }\n}\n","import { arrayify } from '@ethersproject/bytes';\nimport { pbkdf2 } from '@ethersproject/pbkdf2';\n\nimport { strategy } from './universal-crypto';\n\nexport interface Keystore {\n  data: string;\n  iv: string;\n  salt: string;\n}\n\nexport function bufferFromString(\n  string: string,\n  encoding: 'utf-8' | 'base64' = 'base64'\n): Uint8Array {\n  if (strategy === 'Node') {\n    return Buffer.from(string, encoding);\n  }\n  if (encoding === 'utf-8') {\n    return new TextEncoder().encode(string);\n  }\n\n  return new Uint8Array(\n    atob(string)\n      .split('')\n      .map((c) => c.charCodeAt(0))\n  );\n}\n\nexport function stringFromBuffer(\n  buffer: Uint8Array,\n  encoding: 'utf-8' | 'base64' = 'base64'\n): string {\n  if (strategy === 'Node') {\n    return Buffer.from(buffer).toString(encoding);\n  }\n\n  return btoa(String.fromCharCode.apply(null, new Uint8Array(buffer) as unknown as number[]));\n}\n\n/**\n * Generate a pbkdf2 key from a password and random salt\n */\nexport function keyFromPassword(password: string, saltBuffer: Uint8Array): Uint8Array {\n  const passBuffer = bufferFromString(String(password).normalize('NFKC'), 'utf-8');\n  const key = pbkdf2(passBuffer, saltBuffer, 100000, 32, 'sha256');\n\n  return arrayify(key);\n}\n","import type { createCipheriv, createDecipheriv } from 'crypto';\n\ntype UniversalCrypto = {\n  getRandomValues: (length: number) => Uint8Array;\n  randomBytes: (length: number) => Uint8Array;\n  subtle: SubtleCrypto;\n  createCipheriv: typeof createCipheriv;\n  createDecipheriv: typeof createDecipheriv;\n};\nlet selectedCrypto;\nlet selectedStrategy: 'Node' | 'Web' = 'Node';\n\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nif (typeof globalThis !== 'undefined' && globalThis.crypto) {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  selectedCrypto = globalThis.crypto;\n  selectedStrategy = 'Web';\n}\n\nif (!selectedCrypto && typeof require === 'function') {\n  try {\n    // eslint-disable-next-line global-require\n    selectedCrypto = require('crypto');\n    selectedStrategy = 'Node';\n  } catch (error) {\n    // eslint-disable-next-line no-console\n    console.error('keystore expects a standard Web browser or Node environment.', error);\n  }\n}\n\nexport const crypto: UniversalCrypto = selectedCrypto;\nexport const strategy = selectedStrategy;\n","import { crypto, strategy } from './universal-crypto';\n\nexport const randomBytes = (length: number) =>\n  strategy === 'Node'\n    ? crypto.randomBytes(length)\n    : crypto.getRandomValues(new Uint8Array(length) as unknown as number);\n","import type { Keystore } from './aes-ctr';\nimport { bufferFromString, stringFromBuffer, keyFromPassword } from './aes-ctr';\nimport { randomBytes } from './randomBytes';\nimport { crypto } from './universal-crypto';\n\nconst ALGORITHM = 'AES-CTR';\n\n/**\n * Encrypts a data object that can be any serializable value using\n * a provided password.\n *\n * @returns Promise<Keystore> object\n */\nexport async function encrypt<T>(password: string, data: T): Promise<Keystore> {\n  const iv = randomBytes(16);\n  const salt = randomBytes(32);\n  const secret = keyFromPassword(password, salt);\n  const dataBuffer = Uint8Array.from(Buffer.from(JSON.stringify(data), 'utf-8'));\n  const alg = {\n    name: ALGORITHM,\n    counter: iv,\n    length: 64,\n  };\n  const key = await crypto.subtle.importKey('raw', secret, alg, false, ['encrypt']);\n  const encBuffer = await crypto.subtle.encrypt(alg, key, dataBuffer);\n\n  return {\n    data: stringFromBuffer(encBuffer),\n    iv: stringFromBuffer(iv),\n    salt: stringFromBuffer(salt),\n  };\n}\n\n/**\n * Given a password and a keystore object, decrypts the text and returns\n * the resulting value\n */\nexport async function decrypt<T>(password: string, keystore: Keystore): Promise<T> {\n  const iv = bufferFromString(keystore.iv);\n  const salt = bufferFromString(keystore.salt);\n  const secret = keyFromPassword(password, salt);\n  const encryptedText = bufferFromString(keystore.data);\n\n  const alg = {\n    name: ALGORITHM,\n    counter: iv,\n    length: 64,\n  };\n  const key = await crypto.subtle.importKey('raw', secret, alg, false, ['decrypt']);\n\n  const ptBuffer = await crypto.subtle.decrypt(alg, key, encryptedText);\n  const decryptedData = new TextDecoder().decode(ptBuffer);\n\n  try {\n    return JSON.parse(decryptedData);\n  } catch {\n    throw new Error('Invalid credentials');\n  }\n}\n"],"mappings":"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","names":[]}