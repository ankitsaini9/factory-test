var C=Object.defineProperty;var S=Object.getOwnPropertySymbols;var N=Object.prototype.hasOwnProperty,A=Object.prototype.propertyIsEnumerable;var x=(r,n,t)=>n in r?C(r,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[n]=t,P=(r,n)=>{for(var t in n||(n={}))N.call(n,t)&&x(r,t,n[t]);if(S)for(var t of S(n))A.call(n,t)&&x(r,t,n[t]);return r};var v=(r=>typeof require!="undefined"?require:typeof Proxy!="undefined"?new Proxy(r,{get:(n,t)=>(typeof require!="undefined"?require:n)[t]}):r)(function(r){if(typeof require!="undefined")return require.apply(this,arguments);throw new Error('Dynamic require of "'+r+'" is not supported')});var q=(r,n)=>()=>(r&&(n=r(r=0)),n);var U=(r,n)=>{for(var t in n)C(r,t,{get:n[t],enumerable:!0})};var o=q(()=>{});o();o();import{NativeAssetId as l}from"@fuel-ts/constants";import{hashMessage as E,hashTransaction as F}from"@fuel-ts/hasher";import{HDWallet as w}from"@fuel-ts/hdwallet";import{AbstractWallet as D}from"@fuel-ts/interfaces";import{Mnemonic as z}from"@fuel-ts/mnemonic";import{ScriptTransactionRequest as I,transactionRequestify as g,Provider as Q}from"@fuel-ts/providers";import{Signer as B}from"@fuel-ts/signer";var G="http://127.0.0.1:4000/graphql",d=class extends D{constructor(t,e=G){super();let s=new B(t);this.signer=()=>s,this.provider=this.connect(e)}get address(){return this.signer().address}get privateKey(){return this.signer().privateKey}get publicKey(){return this.signer().publicKey}connect(t){if(t)typeof t=="string"?this.provider=new Q(t):this.provider=t;else throw new Error("Provider is required");return this.provider}signMessage(t){return this.signer().sign(E(t))}signTransaction(t){let e=g(t),s=F(e);return this.signer().sign(s)}populateTransactionWitnessesSignature(t){let e=g(t),s=e.getCoinInputWitnessIndexByOwner(this.address);if(typeof s=="number"){let i=this.signTransaction(e);e.updateWitness(s,i)}return e}async getCoinsToSpend(t){return this.provider.getCoinsToSpend(this.address,t)}async getCoins(){let t=[],s;for(;;){let i=await this.provider.getCoins(this.address,void 0,{first:9999,after:s});if(t.push(...i),!(i.length>=9999))break;throw new Error(`Wallets with more than ${9999} coins are not yet supported`)}return t}async getBalance(t=l){return await this.provider.getBalance(this.address,t)}async getBalances(){let t=[],s;for(;;){let i=await this.provider.getBalances(this.address,{first:9999,after:s});if(t.push(...i),!(i.length>=9999))break;throw new Error(`Wallets with more than ${9999} balances are not yet supported`)}return t}async fund(t){let e=t.calculateFee(),s=await this.getCoinsToSpend([[e,l]]);t.addCoins(s)}async transfer(t,e,s=l,i={}){let u=P({gasLimit:1e4},i),p=new I(u);p.addCoinOutput(t,e,s);let K=p.calculateFee(),L=await this.getCoinsToSpend([[e,s],[K,l]]);return p.addCoins(L),this.sendTransaction(p)}async sendTransaction(t){let e=g(t);return this.provider.sendTransaction(this.populateTransactionWitnessesSignature(e))}async simulateTransaction(t){let e=g(t);return this.provider.call(this.populateTransactionWitnessesSignature(e),{utxoValidation:!0})}static generate(t){let e=B.generatePrivateKey(t==null?void 0:t.entropy);return new d(e,t==null?void 0:t.provider)}static fromSeed(t,e){let i=w.fromSeed(t).derivePath(e||d.defaultPath);return new d(i.privateKey)}static fromMnemonic(t,e,s){let i=z.mnemonicToSeed(t,s),p=w.fromSeed(i).derivePath(e||d.defaultPath);return new d(p.privateKey)}static fromExtendedKey(t){let e=w.fromExtendedKey(t);return new d(e.privateKey)}},m=d;m.defaultPath="m/44'/1179993420'/0'/0/0";var k={};U(k,{generateTestWallet:()=>V,seedWallet:()=>R});o();o();o();o();o();import{arrayify as it}from"@ethersproject/bytes";o();var h,b="Node";typeof globalThis<"u"&&globalThis.crypto&&(h=globalThis.crypto,b="Web");if(!h&&typeof v=="function")try{h=v("crypto"),b="Node"}catch(r){console.error("keystore expects a standard Web browser or Node environment.",r)}var f=h,T=b;o();var y=r=>T==="Node"?f.randomBytes(r):f.getRandomValues(new Uint8Array(r));o();import{coinQuantityfy as O,ScriptTransactionRequest as H}from"@fuel-ts/providers";var R=async(r,n)=>{let t=new m(process.env.GENESIS_SECRET||y(32),r.provider),e=await t.getCoinsToSpend(n),s=new H({gasLimit:1e4});s.addCoins(e),n.map(O).forEach(({amount:u,assetId:p})=>s.addCoinOutput(r.address,u,p)),await(await t.sendTransaction(s)).wait()},V=async(r,n)=>{let t=m.generate({provider:r});return n&&await R(t,n),t};export{k as TestUtils,m as Wallet};
//# sourceMappingURL=index.mjs.map